{"ast":null,"code":"/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventTarget = require('../../eventtarget');\nvar Latch = require('../util/latch');\nvar _a = require('../util/sdp'),\n  getSdpFormat = _a.getSdpFormat,\n  updatePlanBTrackIdsToSSRCs = _a.updatePlanBTrackIdsToSSRCs,\n  updateUnifiedPlanTrackIdsToSSRCs = _a.updateUnifiedPlanTrackIdsToSSRCs;\nvar _b = require('../util'),\n  delegateMethods = _b.delegateMethods,\n  interceptEvent = _b.interceptEvent,\n  proxyProperties = _b.proxyProperties;\nvar isUnifiedPlan = getSdpFormat() === 'unified';\nvar updateTrackIdsToSSRCs = isUnifiedPlan ? updateUnifiedPlanTrackIdsToSSRCs : updatePlanBTrackIdsToSSRCs;\nvar SafariRTCPeerConnection = /** @class */function (_super) {\n  __extends(SafariRTCPeerConnection, _super);\n  function SafariRTCPeerConnection(configuration) {\n    var _this = _super.call(this) || this;\n    interceptEvent(_this, 'datachannel');\n    interceptEvent(_this, 'iceconnectionstatechange');\n    interceptEvent(_this, 'signalingstatechange');\n    interceptEvent(_this, 'track');\n    var peerConnection = new RTCPeerConnection(configuration);\n    Object.defineProperties(_this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _audioTransceiver: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _videoTransceiver: {\n        value: null,\n        writable: true\n      }\n    });\n    peerConnection.addEventListener('datachannel', function (event) {\n      shimDataChannel(event.channel);\n      _this.dispatchEvent(event);\n    });\n    peerConnection.addEventListener('iceconnectionstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (_this._isClosed) {\n        return;\n      }\n      _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n    });\n    peerConnection.addEventListener('signalingstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (_this._isClosed) {\n        return;\n      }\n      if (peerConnection.signalingState === 'stable') {\n        _this._appliedTracksToSSRCs = new Map(_this._tracksToSSRCs);\n      }\n      if (!_this._pendingLocalOffer && !_this._pendingRemoteOffer) {\n        _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n      }\n    });\n    // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n    // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n    // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n    // even though a new remote RTCSessionDescription had already been applied.\n    peerConnection.addEventListener('track', function (event) {\n      _this._pendingRemoteOffer = null;\n      _this.dispatchEvent(event);\n    });\n    proxyProperties(RTCPeerConnection.prototype, _this, peerConnection);\n    return _this;\n  }\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"localDescription\", {\n    get: function () {\n      return this._pendingLocalOffer || this._peerConnection.localDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"iceConnectionState\", {\n    get: function () {\n      return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"iceGatheringState\", {\n    get: function () {\n      return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"remoteDescription\", {\n    get: function () {\n      return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SafariRTCPeerConnection.prototype, \"signalingState\", {\n    get: function () {\n      if (this._isClosed) {\n        return 'closed';\n      } else if (this._pendingLocalOffer) {\n        return 'have-local-offer';\n      } else if (this._pendingRemoteOffer) {\n        return 'have-remote-offer';\n      }\n      return this._peerConnection.signalingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SafariRTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n    var _this = this;\n    if (this.signalingState === 'have-remote-offer') {\n      return this._signalingStateLatch.when('low').then(function () {\n        return _this._peerConnection.addIceCandidate(candidate);\n      });\n    }\n    return this._peerConnection.addIceCandidate(candidate);\n  };\n  SafariRTCPeerConnection.prototype.createOffer = function (options) {\n    var _this = this;\n    options = Object.assign({}, options);\n    // NOTE(mroberts): In general, this is not the way to do this; however, it's\n    // good enough for our application.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n      try {\n        this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n      try {\n        this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n          direction: 'recvonly'\n        }) : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n    return this._peerConnection.createOffer(options).then(function (offer) {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n      // then we no longer need to retain the rolled back tracks to SSRCs Map.\n      _this._rolledBackTracksToSSRCs.clear();\n      return new RTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(_this._tracksToSSRCs, offer.sdp)\n      });\n    });\n  };\n  SafariRTCPeerConnection.prototype.createAnswer = function (options) {\n    var _this = this;\n    if (this._pendingRemoteOffer) {\n      return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function () {\n        _this._signalingStateLatch.lower();\n        return _this._peerConnection.createAnswer();\n      }).then(function (answer) {\n        _this._pendingRemoteOffer = null;\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        _this._rolledBackTracksToSSRCs.clear();\n        return isUnifiedPlan ? new RTCSessionDescription({\n          type: answer.type,\n          sdp: updateTrackIdsToSSRCs(_this._tracksToSSRCs, answer.sdp)\n        }) : answer;\n      }, function (error) {\n        _this._pendingRemoteOffer = null;\n        throw error;\n      });\n    }\n    return this._peerConnection.createAnswer(options).then(function (answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      _this._rolledBackTracksToSSRCs.clear();\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(_this._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    });\n  };\n  SafariRTCPeerConnection.prototype.createDataChannel = function (label, dataChannelDict) {\n    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  };\n  SafariRTCPeerConnection.prototype.removeTrack = function (sender) {\n    sender.replaceTrack(null);\n    this._peerConnection.removeTrack(sender);\n  };\n  SafariRTCPeerConnection.prototype.setLocalDescription = function (description) {\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n    return setDescription(this, true, description);\n  };\n  SafariRTCPeerConnection.prototype.setRemoteDescription = function (description) {\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    return setDescription(this, false, description);\n  };\n  SafariRTCPeerConnection.prototype.close = function () {\n    var _this = this;\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    this._peerConnection.close();\n    setTimeout(function () {\n      _this.dispatchEvent(new Event('iceconnectionstatechange'));\n      _this.dispatchEvent(new Event('signalingstatechange'));\n    });\n  };\n  return SafariRTCPeerConnection;\n}(EventTarget);\ndelegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error(\"Cannot set \" + (local ? 'local' : 'remote') + \"\\n        offer in state \" + peerConnection.signalingState));\n    }\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description);\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function () {\n        return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error(\"Cannot rollback \\n        \" + (local ? 'local' : 'remote') + \" description in \" + peerConnection.signalingState));\n    }\n    clearPendingLocalOffer();\n    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n    return Promise.resolve().then(function () {\n      return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function () {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function () {\n    return peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (_a) {\n    var _b = _a.receiver,\n      receiver = _b === void 0 ? {} : _b;\n    var _c = receiver.track,\n      track = _c === void 0 ? {} : _c;\n    return track.kind === kind;\n  });\n}\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535 ? null : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n    }\n  });\n}\nmodule.exports = SafariRTCPeerConnection;","map":{"version":3,"mappings":"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","names":["EventTarget","require","Latch","getSdpFormat","updatePlanBTrackIdsToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","delegateMethods","interceptEvent","proxyProperties","isUnifiedPlan","updateTrackIdsToSSRCs","__extends","configuration","_super","_this","peerConnection","RTCPeerConnection","Object","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_audioTransceiver","_isClosed","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_signalingStateLatch","_tracksToSSRCs","_videoTransceiver","addEventListener","shimDataChannel","event","channel","dispatchEvent","_i","args","signalingState","prototype","SafariRTCPeerConnection","localDescription","iceConnectionState","iceGatheringState","remoteDescription","candidate","when","then","addIceCandidate","options","assign","offerToReceiveVideo","hasReceiversForTracksOfKind","offerToReceiveAudio","addTransceiver","direction","e","Promise","reject","createOffer","clear","RTCSessionDescription","type","offer","sdp","setRemoteDescription","lower","createAnswer","answer","error","label","dataChannelDict","dataChannel","createDataChannel","sender","replaceTrack","removeTrack","description","size","setDescription","close","setTimeout","Event","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setLocalDescription","setRemoteAnswer","Error","state","raise","previousSignalingState","resolve","kind","getTransceivers","find","_a","_b","receiver","track","maxPacketLifeTime","maxRetransmits","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/safari.js"],"sourcesContent":["/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nconst EventTarget = require('../../eventtarget');\nconst Latch = require('../util/latch');\nconst { getSdpFormat, updatePlanBTrackIdsToSSRCs, updateUnifiedPlanTrackIdsToSSRCs } = require('../util/sdp');\nconst { delegateMethods, interceptEvent, proxyProperties } = require('../util');\n\nconst isUnifiedPlan = getSdpFormat() === 'unified';\n\nconst updateTrackIdsToSSRCs = isUnifiedPlan\n  ? updateUnifiedPlanTrackIdsToSSRCs\n  : updatePlanBTrackIdsToSSRCs;\n\nclass SafariRTCPeerConnection extends EventTarget {\n  constructor(configuration) {\n    super();\n\n    interceptEvent(this, 'datachannel');\n    interceptEvent(this, 'iceconnectionstatechange');\n    interceptEvent(this, 'signalingstatechange');\n    interceptEvent(this, 'track');\n\n    const peerConnection = new RTCPeerConnection(configuration);\n\n    Object.defineProperties(this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _audioTransceiver: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _videoTransceiver: {\n        value: null,\n        writable: true\n      }\n    });\n\n    peerConnection.addEventListener('datachannel', event => {\n      shimDataChannel(event.channel);\n      this.dispatchEvent(event);\n    });\n\n    peerConnection.addEventListener('iceconnectionstatechange', (...args) => {\n      if (this._isClosed) {\n        return;\n      }\n      this.dispatchEvent(...args);\n    });\n\n    peerConnection.addEventListener('signalingstatechange', (...args) => {\n      if (this._isClosed) {\n        return;\n      }\n      if (peerConnection.signalingState === 'stable') {\n        this._appliedTracksToSSRCs = new Map(this._tracksToSSRCs);\n      }\n      if (!this._pendingLocalOffer && !this._pendingRemoteOffer) {\n        this.dispatchEvent(...args);\n      }\n    });\n\n    // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n    // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n    // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n    // even though a new remote RTCSessionDescription had already been applied.\n    peerConnection.addEventListener('track', event => {\n      this._pendingRemoteOffer = null;\n      this.dispatchEvent(event);\n    });\n\n    proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n\n  }\n\n  get localDescription() {\n    return this._pendingLocalOffer || this._peerConnection.localDescription;\n  }\n\n  get iceConnectionState() {\n    return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n  }\n\n  get iceGatheringState() {\n    return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n  }\n\n  get remoteDescription() {\n    return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n  }\n\n  get signalingState() {\n    if (this._isClosed) {\n      return 'closed';\n    } else if (this._pendingLocalOffer) {\n      return 'have-local-offer';\n    } else if (this._pendingRemoteOffer) {\n      return 'have-remote-offer';\n    }\n    return this._peerConnection.signalingState;\n  }\n\n  addIceCandidate(candidate) {\n    if (this.signalingState === 'have-remote-offer') {\n      return this._signalingStateLatch.when('low').then(() => this._peerConnection.addIceCandidate(candidate));\n    }\n    return this._peerConnection.addIceCandidate(candidate);\n  }\n\n  createOffer(options) {\n    options = Object.assign({}, options);\n\n    // NOTE(mroberts): In general, this is not the way to do this; however, it's\n    // good enough for our application.\n    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n      delete options.offerToReceiveAudio;\n      try {\n        this._audioTransceiver = isUnifiedPlan\n          ? this.addTransceiver('audio', { direction: 'recvonly' })\n          : this.addTransceiver('audio');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n      delete options.offerToReceiveVideo;\n      try {\n        this._videoTransceiver = isUnifiedPlan\n          ? this.addTransceiver('video', { direction: 'recvonly' })\n          : this.addTransceiver('video');\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    return this._peerConnection.createOffer(options).then(offer => {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n      // then we no longer need to retain the rolled back tracks to SSRCs Map.\n      this._rolledBackTracksToSSRCs.clear();\n\n      return new RTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(this._tracksToSSRCs, offer.sdp)\n      });\n    });\n  }\n\n  createAnswer(options) {\n    if (this._pendingRemoteOffer) {\n      return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(() => {\n        this._signalingStateLatch.lower();\n        return this._peerConnection.createAnswer();\n      }).then(answer => {\n        this._pendingRemoteOffer = null;\n\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        this._rolledBackTracksToSSRCs.clear();\n\n        return isUnifiedPlan ? new RTCSessionDescription({\n          type: answer.type,\n          sdp: updateTrackIdsToSSRCs(this._tracksToSSRCs, answer.sdp)\n        }) : answer;\n      }, error => {\n        this._pendingRemoteOffer = null;\n        throw error;\n      });\n    }\n\n    return this._peerConnection.createAnswer(options).then(answer => {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      this._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(this._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    });\n  }\n\n  createDataChannel(label, dataChannelDict) {\n    const dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  }\n\n  removeTrack(sender) {\n    sender.replaceTrack(null);\n    this._peerConnection.removeTrack(sender);\n  }\n\n  setLocalDescription(description) {\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n    return setDescription(this, true, description);\n  }\n\n  setRemoteDescription(description) {\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    return setDescription(this, false, description);\n  }\n\n  close() {\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    this._peerConnection.close();\n    setTimeout(() => {\n      this.dispatchEvent(new Event('iceconnectionstatechange'));\n      this.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n}\n\ndelegateMethods(\n  RTCPeerConnection.prototype,\n  SafariRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  const pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  const pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  const intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  const setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error(`Cannot set ${local ? 'local' : 'remote'}\n        offer in state ${peerConnection.signalingState}`));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    const previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description);\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error(`Cannot rollback \n        ${local ? 'local' : 'remote'} description in ${peerConnection.signalingState}`));\n    }\n    clearPendingLocalOffer();\n\n    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n    return Promise.resolve().then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  const pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(() => {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(() => peerConnection._signalingStateLatch.lower());\n}\n\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(({ receiver = {} }) => {\n    const { track = {} } = receiver;\n    return track.kind === kind;\n  });\n}\n\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535\n        ? null\n        : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535\n        ? null\n        : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}