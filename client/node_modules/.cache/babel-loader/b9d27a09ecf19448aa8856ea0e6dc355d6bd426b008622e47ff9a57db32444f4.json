{"ast":null,"code":"'use strict';\n\nvar CancelablePromise = require('../../util/cancelablepromise');\nvar DefaultPeerConnectionManager = require('./peerconnectionmanager');\nvar DefaultRoomV2 = require('./room');\nvar DefaultTransport = require('./twilioconnectiontransport');\nvar _a = require('../../util/twilio-video-errors'),\n  SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError,\n  SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;\nvar _b = require('../../util'),\n  flatMap = _b.flatMap,\n  createRoomConnectEventPayload = _b.createRoomConnectEventPayload;\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n  var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;\n  var PeerConnectionManager = options.PeerConnectionManager,\n    RoomV2 = options.RoomV2,\n    Transport = options.Transport,\n    iceServers = options.iceServers,\n    log = options.log;\n  var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  var trackSenders = flatMap(localParticipant.tracks, function (trackV2) {\n    return [trackV2.trackTransceiver];\n  });\n  peerConnectionManager.setTrackSenders(trackSenders);\n  var cancellationError = new Error('Canceled');\n  var transport;\n  var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {\n    var onIced = function (iceServers) {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n      return peerConnectionManager.createAndOffer().then(function () {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n        log.debug('createAndOffer() succeeded.');\n        // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n        peerConnectionManager.dequeue('description');\n      }).catch(function (error) {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n    var automaticSubscription = options.automaticSubscription,\n      bandwidthProfile = options.bandwidthProfile,\n      dominantSpeaker = options.dominantSpeaker,\n      environment = options.environment,\n      eventObserver = options.eventObserver,\n      loggerName = options.loggerName,\n      logLevel = options.logLevel,\n      name = options.name,\n      networkMonitor = options.networkMonitor,\n      networkQuality = options.networkQuality,\n      notifyWarnings = options.notifyWarnings,\n      realm = options.realm,\n      sdpSemantics = options.sdpSemantics;\n    // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n    var trackPriority = !!bandwidthProfile;\n    var trackSwitchOff = !!bandwidthProfile;\n    var renderHints = !!bandwidthProfile && (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n    var transportOptions = Object.assign({\n      adaptiveSimulcast: adaptiveSimulcast,\n      automaticSubscription: automaticSubscription,\n      dominantSpeaker: dominantSpeaker,\n      environment: environment,\n      eventObserver: eventObserver,\n      loggerName: loggerName,\n      logLevel: logLevel,\n      networkMonitor: networkMonitor,\n      networkQuality: networkQuality,\n      notifyWarnings: notifyWarnings,\n      iceServers: iceServers,\n      onIced: onIced,\n      realm: realm,\n      renderHints: renderHints,\n      sdpSemantics: sdpSemantics,\n      trackPriority: trackPriority,\n      trackSwitchOff: trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile: bandwidthProfile\n    } : {});\n    transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);\n    var connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n    transport.once('connected', function (initialState) {\n      log.debug('Transport connected:', initialState);\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n      var localParticipantState = initialState.participant;\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n    transport.once('stateChanged', function (state, error) {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n  cancelablePromise.catch(function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n    peerConnectionManager.close();\n  });\n  return cancelablePromise;\n}\nmodule.exports = createCancelableRoomSignalingPromise;","map":{"version":3,"mappings":"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","names":["CancelablePromise","require","DefaultPeerConnectionManager","DefaultRoomV2","DefaultTransport","SignalingConnectionDisconnectedError","SignalingIncomingMessageInvalidError","flatMap","createRoomConnectEventPayload","createCancelableRoomSignalingPromise","token","wsServer","localParticipant","encodingParameters","preferredCodecs","options","Object","assign","PeerConnectionManager","RoomV2","Transport","adaptiveSimulcast","video","iceServers","log","peerConnectionManager","trackSenders","tracks","trackV2","trackTransceiver","setTrackSenders","cancellationError","Error","transport","cancelablePromise","resolve","reject","isCanceled","onIced","Promise","debug","setConfiguration","createAndOffer","then","dequeue","catch","error","bandwidthProfile","dominantSpeaker","environment","eventObserver","loggerName","logLevel","name","networkMonitor","networkQuality","notifyWarnings","realm","sdpSemantics","trackPriority","trackSwitchOff","renderHints","clientTrackSwitchOffControl","contentPreferencesMode","transportOptions","automaticSubscription","connectEventPayload","emit","once","initialState","localParticipantState","state","disconnect","close","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/signaling/v2/cancelableroomsignalingpromise.js"],"sourcesContent":["'use strict';\n\nconst CancelablePromise = require('../../util/cancelablepromise');\nconst DefaultPeerConnectionManager = require('./peerconnectionmanager');\nconst DefaultRoomV2 = require('./room');\nconst DefaultTransport = require('./twilioconnectiontransport');\n\nconst {\n  SignalingConnectionDisconnectedError,\n  SignalingIncomingMessageInvalidError\n} = require('../../util/twilio-video-errors');\n\nconst { flatMap, createRoomConnectEventPayload } = require('../../util');\n\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n\n  const adaptiveSimulcast = preferredCodecs.video[0] &&  preferredCodecs.video[0].adaptiveSimulcast === true;\n  const { PeerConnectionManager, RoomV2, Transport, iceServers, log } = options;\n  const peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  const trackSenders = flatMap(localParticipant.tracks, trackV2 => [trackV2.trackTransceiver]);\n  peerConnectionManager.setTrackSenders(trackSenders);\n\n  const cancellationError = new Error('Canceled');\n\n  let transport;\n\n  const cancelablePromise = new CancelablePromise((resolve, reject, isCanceled) => {\n    const onIced = iceServers => {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n\n      return peerConnectionManager.createAndOffer().then(() => {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n        log.debug('createAndOffer() succeeded.');\n        // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n        peerConnectionManager.dequeue('description');\n      }).catch(error => {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n\n    const {\n      automaticSubscription,\n      bandwidthProfile,\n      dominantSpeaker,\n      environment,\n      eventObserver,\n      loggerName,\n      logLevel,\n      name,\n      networkMonitor,\n      networkQuality,\n      notifyWarnings,\n      realm,\n      sdpSemantics,\n    } = options;\n\n    // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n    const trackPriority = !!bandwidthProfile;\n    const trackSwitchOff = !!bandwidthProfile;\n    const renderHints = !!bandwidthProfile &&\n      (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n\n    const transportOptions = Object.assign({\n      adaptiveSimulcast,\n      automaticSubscription,\n      dominantSpeaker,\n      environment,\n      eventObserver,\n      loggerName,\n      logLevel,\n      networkMonitor,\n      networkQuality,\n      notifyWarnings,\n      iceServers,\n      onIced,\n      realm,\n      renderHints,\n      sdpSemantics,\n      trackPriority,\n      trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile\n    } : {});\n\n    transport = new Transport(\n      name,\n      token,\n      localParticipant,\n      peerConnectionManager,\n      wsServer,\n      transportOptions);\n\n    const connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n\n    transport.once('connected', initialState => {\n      log.debug('Transport connected:', initialState);\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n      const { participant: localParticipantState } = initialState;\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n\n    transport.once('stateChanged', (state, error) => {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, () => {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n\n  cancelablePromise.catch(() => {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n    peerConnectionManager.close();\n  });\n\n  return cancelablePromise;\n}\n\nmodule.exports = createCancelableRoomSignalingPromise;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}