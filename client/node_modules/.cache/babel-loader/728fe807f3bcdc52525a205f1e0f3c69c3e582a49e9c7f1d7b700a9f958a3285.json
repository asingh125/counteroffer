{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar StateMachine = require('../../statemachine');\nvar TwilioConnection = require('../../twilioconnection');\nvar DefaultBackoff = require('../../util/backoff');\nvar reconnectBackoffConfig = require('../../util/constants').reconnectBackoffConfig;\nvar Timeout = require('../../util/timeout');\nvar _a = require('../../util/constants'),\n  SDK_NAME = _a.SDK_NAME,\n  SDK_VERSION = _a.SDK_VERSION,\n  SDP_FORMAT = _a.SDP_FORMAT;\nvar _b = require('../../util'),\n  createBandwidthProfilePayload = _b.createBandwidthProfilePayload,\n  createMediaSignalingPayload = _b.createMediaSignalingPayload,\n  createMediaWarningsPayload = _b.createMediaWarningsPayload,\n  createSubscribePayload = _b.createSubscribePayload,\n  getUserAgent = _b.getUserAgent,\n  isNonArrayObject = _b.isNonArrayObject;\nvar _c = require('../../util/twilio-video-errors'),\n  createTwilioError = _c.createTwilioError,\n  RoomCompletedError = _c.RoomCompletedError,\n  SignalingConnectionError = _c.SignalingConnectionError,\n  SignalingServerBusyError = _c.SignalingServerBusyError;\nvar ICE_VERSION = 1;\nvar RSP_VERSION = 2;\n/*\nTwilioConnectionTransport States\n----------------\n\n                      +-----------+\n                      |           |\n                      |  syncing  |---------+\n                      |           |         |\n                      +-----------+         |\n                         ^     |            |\n                         |     |            |\n                         |     v            v\n    +------------+    +-----------+    +--------------+\n    |            |    |           |    |              |\n    | connecting |--->| connected |--->| disconnected |\n    |            |    |           |    |              |\n    +------------+    +-----------+    +--------------+\n             |                              ^\n             |                              |\n             |                              |\n             +------------------------------+\n\n*/\nvar states = {\n  connecting: ['connected', 'disconnected'],\n  connected: ['disconnected', 'syncing'],\n  syncing: ['connected', 'disconnected'],\n  disconnected: []\n};\n/**\n * A {@link TwilioConnectionTransport} supports sending and receiving Room Signaling Protocol\n * (RSP) messages. It also supports RSP requests, such as Sync and Disconnect.\n * @extends StateMachine\n * @emits TwilioConnectionTransport#connected\n * @emits TwilioConnectionTransport#message\n */\nvar TwilioConnectionTransport = /** @class */function (_super) {\n  __extends(TwilioConnectionTransport, _super);\n  /**\n   * Construct a {@link TwilioConnectionTransport}.\n   * @param {?string} name\n   * @param {string} accessToken\n   * @param {ParticipantSignaling} localParticipant\n   * @param {PeerConnectionManager} peerConnectionManager\n   * @param {string} wsServer\n   * @param {object} [options]\n   */\n  function TwilioConnectionTransport(name, accessToken, localParticipant, peerConnectionManager, wsServer, options) {\n    var _this = this;\n    options = Object.assign({\n      Backoff: DefaultBackoff,\n      TwilioConnection: TwilioConnection,\n      iceServers: null,\n      trackPriority: true,\n      trackSwitchOff: true,\n      renderHints: true,\n      userAgent: getUserAgent()\n    }, options);\n    _this = _super.call(this, 'connecting', states) || this;\n    Object.defineProperties(_this, {\n      _accessToken: {\n        value: accessToken\n      },\n      _automaticSubscription: {\n        value: options.automaticSubscription\n      },\n      _bandwidthProfile: {\n        value: options.bandwidthProfile\n      },\n      _dominantSpeaker: {\n        value: options.dominantSpeaker\n      },\n      _adaptiveSimulcast: {\n        value: options.adaptiveSimulcast\n      },\n      _eventObserver: {\n        value: options.eventObserver,\n        writable: false\n      },\n      _renderHints: {\n        value: options.renderHints\n      },\n      _iceServersStatus: {\n        value: Array.isArray(options.iceServers) ? 'overrode' : 'acquire'\n      },\n      _localParticipant: {\n        value: localParticipant\n      },\n      _name: {\n        value: name\n      },\n      _networkQuality: {\n        value: isNonArrayObject(options.networkQuality) || options.networkQuality\n      },\n      _notifyWarnings: {\n        value: options.notifyWarnings\n      },\n      _options: {\n        value: options\n      },\n      _peerConnectionManager: {\n        value: peerConnectionManager\n      },\n      _sessionTimer: {\n        value: null,\n        writable: true\n      },\n      _sessionTimeoutMS: {\n        value: 0,\n        writable: true\n      },\n      _reconnectBackoff: {\n        value: new options.Backoff(reconnectBackoffConfig)\n      },\n      _session: {\n        value: null,\n        writable: true\n      },\n      _trackPriority: {\n        value: options.trackPriority\n      },\n      _trackSwitchOff: {\n        value: options.trackSwitchOff\n      },\n      _twilioConnection: {\n        value: null,\n        writable: true\n      },\n      _updatesReceived: {\n        value: []\n      },\n      _updatesToSend: {\n        value: []\n      },\n      _userAgent: {\n        value: options.userAgent\n      },\n      _wsServer: {\n        value: wsServer\n      }\n    });\n    setupTransport(_this);\n    return _this;\n  }\n  /**\n   * Create a Connect, Sync or Disconnect RSP message.\n   * @private\n   * @returns {?object}\n   */\n  TwilioConnectionTransport.prototype._createConnectOrSyncOrDisconnectMessage = function () {\n    if (this.state === 'connected') {\n      return null;\n    }\n    if (this.state === 'disconnected') {\n      return {\n        session: this._session,\n        type: 'disconnect',\n        version: RSP_VERSION\n      };\n    }\n    var type = {\n      connecting: 'connect',\n      syncing: 'sync'\n    }[this.state];\n    var message = {\n      name: this._name,\n      participant: this._localParticipant.getState(),\n      peer_connections: this._peerConnectionManager.getStates(),\n      type: type,\n      version: RSP_VERSION\n    };\n    if (message.type === 'connect') {\n      message.ice_servers = this._iceServersStatus;\n      message.publisher = {\n        name: SDK_NAME,\n        sdk_version: SDK_VERSION,\n        user_agent: this._userAgent\n      };\n      if (this._bandwidthProfile) {\n        message.bandwidth_profile = createBandwidthProfilePayload(this._bandwidthProfile);\n      }\n      if (this._notifyWarnings) {\n        message.participant.media_warnings = createMediaWarningsPayload(this._notifyWarnings);\n      }\n      message.media_signaling = createMediaSignalingPayload(this._dominantSpeaker, this._networkQuality, this._trackPriority, this._trackSwitchOff, this._adaptiveSimulcast, this._renderHints);\n      message.subscribe = createSubscribePayload(this._automaticSubscription);\n      message.format = SDP_FORMAT;\n      message.token = this._accessToken;\n    } else if (message.type === 'sync') {\n      message.session = this._session;\n      message.token = this._accessToken;\n    } else if (message.type === 'update') {\n      message.session = this._session;\n    }\n    return message;\n  };\n  /**\n   * Create an \"ice\" message.\n   * @private\n   */\n  TwilioConnectionTransport.prototype._createIceMessage = function () {\n    return {\n      edge: 'roaming',\n      token: this._accessToken,\n      type: 'ice',\n      version: ICE_VERSION\n    };\n  };\n  /**\n   * Send a Connect, Sync or Disconnect RSP message.\n   * @private\n   */\n  TwilioConnectionTransport.prototype._sendConnectOrSyncOrDisconnectMessage = function () {\n    var message = this._createConnectOrSyncOrDisconnectMessage();\n    if (message) {\n      this._twilioConnection.sendMessage(message);\n    }\n  };\n  /**\n   * Disconnect the {@link TwilioConnectionTransport}. Returns true if calling the method resulted\n   * in disconnection.\n   * @param {TwilioError} [error]\n   * @returns {boolean}\n   */\n  TwilioConnectionTransport.prototype.disconnect = function (error) {\n    if (this.state !== 'disconnected') {\n      this.preempt('disconnected', null, [error]);\n      this._sendConnectOrSyncOrDisconnectMessage();\n      this._twilioConnection.close();\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Publish an RSP Update. Returns true if calling the method resulted in\n   * publishing (or eventually publishing) the update.\n   * @param {object} update\n   * @returns {boolean}\n   */\n  TwilioConnectionTransport.prototype.publish = function (update) {\n    switch (this.state) {\n      case 'connected':\n        this._twilioConnection.sendMessage(Object.assign({\n          session: this._session,\n          type: 'update',\n          version: RSP_VERSION\n        }, update));\n        return true;\n      case 'connecting':\n      case 'syncing':\n        this._updatesToSend.push(update);\n        return true;\n      case 'disconnected':\n      default:\n        return false;\n    }\n  };\n  /**\n   * Publish (or queue) an event to the Insights gateway.\n   * @param {string} group - Event group name\n   * @param {string} name - Event name\n   * @param {string} level - Event level\n   * @param {object} payload - Event payload\n   * @returns {void}\n   */\n  TwilioConnectionTransport.prototype.publishEvent = function (group, name, level, payload) {\n    this._eventObserver.emit('event', {\n      group: group,\n      name: name,\n      level: level,\n      payload: payload\n    });\n  };\n  /**\n   * Sync the {@link TwilioConnectionTransport}. Returns true if calling the method resulted in\n   * syncing.\n   * @returns {boolean}\n   */\n  TwilioConnectionTransport.prototype.sync = function () {\n    if (this.state === 'connected') {\n      this.preempt('syncing');\n      this._sendConnectOrSyncOrDisconnectMessage();\n      return true;\n    }\n    return false;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n  TwilioConnectionTransport.prototype._setSession = function (session, sessionTimeout) {\n    this._session = session;\n    this._sessionTimeoutMS = sessionTimeout * 1000;\n  };\n  /**\n   * Determines if we should attempt reconnect.\n   * returns a Promise to wait on before attempting to\n   * reconnect. returns null if its not okay to reconnect.\n   * @private\n   * @returns {Promise<void>}\n   */\n  TwilioConnectionTransport.prototype._getReconnectTimer = function () {\n    var _this = this;\n    if (this._sessionTimeoutMS === 0) {\n      // this means either we have never connected.\n      // or we timed out while trying to reconnect\n      // In either case we do not want to reconnect.\n      return null;\n    }\n    // start session timer\n    if (!this._sessionTimer) {\n      this._sessionTimer = new Timeout(function () {\n        // ensure that _clearReconnectTimer wasn't\n        // called while we were waiting.\n        if (_this._sessionTimer) {\n          // do not allow any more reconnect attempts.\n          _this._sessionTimeoutMS = 0;\n        }\n      }, this._sessionTimeoutMS);\n    }\n    // return promise that waits with exponential backoff.\n    return new Promise(function (resolve) {\n      _this._reconnectBackoff.backoff(resolve);\n    });\n  };\n  /**\n   * clears the session reconnect timer.\n   *\n   * @private\n   * @returns {void}\n   */\n  TwilioConnectionTransport.prototype._clearReconnectTimer = function () {\n    this._reconnectBackoff.reset();\n    if (this._sessionTimer) {\n      this._sessionTimer.clear();\n      this._sessionTimer = null;\n    }\n  };\n  return TwilioConnectionTransport;\n}(StateMachine);\n/**\n * @event TwilioConnectionTransport#connected\n * @param {object} initialState\n */\n/**\n * @event TwilioConnectionTransport#message\n * @param {object} peerConnections\n */\nfunction reducePeerConnections(peerConnections) {\n  return Array.from(peerConnections.reduce(function (peerConnectionsById, update) {\n    var reduced = peerConnectionsById.get(update.id) || update;\n    // First, reduce the top-level `description` property.\n    if (!reduced.description && update.description) {\n      reduced.description = update.description;\n    } else if (reduced.description && update.description) {\n      if (update.description.revision > reduced.description.revision) {\n        reduced.description = update.description;\n      }\n    }\n    // Then, reduce the top-level `ice` property.\n    if (!reduced.ice && update.ice) {\n      reduced.ice = update.ice;\n    } else if (reduced.ice && update.ice) {\n      if (update.ice.revision > reduced.ice.revision) {\n        reduced.ice = update.ice;\n      }\n    }\n    // Finally, update the map.\n    peerConnectionsById.set(reduced.id, reduced);\n    return peerConnectionsById;\n  }, new Map()).values());\n}\nfunction reduceUpdates(updates) {\n  return updates.reduce(function (reduced, update) {\n    // First, reduce the top-level `participant` property.\n    if (!reduced.participant && update.participant) {\n      reduced.participant = update.participant;\n    } else if (reduced.participant && update.participant) {\n      if (update.participant.revision > reduced.participant.revision) {\n        reduced.participant = update.participant;\n      }\n    }\n    // Then, reduce the top-level `peer_connections` property.\n    /* eslint camelcase:0 */\n    if (!reduced.peer_connections && update.peer_connections) {\n      reduced.peer_connections = reducePeerConnections(update.peer_connections);\n    } else if (reduced.peer_connections && update.peer_connections) {\n      reduced.peer_connections = reducePeerConnections(reduced.peer_connections.concat(update.peer_connections));\n    }\n    return reduced;\n  }, {});\n}\nfunction setupTransport(transport) {\n  function createOrResetTwilioConnection() {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n    if (transport._twilioConnection) {\n      transport._twilioConnection.removeListener('message', handleMessage);\n    }\n    var _iceServersStatus = transport._iceServersStatus,\n      _options = transport._options,\n      _wsServer = transport._wsServer,\n      state = transport.state;\n    var TwilioConnection = _options.TwilioConnection;\n    var twilioConnection = new TwilioConnection(_wsServer, Object.assign({\n      helloBody: state === 'connecting' && _iceServersStatus === 'acquire' ? transport._createIceMessage() : transport._createConnectOrSyncOrDisconnectMessage()\n    }, _options));\n    twilioConnection.once('close', function (reason) {\n      if (reason === TwilioConnection.CloseReason.LOCAL) {\n        disconnect();\n      } else {\n        disconnect(new Error(reason));\n      }\n    });\n    twilioConnection.on('message', handleMessage);\n    transport._twilioConnection = twilioConnection;\n  }\n  function disconnect(error) {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n    if (!error) {\n      transport.disconnect();\n      return;\n    }\n    var reconnectTimer = transport._getReconnectTimer();\n    if (!reconnectTimer) {\n      var twilioError = error.message === TwilioConnection.CloseReason.BUSY ? new SignalingServerBusyError() : new SignalingConnectionError();\n      transport.disconnect(twilioError);\n      return;\n    }\n    if (transport.state === 'connected') {\n      transport.preempt('syncing');\n    }\n    reconnectTimer.then(createOrResetTwilioConnection);\n  }\n  function handleMessage(message) {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n    if (message.type === 'error') {\n      transport.disconnect(createTwilioError(message.code, message.message));\n      return;\n    }\n    switch (transport.state) {\n      case 'connected':\n        switch (message.type) {\n          case 'connected':\n          case 'synced':\n          case 'update':\n          case 'warning':\n            transport.emit('message', message);\n            return;\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);\n            return;\n          default:\n            // Do nothing.\n            return;\n        }\n      case 'connecting':\n        switch (message.type) {\n          case 'iced':\n            transport._options.onIced(message.ice_servers).then(function () {\n              transport._sendConnectOrSyncOrDisconnectMessage();\n            });\n            return;\n          case 'connected':\n            transport._setSession(message.session, message.options.session_timeout);\n            transport.emit('connected', message);\n            transport.preempt('connected');\n            return;\n          case 'synced':\n          case 'update':\n            transport._updatesReceived.push(message);\n            return;\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);\n            return;\n          default:\n            // Do nothing.\n            return;\n        }\n      case 'syncing':\n        switch (message.type) {\n          case 'connected':\n          case 'update':\n            transport._updatesReceived.push(message);\n            return;\n          case 'synced':\n            transport._clearReconnectTimer();\n            transport.emit('message', message);\n            transport.preempt('connected');\n            return;\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);\n            return;\n          default:\n            // Do nothing.\n            return;\n        }\n      default:\n        // Impossible\n        return;\n    }\n  }\n  transport.on('stateChanged', function stateChanged(state) {\n    switch (state) {\n      case 'connected':\n        {\n          var updates = transport._updatesToSend.splice(0);\n          if (updates.length) {\n            transport.publish(reduceUpdates(updates));\n          }\n          transport._updatesReceived.splice(0).forEach(function (update) {\n            return transport.emit('message', update);\n          });\n          return;\n        }\n      case 'disconnected':\n        transport._twilioConnection.removeListener('message', handleMessage);\n        transport.removeListener('stateChanged', stateChanged);\n        return;\n      case 'syncing':\n        // Do nothing.\n        return;\n      default:\n        // Impossible\n        return;\n    }\n  });\n  var _options = transport._options,\n    _iceServersStatus = transport._iceServersStatus;\n  var iceServers = _options.iceServers,\n    onIced = _options.onIced;\n  if (_iceServersStatus === 'overrode') {\n    onIced(iceServers).then(createOrResetTwilioConnection);\n  } else {\n    createOrResetTwilioConnection();\n  }\n}\nmodule.exports = TwilioConnectionTransport;","map":{"version":3,"mappings":"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","names":["StateMachine","require","TwilioConnection","DefaultBackoff","Timeout","SDK_NAME","SDK_VERSION","SDP_FORMAT","createBandwidthProfilePayload","createMediaSignalingPayload","createMediaWarningsPayload","createSubscribePayload","getUserAgent","isNonArrayObject","createTwilioError","RoomCompletedError","SignalingConnectionError","SignalingServerBusyError","ICE_VERSION","RSP_VERSION","states","connecting","connected","syncing","disconnected","__extends","name","accessToken","localParticipant","peerConnectionManager","wsServer","options","Object","assign","Backoff","iceServers","trackPriority","trackSwitchOff","renderHints","userAgent","_this","defineProperties","_accessToken","value","_automaticSubscription","automaticSubscription","_bandwidthProfile","bandwidthProfile","_dominantSpeaker","dominantSpeaker","_adaptiveSimulcast","adaptiveSimulcast","_eventObserver","eventObserver","writable","_renderHints","_iceServersStatus","Array","isArray","_localParticipant","_name","_networkQuality","networkQuality","_notifyWarnings","notifyWarnings","_options","_peerConnectionManager","_sessionTimer","_sessionTimeoutMS","_reconnectBackoff","reconnectBackoffConfig","_session","_trackPriority","_trackSwitchOff","_twilioConnection","_updatesReceived","_updatesToSend","_userAgent","_wsServer","setupTransport","TwilioConnectionTransport","state","session","type","version","message","participant","getState","peer_connections","getStates","ice_servers","publisher","sdk_version","user_agent","bandwidth_profile","media_warnings","media_signaling","subscribe","format","token","edge","_createConnectOrSyncOrDisconnectMessage","sendMessage","error","preempt","_sendConnectOrSyncOrDisconnectMessage","close","update","push","group","level","payload","emit","sessionTimeout","Promise","backoff","resolve","reset","clear","reducePeerConnections","peerConnections","from","reduce","peerConnectionsById","reduced","get","id","description","revision","ice","set","Map","values","reduceUpdates","updates","concat","transport","createOrResetTwilioConnection","removeListener","handleMessage","twilioConnection","helloBody","_createIceMessage","once","reason","CloseReason","LOCAL","disconnect","Error","on","reconnectTimer","_getReconnectTimer","twilioError","BUSY","then","code","status","onIced","_setSession","session_timeout","_clearReconnectTimer","stateChanged","splice","length","publish","forEach","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/signaling/v2/twilioconnectiontransport.js"],"sourcesContent":["'use strict';\n\nconst StateMachine = require('../../statemachine');\nconst TwilioConnection = require('../../twilioconnection');\nconst DefaultBackoff = require('../../util/backoff');\nconst { reconnectBackoffConfig } = require('../../util/constants');\nconst Timeout = require('../../util/timeout');\nconst { SDK_NAME, SDK_VERSION, SDP_FORMAT } = require('../../util/constants');\n\nconst {\n  createBandwidthProfilePayload,\n  createMediaSignalingPayload,\n  createMediaWarningsPayload,\n  createSubscribePayload,\n  getUserAgent,\n  isNonArrayObject\n} = require('../../util');\n\nconst {\n  createTwilioError,\n  RoomCompletedError,\n  SignalingConnectionError,\n  SignalingServerBusyError,\n} = require('../../util/twilio-video-errors');\n\nconst ICE_VERSION = 1;\nconst RSP_VERSION = 2;\n\n/*\nTwilioConnectionTransport States\n----------------\n\n                      +-----------+\n                      |           |\n                      |  syncing  |---------+\n                      |           |         |\n                      +-----------+         |\n                         ^     |            |\n                         |     |            |\n                         |     v            v\n    +------------+    +-----------+    +--------------+\n    |            |    |           |    |              |\n    | connecting |--->| connected |--->| disconnected |\n    |            |    |           |    |              |\n    +------------+    +-----------+    +--------------+\n             |                              ^\n             |                              |\n             |                              |\n             +------------------------------+\n\n*/\n\nconst states = {\n  connecting: [\n    'connected',\n    'disconnected'\n  ],\n  connected: [\n    'disconnected',\n    'syncing'\n  ],\n  syncing: [\n    'connected',\n    'disconnected'\n  ],\n  disconnected: []\n};\n\n/**\n * A {@link TwilioConnectionTransport} supports sending and receiving Room Signaling Protocol\n * (RSP) messages. It also supports RSP requests, such as Sync and Disconnect.\n * @extends StateMachine\n * @emits TwilioConnectionTransport#connected\n * @emits TwilioConnectionTransport#message\n */\nclass TwilioConnectionTransport extends StateMachine {\n  /**\n   * Construct a {@link TwilioConnectionTransport}.\n   * @param {?string} name\n   * @param {string} accessToken\n   * @param {ParticipantSignaling} localParticipant\n   * @param {PeerConnectionManager} peerConnectionManager\n   * @param {string} wsServer\n   * @param {object} [options]\n   */\n  constructor(name, accessToken, localParticipant, peerConnectionManager, wsServer, options) {\n    options = Object.assign({\n      Backoff: DefaultBackoff,\n      TwilioConnection,\n      iceServers: null,\n      trackPriority: true,\n      trackSwitchOff: true,\n      renderHints: true,\n      userAgent: getUserAgent()\n    }, options);\n    super('connecting', states);\n\n\n    Object.defineProperties(this, {\n      _accessToken: {\n        value: accessToken\n      },\n      _automaticSubscription: {\n        value: options.automaticSubscription\n      },\n      _bandwidthProfile: {\n        value: options.bandwidthProfile\n      },\n      _dominantSpeaker: {\n        value: options.dominantSpeaker\n      },\n      _adaptiveSimulcast: {\n        value: options.adaptiveSimulcast\n      },\n      _eventObserver: {\n        value: options.eventObserver,\n        writable: false\n      },\n      _renderHints: {\n        value: options.renderHints\n      },\n      _iceServersStatus: {\n        value: Array.isArray(options.iceServers)\n          ? 'overrode'\n          : 'acquire'\n      },\n      _localParticipant: {\n        value: localParticipant\n      },\n      _name: {\n        value: name,\n      },\n      _networkQuality: {\n        value: isNonArrayObject(options.networkQuality) || options.networkQuality\n      },\n      _notifyWarnings: {\n        value: options.notifyWarnings\n      },\n      _options: {\n        value: options\n      },\n      _peerConnectionManager: {\n        value: peerConnectionManager\n      },\n      _sessionTimer: {\n        value: null,\n        writable: true\n      },\n      _sessionTimeoutMS: {\n        value: 0, // initially 0, set only after 1st successful connection.\n        writable: true\n      },\n      _reconnectBackoff: {\n        value: new options.Backoff(reconnectBackoffConfig)\n      },\n      _session: {\n        value: null,\n        writable: true\n      },\n      _trackPriority: {\n        value: options.trackPriority\n      },\n      _trackSwitchOff: {\n        value: options.trackSwitchOff\n      },\n      _twilioConnection: {\n        value: null,\n        writable: true\n      },\n      _updatesReceived: {\n        value: []\n      },\n      _updatesToSend: {\n        value: []\n      },\n      _userAgent: {\n        value: options.userAgent\n      },\n      _wsServer: {\n        value: wsServer\n      }\n    });\n\n\n    setupTransport(this);\n  }\n\n  /**\n   * Create a Connect, Sync or Disconnect RSP message.\n   * @private\n   * @returns {?object}\n   */\n  _createConnectOrSyncOrDisconnectMessage() {\n    if (this.state === 'connected') {\n      return null;\n    }\n\n    if (this.state === 'disconnected') {\n      return {\n        session: this._session,\n        type: 'disconnect',\n        version: RSP_VERSION\n      };\n    }\n\n    const type = {\n      connecting: 'connect',\n      syncing: 'sync'\n    }[this.state];\n\n    const message = {\n      name: this._name,\n      participant: this._localParticipant.getState(),\n      peer_connections: this._peerConnectionManager.getStates(),\n      type,\n      version: RSP_VERSION\n    };\n\n    if (message.type === 'connect') {\n      message.ice_servers = this._iceServersStatus;\n\n      message.publisher = {\n        name: SDK_NAME,\n        sdk_version: SDK_VERSION,\n        user_agent: this._userAgent\n      };\n\n      if (this._bandwidthProfile) {\n        message.bandwidth_profile = createBandwidthProfilePayload(\n          this._bandwidthProfile);\n      }\n\n      if (this._notifyWarnings) {\n        message.participant.media_warnings = createMediaWarningsPayload(\n          this._notifyWarnings);\n      }\n\n      message.media_signaling = createMediaSignalingPayload(\n        this._dominantSpeaker,\n        this._networkQuality,\n        this._trackPriority,\n        this._trackSwitchOff,\n        this._adaptiveSimulcast,\n        this._renderHints);\n\n      message.subscribe = createSubscribePayload(this._automaticSubscription);\n      message.format = SDP_FORMAT;\n      message.token = this._accessToken;\n    } else if (message.type === 'sync') {\n      message.session = this._session;\n      message.token = this._accessToken;\n    } else if (message.type === 'update') {\n      message.session = this._session;\n    }\n\n    return message;\n  }\n\n  /**\n   * Create an \"ice\" message.\n   * @private\n   */\n  _createIceMessage() {\n    return {\n      edge: 'roaming', // roaming here means use same edge as signaling.\n      token: this._accessToken,\n      type: 'ice',\n      version: ICE_VERSION\n    };\n  }\n\n  /**\n   * Send a Connect, Sync or Disconnect RSP message.\n   * @private\n   */\n  _sendConnectOrSyncOrDisconnectMessage() {\n    const message = this._createConnectOrSyncOrDisconnectMessage();\n    if (message) {\n      this._twilioConnection.sendMessage(message);\n    }\n  }\n\n  /**\n   * Disconnect the {@link TwilioConnectionTransport}. Returns true if calling the method resulted\n   * in disconnection.\n   * @param {TwilioError} [error]\n   * @returns {boolean}\n   */\n  disconnect(error) {\n    if (this.state !== 'disconnected') {\n      this.preempt('disconnected', null, [error]);\n      this._sendConnectOrSyncOrDisconnectMessage();\n      this._twilioConnection.close();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Publish an RSP Update. Returns true if calling the method resulted in\n   * publishing (or eventually publishing) the update.\n   * @param {object} update\n   * @returns {boolean}\n   */\n  publish(update) {\n    switch (this.state) {\n      case 'connected':\n        this._twilioConnection.sendMessage(Object.assign({\n          session: this._session,\n          type: 'update',\n          version: RSP_VERSION\n        }, update));\n        return true;\n      case 'connecting':\n      case 'syncing':\n        this._updatesToSend.push(update);\n        return true;\n      case 'disconnected':\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Publish (or queue) an event to the Insights gateway.\n   * @param {string} group - Event group name\n   * @param {string} name - Event name\n   * @param {string} level - Event level\n   * @param {object} payload - Event payload\n   * @returns {void}\n   */\n  publishEvent(group, name, level, payload) {\n    this._eventObserver.emit('event', { group, name, level, payload });\n  }\n\n  /**\n   * Sync the {@link TwilioConnectionTransport}. Returns true if calling the method resulted in\n   * syncing.\n   * @returns {boolean}\n   */\n  sync() {\n    if (this.state === 'connected') {\n      this.preempt('syncing');\n      this._sendConnectOrSyncOrDisconnectMessage();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  _setSession(session, sessionTimeout) {\n    this._session = session;\n    this._sessionTimeoutMS = sessionTimeout * 1000;\n  }\n\n  /**\n   * Determines if we should attempt reconnect.\n   * returns a Promise to wait on before attempting to\n   * reconnect. returns null if its not okay to reconnect.\n   * @private\n   * @returns {Promise<void>}\n   */\n  _getReconnectTimer() {\n    if (this._sessionTimeoutMS === 0) {\n      // this means either we have never connected.\n      // or we timed out while trying to reconnect\n      // In either case we do not want to reconnect.\n      return null;\n    }\n\n    // start session timer\n    if (!this._sessionTimer) {\n      this._sessionTimer = new Timeout(() => {\n        // ensure that _clearReconnectTimer wasn't\n        // called while we were waiting.\n        if (this._sessionTimer) {\n          // do not allow any more reconnect attempts.\n          this._sessionTimeoutMS = 0;\n        }\n      }, this._sessionTimeoutMS);\n    }\n\n    // return promise that waits with exponential backoff.\n    return new Promise(resolve => {\n      this._reconnectBackoff.backoff(resolve);\n    });\n  }\n\n  /**\n   * clears the session reconnect timer.\n   *\n   * @private\n   * @returns {void}\n   */\n  _clearReconnectTimer() {\n    this._reconnectBackoff.reset();\n    if (this._sessionTimer) {\n      this._sessionTimer.clear();\n      this._sessionTimer = null;\n    }\n  }\n}\n\n/**\n * @event TwilioConnectionTransport#connected\n * @param {object} initialState\n */\n\n/**\n * @event TwilioConnectionTransport#message\n * @param {object} peerConnections\n */\n\nfunction reducePeerConnections(peerConnections) {\n  return Array.from(peerConnections.reduce((peerConnectionsById, update) => {\n    const reduced = peerConnectionsById.get(update.id) || update;\n\n    // First, reduce the top-level `description` property.\n    if (!reduced.description && update.description) {\n      reduced.description = update.description;\n    } else if (reduced.description && update.description) {\n      if (update.description.revision > reduced.description.revision) {\n        reduced.description = update.description;\n      }\n    }\n\n    // Then, reduce the top-level `ice` property.\n    if (!reduced.ice && update.ice) {\n      reduced.ice = update.ice;\n    } else if (reduced.ice && update.ice) {\n      if (update.ice.revision > reduced.ice.revision) {\n        reduced.ice = update.ice;\n      }\n    }\n\n    // Finally, update the map.\n    peerConnectionsById.set(reduced.id, reduced);\n    return peerConnectionsById;\n  }, new Map()).values());\n}\n\nfunction reduceUpdates(updates) {\n  return updates.reduce((reduced, update) => {\n    // First, reduce the top-level `participant` property.\n    if (!reduced.participant && update.participant) {\n      reduced.participant = update.participant;\n    } else if (reduced.participant && update.participant) {\n      if (update.participant.revision > reduced.participant.revision) {\n        reduced.participant = update.participant;\n      }\n    }\n\n    // Then, reduce the top-level `peer_connections` property.\n    /* eslint camelcase:0 */\n    if (!reduced.peer_connections && update.peer_connections) {\n      reduced.peer_connections = reducePeerConnections(update.peer_connections);\n    } else if (reduced.peer_connections && update.peer_connections) {\n      reduced.peer_connections = reducePeerConnections(\n        reduced.peer_connections.concat(update.peer_connections));\n    }\n    return reduced;\n  }, {});\n}\n\nfunction setupTransport(transport) {\n  function createOrResetTwilioConnection() {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n    if (transport._twilioConnection) {\n      transport._twilioConnection.removeListener('message', handleMessage);\n    }\n    const { _iceServersStatus, _options, _wsServer, state } = transport;\n    const { TwilioConnection } = _options;\n\n    const twilioConnection = new TwilioConnection(_wsServer, Object.assign({\n      helloBody: state === 'connecting' && _iceServersStatus === 'acquire'\n        ? transport._createIceMessage()\n        : transport._createConnectOrSyncOrDisconnectMessage()\n    }, _options));\n\n    twilioConnection.once('close', reason => {\n      if (reason === TwilioConnection.CloseReason.LOCAL) {\n        disconnect();\n      } else {\n        disconnect(new Error(reason));\n      }\n    });\n\n    twilioConnection.on('message', handleMessage);\n    transport._twilioConnection = twilioConnection;\n  }\n\n  function disconnect(error) {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n    if (!error) {\n      transport.disconnect();\n      return;\n    }\n\n    const reconnectTimer = transport._getReconnectTimer();\n    if (!reconnectTimer) {\n      const twilioError = error.message === TwilioConnection.CloseReason.BUSY\n        ? new SignalingServerBusyError()\n        : new SignalingConnectionError();\n      transport.disconnect(twilioError);\n      return;\n    }\n\n    if (transport.state === 'connected') {\n      transport.preempt('syncing');\n    }\n\n    reconnectTimer.then(createOrResetTwilioConnection);\n  }\n\n  function handleMessage(message) {\n    if (transport.state === 'disconnected') {\n      return;\n    }\n    if (message.type === 'error') {\n      transport.disconnect(createTwilioError(message.code, message.message));\n      return;\n    }\n    switch (transport.state) {\n      case 'connected':\n        switch (message.type) {\n          case 'connected':\n          case 'synced':\n          case 'update':\n          case 'warning':\n            transport.emit('message', message);\n            return;\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed'\n              ? new RoomCompletedError()\n              : null);\n            return;\n          default:\n            // Do nothing.\n            return;\n        }\n      case 'connecting':\n        switch (message.type) {\n          case 'iced':\n            transport._options.onIced(message.ice_servers).then(() => {\n              transport._sendConnectOrSyncOrDisconnectMessage();\n            });\n            return;\n          case 'connected':\n            transport._setSession(message.session, message.options.session_timeout);\n            transport.emit('connected', message);\n            transport.preempt('connected');\n            return;\n          case 'synced':\n          case 'update':\n            transport._updatesReceived.push(message);\n            return;\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed'\n              ? new RoomCompletedError()\n              : null);\n            return;\n          default:\n            // Do nothing.\n            return;\n        }\n      case 'syncing':\n        switch (message.type) {\n          case 'connected':\n          case 'update':\n            transport._updatesReceived.push(message);\n            return;\n          case 'synced':\n            transport._clearReconnectTimer();\n            transport.emit('message', message);\n            transport.preempt('connected');\n            return;\n          case 'disconnected':\n            transport.disconnect(message.status === 'completed'\n              ? new RoomCompletedError()\n              : null);\n            return;\n          default:\n            // Do nothing.\n            return;\n        }\n      default:\n        // Impossible\n        return;\n    }\n  }\n\n  transport.on('stateChanged', function stateChanged(state) {\n    switch (state) {\n      case 'connected': {\n        const updates = transport._updatesToSend.splice(0);\n        if (updates.length) {\n          transport.publish(reduceUpdates(updates));\n        }\n        transport._updatesReceived.splice(0).forEach(update => transport.emit('message', update));\n        return;\n      }\n      case 'disconnected':\n        transport._twilioConnection.removeListener('message', handleMessage);\n        transport.removeListener('stateChanged', stateChanged);\n        return;\n      case 'syncing':\n        // Do nothing.\n        return;\n      default:\n        // Impossible\n        return;\n    }\n  });\n\n  const { _options, _iceServersStatus } = transport;\n  const { iceServers, onIced } = _options;\n\n  if (_iceServersStatus === 'overrode') {\n    onIced(iceServers).then(createOrResetTwilioConnection);\n  } else {\n    createOrResetTwilioConnection();\n  }\n}\n\nmodule.exports = TwilioConnectionTransport;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}