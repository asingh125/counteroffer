{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar MediaTrack = require('./mediatrack');\nvar VideoProcessorEventObserver = require('./videoprocessoreventobserver');\nvar DEFAULT_FRAME_RATE = require('../../util/constants').DEFAULT_FRAME_RATE;\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\nvar VideoTrack = /** @class */function (_super) {\n  __extends(VideoTrack, _super);\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  function VideoTrack(mediaTrackTransceiver, options) {\n    var _this = _super.call(this, mediaTrackTransceiver, options) || this;\n    Object.defineProperties(_this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n    _this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(_this._log);\n    return _this;\n  }\n  /**\n   * @private\n   */\n  VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {\n    if (isPublishing === void 0) {\n      isPublishing = false;\n    }\n    var canCaptureFrames = true;\n    var message = '';\n    var _a = this.mediaStreamTrack,\n      enabled = _a.enabled,\n      readyState = _a.readyState;\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n    if (message) {\n      this._log.debug(message);\n    }\n    return {\n      canCaptureFrames: canCaptureFrames,\n      message: message\n    };\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._captureFrames = function () {\n    var _this = this;\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n      return;\n    }\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n      return;\n    }\n    this._isCapturing = true;\n    this._processorEventObserver.emit('start');\n    this._log.debug('Start capturing frames');\n    var startTime = Date.now();\n    var processFramePeriodMs;\n    this._dummyEl.play().then(function () {\n      var captureFrame = function (cb) {\n        clearTimeout(_this._captureTimeoutId);\n        var _a = _this.mediaStreamTrack.getSettings().frameRate,\n          frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;\n        var capturePeriodMs = Math.floor(1000 / frameRate);\n        var delay = capturePeriodMs - processFramePeriodMs;\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n        _this._captureTimeoutId = setTimeout(cb, delay);\n      };\n      var process = function () {\n        var checkResult = _this._checkIfCanCaptureFrames();\n        if (!checkResult.canCaptureFrames) {\n          _this._isCapturing = false;\n          _this._processorEventObserver.emit('stop', checkResult.message);\n          _this._log.debug('Cannot capture frames. Stopping capturing frames.');\n          return;\n        }\n        startTime = Date.now();\n        var _a = _this.mediaStreamTrack.getSettings(),\n          _b = _a.width,\n          width = _b === void 0 ? 0 : _b,\n          _c = _a.height,\n          height = _c === void 0 ? 0 : _c;\n        // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n        if (_this._inputFrame.width !== width) {\n          _this._inputFrame.width = width;\n          _this._inputFrame.height = height;\n          if (_this._outputFrame) {\n            _this._outputFrame.width = width;\n            _this._outputFrame.height = height;\n          }\n        }\n        _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);\n        var result = null;\n        try {\n          result = _this.processor.processFrame(_this._inputFrame, _this._outputFrame);\n        } catch (ex) {\n          _this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n        (result instanceof Promise ? result : Promise.resolve(result)).then(function () {\n          if (_this._outputFrame) {\n            _this.processedTrack.requestFrame();\n            _this._processorEventObserver.emit('stats');\n          }\n        }).finally(function () {\n          processFramePeriodMs = Date.now() - startTime;\n          captureFrame(process);\n        });\n      };\n      captureFrame(process);\n    }).catch(function (error) {\n      return _this._log.error('Video element cannot be played', {\n        error: error,\n        track: _this\n      });\n    });\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._initialize = function () {\n    var _this = this;\n    _super.prototype._initialize.call(this);\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n        }\n      };\n      this._dummyEl.onresize = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n          if (_this.isStarted) {\n            _this._log.debug('Dimensions changed:', _this.dimensions);\n            _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);\n          }\n        }\n      };\n    }\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._restartProcessor = function () {\n    var processor = this.processor;\n    if (processor) {\n      this.removeProcessor(processor);\n      this.addProcessor(processor);\n    }\n  };\n  /**\n   * @private\n   */\n  VideoTrack.prototype._start = function (dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n    this._log.debug('Dimensions:', this.dimensions);\n    this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n    return _super.prototype._start.call(this, dummyEl);\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n  VideoTrack.prototype.addProcessor = function (processor) {\n    var _this = this;\n    if (typeof OffscreenCanvas !== 'function') {\n      return this._log.warn('Adding a VideoProcessor is not supported in this browser.');\n    }\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = function () {\n        _this._log.debug('mediaStreamTrack unmuted');\n        // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n        if (_this.processedTrack.muted) {\n          _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n          _this._restartProcessor();\n        }\n      };\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n    var _a = this.mediaStreamTrack.getSettings(),\n      _b = _a.width,\n      width = _b === void 0 ? 0 : _b,\n      _c = _a.height,\n      height = _c === void 0 ? 0 : _c,\n      _d = _a.frameRate,\n      frameRate = _d === void 0 ? DEFAULT_FRAME_RATE : _d;\n    this._inputFrame = new OffscreenCanvas(width, height);\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n    this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n    this._processorEventObserver.emit('add', {\n      processor: processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')\n    });\n    this._updateElementsMediaStreamTrack();\n    this._captureFrames();\n    return this;\n  };\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  */ /**\n     * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n     *\n     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n     * MediaStreamTracks of the same kind on the MediaStream, this method removes\n     * them.\n     *\n     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const Video = require('twilio-video');\n     *\n     * const videoElement = document.createElement('video');\n     * document.body.appendChild(videoElement);\n     *\n     * Video.createLocalVideoTrack().then(function(videoTrack) {\n     *   videoTrack.attach(videoElement);\n     * });\n     */ /**\n        * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n        * <code>document.querySelector</code>. The HTMLMediaElement could be an\n        * HTMLAudioElement or an HTMLVideoElement.\n        *\n        * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n        * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n        * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n        * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n        * MediaStreamTracks of the same kind on the MediaStream, this method removes\n        * them.\n        *\n        * @param {string} selector - A query selector for the HTMLMediaElement to\n        *   attach to\n        * @returns {HTMLMediaElement} mediaElement\n        * @example\n        * const Video = require('twilio-video');\n        *\n        * const videoElement = document.createElement('video');\n        * videoElement.id = 'my-video-element';\n        * document.body.appendChild(videoElement);\n        *\n        * Video.createLocalVideoTrack().then(function(track) {\n        *   track.attach('#my-video-element');\n        * });\n        */\n  VideoTrack.prototype.attach = function () {\n    var result = _super.prototype.attach.apply(this, arguments);\n    if (this.processor) {\n      this._captureFrames();\n    }\n    return result;\n  };\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  */ /**\n     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n     *   which the {@link VideoTrack} is attached\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const videoElement = document.getElementById('my-video-element');\n     * videoTrack.detach(videoElement).remove();\n     */ /**\n        * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n        *   specified by <code>document.querySelector</code>.\n        * @param {string} selector - The query selector of HTMLMediaElement to which\n        *    the {@link VideoTrack} is attached\n        * @returns {HTMLMediaElement} mediaElement\n        * @example\n        * videoTrack.detach('#my-video-element').remove();\n        */\n  VideoTrack.prototype.detach = function () {\n    return _super.prototype.detach.apply(this, arguments);\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n  VideoTrack.prototype.removeProcessor = function (processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n    this._processorEventObserver.emit('remove');\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n    this.processor = null;\n    this.processedTrack = null;\n    this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);\n    this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);\n    this._inputFrame = null;\n    this._outputFrame = null;\n    this._updateElementsMediaStreamTrack();\n    return this;\n  };\n  return VideoTrack;\n}(MediaTrack);\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth || track.dimensions.height !== elem.videoHeight;\n}\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\nmodule.exports = VideoTrack;","map":{"version":3,"mappings":"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","names":["MediaTrack","require","VideoProcessorEventObserver","__extends","mediaTrackTransceiver","options","_super","Object","defineProperties","_this","_captureTimeoutId","value","writable","_isCapturing","_inputFrame","_outputFrame","_processorEventObserver","_unmuteHandler","dimensions","enumerable","width","height","processor","_log","VideoTrack","isPublishing","canCaptureFrames","message","mediaStreamTrack","enabled","readyState","_attachments","size","debug","_checkIfCanCaptureFrames","emit","startTime","Date","now","processFramePeriodMs","_dummyEl","play","then","captureFrame","clearTimeout","getSettings","frameRate","DEFAULT_FRAME_RATE","capturePeriodMs","Math","floor","delay","setTimeout","cb","process","checkResult","_b","_c","getContext","drawImage","result","processFrame","ex","Promise","resolve","processedTrack","requestFrame","finally","catch","error","track","_initialize","onloadedmetadata","dimensionsChanged","videoWidth","videoHeight","onresize","isStarted","DIMENSIONS_CHANGED","removeProcessor","addProcessor","dummyEl","_start","call","OffscreenCanvas","warn","Error","muted","_restartProcessor","addEventListener","_d","document","createElement","captureStream","getTracks","captureHeight","captureWidth","inputFrameRate","isRemoteVideoTrack","toString","includes","_updateElementsMediaStreamTrack","_captureFrames","attach","apply","arguments","detach","removeEventListener","clearRect","elem","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/media/track/videotrack.js"],"sourcesContent":["'use strict';\n\nconst MediaTrack = require('./mediatrack');\nconst VideoProcessorEventObserver = require('./videoprocessoreventobserver');\nconst { DEFAULT_FRAME_RATE } = require('../../util/constants');\n\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\nclass VideoTrack extends MediaTrack {\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  constructor(mediaTrackTransceiver, options) {\n    super(mediaTrackTransceiver, options);\n    Object.defineProperties(this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true,\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(this._log);\n\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _checkIfCanCaptureFrames(isPublishing = false) {\n    let canCaptureFrames = true;\n    let message = '';\n    const { enabled, readyState } = this.mediaStreamTrack;\n\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n\n    if (message) {\n      this._log.debug(message);\n    }\n    return { canCaptureFrames, message };\n  }\n\n  /**\n   * @private\n   */\n  _captureFrames() {\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n      return;\n    }\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n      return;\n    }\n    this._isCapturing = true;\n    this._processorEventObserver.emit('start');\n    this._log.debug('Start capturing frames');\n\n    let startTime = Date.now();\n    let processFramePeriodMs;\n\n    this._dummyEl.play().then(() => {\n      const captureFrame = cb => {\n        clearTimeout(this._captureTimeoutId);\n        const { frameRate = DEFAULT_FRAME_RATE } = this.mediaStreamTrack.getSettings();\n        const capturePeriodMs = Math.floor(1000 / frameRate);\n        let delay = capturePeriodMs - processFramePeriodMs;\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n        this._captureTimeoutId = setTimeout(cb, delay);\n      };\n      const process = () => {\n        const checkResult = this._checkIfCanCaptureFrames();\n        if (!checkResult.canCaptureFrames) {\n          this._isCapturing = false;\n          this._processorEventObserver.emit('stop', checkResult.message);\n          this._log.debug('Cannot capture frames. Stopping capturing frames.');\n          return;\n        }\n        startTime = Date.now();\n\n        const { width = 0, height = 0 } = this.mediaStreamTrack.getSettings();\n        // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n        if (this._inputFrame.width !== width) {\n          this._inputFrame.width = width;\n          this._inputFrame.height = height;\n\n          if (this._outputFrame) {\n            this._outputFrame.width = width;\n            this._outputFrame.height = height;\n          }\n        }\n        this._inputFrame.getContext('2d').drawImage(this._dummyEl, 0, 0, width, height);\n\n        let result = null;\n        try {\n          result = this.processor.processFrame(this._inputFrame, this._outputFrame);\n        } catch (ex) {\n          this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n        ((result instanceof Promise) ? result : Promise.resolve(result))\n          .then(() => {\n            if (this._outputFrame) {\n              this.processedTrack.requestFrame();\n              this._processorEventObserver.emit('stats');\n            }\n          })\n          .finally(() => {\n            processFramePeriodMs = Date.now() - startTime;\n            captureFrame(process);\n          });\n      };\n      captureFrame(process);\n    }).catch(error => this._log.error('Video element cannot be played', { error, track: this }));\n  }\n\n  /**\n   * @private\n   */\n  _initialize() {\n    super._initialize();\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = () => {\n        if (dimensionsChanged(this, this._dummyEl)) {\n          this.dimensions.width = this._dummyEl.videoWidth;\n          this.dimensions.height = this._dummyEl.videoHeight;\n        }\n      };\n      this._dummyEl.onresize = () => {\n        if (dimensionsChanged(this, this._dummyEl)) {\n          this.dimensions.width = this._dummyEl.videoWidth;\n          this.dimensions.height = this._dummyEl.videoHeight;\n          if (this.isStarted) {\n            this._log.debug('Dimensions changed:', this.dimensions);\n            this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n          }\n        }\n      };\n    }\n  }\n\n  /**\n   * @private\n   */\n  _restartProcessor() {\n    const processor = this.processor;\n    if (processor) {\n      this.removeProcessor(processor);\n      this.addProcessor(processor);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _start(dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n\n    this._log.debug('Dimensions:', this.dimensions);\n    this.emit(VideoTrack.DIMENSIONS_CHANGED, this);\n    return super._start.call(this, dummyEl);\n  }\n\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n  addProcessor(processor) {\n    if (typeof OffscreenCanvas !== 'function') {\n      return this._log.warn('Adding a VideoProcessor is not supported in this browser.');\n    }\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = () => {\n        this._log.debug('mediaStreamTrack unmuted');\n        // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n        if (this.processedTrack.muted) {\n          this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n          this._restartProcessor();\n        }\n      };\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n\n    const { width = 0, height = 0, frameRate = DEFAULT_FRAME_RATE } = this.mediaStreamTrack.getSettings();\n    this._inputFrame = new OffscreenCanvas(width, height);\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n\n    this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n\n    this._processorEventObserver.emit('add', {\n      processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')\n    });\n    this._updateElementsMediaStreamTrack();\n    this._captureFrames();\n    return this;\n  }\n\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  *//**\n   * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n   * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n   *\n   * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n   * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n   * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n   * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n   * MediaStreamTracks of the same kind on the MediaStream, this method removes\n   * them.\n   *\n   * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * const videoElement = document.createElement('video');\n   * document.body.appendChild(videoElement);\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.attach(videoElement);\n   * });\n  *//**\n   * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n   * <code>document.querySelector</code>. The HTMLMediaElement could be an\n   * HTMLAudioElement or an HTMLVideoElement.\n   *\n   * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n   * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n   * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n   * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n   * MediaStreamTracks of the same kind on the MediaStream, this method removes\n   * them.\n   *\n   * @param {string} selector - A query selector for the HTMLMediaElement to\n   *   attach to\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * const videoElement = document.createElement('video');\n   * videoElement.id = 'my-video-element';\n   * document.body.appendChild(videoElement);\n   *\n   * Video.createLocalVideoTrack().then(function(track) {\n   *   track.attach('#my-video-element');\n   * });\n   */\n  attach() {\n    const result = super.attach.apply(this, arguments);\n    if (this.processor) {\n      this._captureFrames();\n    }\n    return result;\n  }\n\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  *//**\n   * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n   * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n   *   which the {@link VideoTrack} is attached\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * const videoElement = document.getElementById('my-video-element');\n   * videoTrack.detach(videoElement).remove();\n  *//**\n   * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n   *   specified by <code>document.querySelector</code>.\n   * @param {string} selector - The query selector of HTMLMediaElement to which\n   *    the {@link VideoTrack} is attached\n   * @returns {HTMLMediaElement} mediaElement\n   * @example\n   * videoTrack.detach('#my-video-element').remove();\n   */\n  detach() {\n    return super.detach.apply(this, arguments);\n  }\n\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n  removeProcessor(processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n\n    this._processorEventObserver.emit('remove');\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n\n    this.processor = null;\n    this.processedTrack = null;\n    this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);\n    this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);\n    this._inputFrame = null;\n    this._outputFrame = null;\n\n    this._updateElementsMediaStreamTrack();\n    return this;\n  }\n}\n\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\n\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth\n    || track.dimensions.height !== elem.videoHeight;\n}\n\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\n\nmodule.exports = VideoTrack;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}