{"ast":null,"code":"'use strict';\n\nvar Filter = require('../../util/filter');\n/**\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\n * {@link IceBox} via {@link IceBox#update} are compared against previously\n * trickled candidates and only new candidates will be returned (assuming they\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\n * @property {?string} ufrag\n */\nvar IceBox = /** @class */function () {\n  /**\n   * Construct an {@link IceBox}.\n   */\n  function IceBox() {\n    Object.defineProperties(this, {\n      _filter: {\n        value: new Filter({\n          getKey: function getKey(iceState) {\n            return iceState.ufrag;\n          },\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n            return a.revision <= b.revision;\n          }\n        })\n      },\n      _ufrag: {\n        writable: true,\n        value: null\n      },\n      ufrag: {\n        enumerable: true,\n        get: function () {\n          return this._ufrag;\n        }\n      }\n    });\n  }\n  /**\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\n   * ICE candidates associated with the username fragment.\n   * @param {string} ufrag\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n  IceBox.prototype.setUfrag = function (ufrag) {\n    this._ufrag = ufrag;\n    var ice = this._filter.toMap().get(ufrag);\n    return ice ? ice.candidates : [];\n  };\n  /**\n   * Update the {@link IceBox}. This method returns any new ICE candidates\n   * associated with the current username fragment.\n   * @param {object} iceState\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n  IceBox.prototype.update = function (iceState) {\n    // NOTE(mroberts): The Server sometimes does not set the candidates property.\n    iceState.candidates = iceState.candidates || [];\n    var oldIceState = this._filter.toMap().get(iceState.ufrag);\n    var oldCandidates = oldIceState ? oldIceState.candidates : [];\n    return this._filter.update(iceState) && this._ufrag === iceState.ufrag ? iceState.candidates.slice(oldCandidates.length) : [];\n  };\n  return IceBox;\n}();\nmodule.exports = IceBox;","map":{"version":3,"mappings":"AAAA,YAAY;;AAEZ,IAAMA,MAAM,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAE3C;;;;;;;AAOA;EACE;;;EAGA;IACEC,MAAM,CAACC,gBAAgB,CAAC,IAAI,EAAE;MAC5BC,OAAO,EAAE;QACPC,KAAK,EAAE,IAAIL,MAAM,CAAC;UAChBM,MAAM,EAAE,SAASA,MAAM,CAACC,QAAQ;YAC9B,OAAOA,QAAQ,CAACC,KAAK;UACvB,CAAC;UACDC,mBAAmB,EAAE,SAASA,mBAAmB,CAACC,CAAC,EAAEC,CAAC;YACpD,OAAOD,CAAC,CAACE,QAAQ,IAAID,CAAC,CAACC,QAAQ;UACjC;SACD;OACF;MACDC,MAAM,EAAE;QACNC,QAAQ,EAAE,IAAI;QACdT,KAAK,EAAE;OACR;MACDG,KAAK,EAAE;QACLO,UAAU,EAAE,IAAI;QAChBC,GAAG;UACD,OAAO,IAAI,CAACH,MAAM;QACpB;;KAEH,CAAC;EACJ;EAEA;;;;;;EAMAI,yBAAQ,GAAR,UAAST,KAAK;IACZ,IAAI,CAACK,MAAM,GAAGL,KAAK;IACnB,IAAMU,GAAG,GAAG,IAAI,CAACd,OAAO,CAACe,KAAK,EAAE,CAACH,GAAG,CAACR,KAAK,CAAC;IAC3C,OAAOU,GAAG,GAAGA,GAAG,CAACE,UAAU,GAAG,EAAE;EAClC,CAAC;EAED;;;;;;EAMAH,uBAAM,GAAN,UAAOV,QAAQ;IACb;IACAA,QAAQ,CAACa,UAAU,GAAGb,QAAQ,CAACa,UAAU,IAAI,EAAE;IAC/C,IAAMC,WAAW,GAAG,IAAI,CAACjB,OAAO,CAACe,KAAK,EAAE,CAACH,GAAG,CAACT,QAAQ,CAACC,KAAK,CAAC;IAC5D,IAAMc,aAAa,GAAGD,WAAW,GAAGA,WAAW,CAACD,UAAU,GAAG,EAAE;IAC/D,OAAO,IAAI,CAAChB,OAAO,CAACmB,MAAM,CAAChB,QAAQ,CAAC,IAAI,IAAI,CAACM,MAAM,KAAKN,QAAQ,CAACC,KAAK,GAClED,QAAQ,CAACa,UAAU,CAACI,KAAK,CAACF,aAAa,CAACG,MAAM,CAAC,GAC/C,EAAE;EACR,CAAC;EACH,aAAC;AAAD,CAAC,EAxDD;AA0DAC,MAAM,CAACC,OAAO,GAAGV,MAAM","names":["Filter","require","Object","defineProperties","_filter","value","getKey","iceState","ufrag","isLessThanOrEqualTo","a","b","revision","_ufrag","writable","enumerable","get","IceBox","ice","toMap","candidates","oldIceState","oldCandidates","update","slice","length","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/signaling/v2/icebox.js"],"sourcesContent":["'use strict';\n\nconst Filter = require('../../util/filter');\n\n/**\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\n * {@link IceBox} via {@link IceBox#update} are compared against previously\n * trickled candidates and only new candidates will be returned (assuming they\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\n * @property {?string} ufrag\n */\nclass IceBox {\n  /**\n   * Construct an {@link IceBox}.\n   */\n  constructor() {\n    Object.defineProperties(this, {\n      _filter: {\n        value: new Filter({\n          getKey: function getKey(iceState) {\n            return iceState.ufrag;\n          },\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n            return a.revision <= b.revision;\n          }\n        })\n      },\n      _ufrag: {\n        writable: true,\n        value: null\n      },\n      ufrag: {\n        enumerable: true,\n        get() {\n          return this._ufrag;\n        }\n      }\n    });\n  }\n\n  /**\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\n   * ICE candidates associated with the username fragment.\n   * @param {string} ufrag\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n  setUfrag(ufrag) {\n    this._ufrag = ufrag;\n    const ice = this._filter.toMap().get(ufrag);\n    return ice ? ice.candidates : [];\n  }\n\n  /**\n   * Update the {@link IceBox}. This method returns any new ICE candidates\n   * associated with the current username fragment.\n   * @param {object} iceState\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n  update(iceState) {\n    // NOTE(mroberts): The Server sometimes does not set the candidates property.\n    iceState.candidates = iceState.candidates || [];\n    const oldIceState = this._filter.toMap().get(iceState.ufrag);\n    const oldCandidates = oldIceState ? oldIceState.candidates : [];\n    return this._filter.update(iceState) && this._ufrag === iceState.ufrag\n      ? iceState.candidates.slice(oldCandidates.length)\n      : [];\n  }\n}\n\nmodule.exports = IceBox;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}