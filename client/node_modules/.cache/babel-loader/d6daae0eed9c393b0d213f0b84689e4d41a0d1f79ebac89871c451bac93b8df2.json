{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventEmitter = require('./eventemitter');\nvar RemoteParticipant = require('./remoteparticipant');\nvar StatsReport = require('./stats/statsreport');\nvar _a = require('./util'),\n  flatMap = _a.flatMap,\n  valueToJSON = _a.valueToJSON;\nvar nInstances = 0;\n/**\n * A {@link Room} represents communication between you and one or more\n * {@link RemoteParticipant}s sharing {@link AudioTrack}s and\n * {@link VideoTrack}s.\n * <br><br>\n * You can connect to a {@link Room} by calling {@link module:twilio-video.connect}.\n * @extends EventEmitter\n * @property {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @property {boolean} isRecording - Whether or not the {@link Room} is being\n *   recorded\n * @property {LocalParticipant} localParticipant - Your {@link LocalParticipant}\n *   in the {@link Room}\n * @property {string} mediaRegion - String indicating geographical region\n *    where  media is processed for the {@link Room}.\n * @property {string} name - The {@link Room}'s name\n * @property {Map<Participant.SID, RemoteParticipant>} participants -\n *   The {@link RemoteParticipant}s participating in this {@link Room}\n * @property {Room.SID} sid - The {@link Room}'s SID\n * @property {string} state - \"connected\", \"reconnecting\", or \"disconnected\"\n * @throws {SignalingConnectionDisconnectedError}\n * @emits Room#disconnected\n * @emits Room#participantConnected\n * @emits Room#participantDisconnected\n * @emits Room#participantReconnected\n * @emits Room#participantReconnecting\n * @emits Room#reconnected\n * @emits Room#reconnecting\n * @emits Room#recordingStarted\n * @emits Room#recordingStopped\n * @emits Room#trackDimensionsChanged\n * @emits Room#trackDisabled\n * @emits Room#trackEnabled\n * @emits Room#trackMessage\n * @emits Room#trackPublished\n * @emits Room#trackPublishPriorityChanged\n * @emits Room#trackStarted\n * @emits Room#trackSubscribed\n * @emits Room#trackSwitchedOff\n * @emits Room#trackSwitchedOn\n * @emits Room#trackUnpublished\n * @emits Room#trackUnsubscribed\n * @emits Room#trackWarning\n * @emits Room#trackWarningsCleared\n */\nvar Room = /** @class */function (_super) {\n  __extends(Room, _super);\n  /**\n   * Construct a {@link Room}.\n   * @param {RoomSignaling} signaling\n   * @param {?object} [options={}]\n   */\n  function Room(localParticipant, signaling, options) {\n    var _this = _super.call(this) || this;\n    var log = options.log.createLog('default', _this);\n    var participants = new Map();\n    /* istanbul ignore next */\n    Object.defineProperties(_this, {\n      _log: {\n        value: log\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl || 'disabled'\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode || 'disabled'\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _options: {\n        value: options\n      },\n      _participants: {\n        value: participants\n      },\n      _signaling: {\n        value: signaling\n      },\n      dominantSpeaker: {\n        enumerable: true,\n        get: function () {\n          return this.participants.get(signaling.dominantSpeakerSid) || null;\n        }\n      },\n      isRecording: {\n        enumerable: true,\n        get: function () {\n          return signaling.recording.isEnabled || false;\n        }\n      },\n      localParticipant: {\n        enumerable: true,\n        value: localParticipant\n      },\n      name: {\n        enumerable: true,\n        value: signaling.name\n      },\n      participants: {\n        enumerable: true,\n        value: participants\n      },\n      sid: {\n        enumerable: true,\n        value: signaling.sid\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return signaling.state;\n        }\n      },\n      mediaRegion: {\n        enumerable: true,\n        value: signaling.mediaRegion\n      }\n    });\n    handleLocalParticipantEvents(_this, localParticipant);\n    handleRecordingEvents(_this, signaling.recording);\n    handleSignalingEvents(_this, signaling);\n    verifyNoiseCancellation(_this);\n    log.info('Created a new Room:', _this.name);\n    log.debug('Initial RemoteParticipants:', Array.from(_this._participants.values()));\n    return _this;\n  }\n  Room.prototype.toString = function () {\n    return \"[Room #\" + this._instanceId + \": \" + this.sid + \"]\";\n  };\n  /**\n   * Disconnect from the {@link Room}.\n   * @returns {this}\n   */\n  Room.prototype.disconnect = function () {\n    this._log.info('Disconnecting');\n    this._signaling.disconnect();\n    return this;\n  };\n  /**\n   * Get the {@link Room}'s media statistics. This is not supported in Safari 12.0 or below\n   * due to this bug : https://bugs.webkit.org/show_bug.cgi?id=192601\n   *\n   * @returns {Promise.<Array<StatsReport>>}\n   */\n  Room.prototype.getStats = function () {\n    var _this = this;\n    return this._signaling.getStats().then(function (responses) {\n      return Array.from(responses).map(function (_a) {\n        var _b = __read(_a, 2),\n          id = _b[0],\n          response = _b[1];\n        return new StatsReport(id, Object.assign({}, response, {\n          localAudioTrackStats: rewriteLocalTrackIds(_this, response.localAudioTrackStats),\n          localVideoTrackStats: rewriteLocalTrackIds(_this, response.localVideoTrackStats)\n        }));\n      });\n    });\n  };\n  /**\n   * Restart the muted local media {@link Track}s and play inadvertently paused HTMLMediaElements\n   * that are attached to local and remote media {@link Track}s. This method is useful mainly on\n   * mobile browsers (Safari and Chrome on iOS), where there is a possibility that the muted local\n   * media {@link Track}s are never unmuted and inadvertently paused HTMLMediaElements are never\n   * played again, especially after handling an incoming phone call.\n   * @returns {this}\n   */\n  Room.prototype.refreshInactiveMedia = function () {\n    var localTrackPublications = this.localParticipant.tracks;\n    var localMediaTracks = Array.from(localTrackPublications.values()).filter(function (_a) {\n      var kind = _a.track.kind;\n      return kind !== 'data';\n    }).map(function (_a) {\n      var track = _a.track;\n      return track;\n    });\n    var remoteMediaTracks = flatMap(this.participants, function (participants) {\n      return Array.from(participants.tracks.values());\n    }).filter(function (_a) {\n      var track = _a.track;\n      return track && track.kind !== 'data';\n    }).map(function (_a) {\n      var track = _a.track;\n      return track;\n    });\n    var mediaTracks = localMediaTracks.concat(remoteMediaTracks);\n    var unmuteEvent = new Event('unmute');\n    localMediaTracks.forEach(function (_a) {\n      var isMuted = _a.isMuted,\n        mediaStreamTrack = _a.mediaStreamTrack;\n      if (isMuted) {\n        mediaStreamTrack.dispatchEvent(unmuteEvent);\n      }\n    });\n    var pauseEvent = new Event('pause');\n    mediaTracks.forEach(function (_a) {\n      var attachments = _a._attachments,\n        elShims = _a._elShims;\n      return attachments.forEach(function (el) {\n        var shim = elShims.get(el);\n        var isInadvertentlyPaused = el.paused && shim && !shim.pausedIntentionally();\n        if (isInadvertentlyPaused) {\n          el.dispatchEvent(pauseEvent);\n        }\n      });\n    });\n    return this;\n  };\n  Room.prototype.toJSON = function () {\n    return valueToJSON(this);\n  };\n  return Room;\n}(EventEmitter);\nfunction verifyNoiseCancellation(room) {\n  var allowedAudioProcessors = room.localParticipant._signaling.audioProcessors;\n  room.localParticipant.audioTracks.forEach(function (_a) {\n    var track = _a.track;\n    var noiseCancellation = track.noiseCancellation;\n    if (noiseCancellation && !allowedAudioProcessors.includes(noiseCancellation.vendor)) {\n      room._log.warn(noiseCancellation.vendor + \" is not supported in this room. disabling it permanently\");\n      noiseCancellation.disablePermanently();\n    }\n  });\n}\nfunction rewriteLocalTrackIds(room, trackStats) {\n  var localParticipantSignaling = room.localParticipant._signaling;\n  return trackStats.reduce(function (trackStats, trackStat) {\n    var publication = localParticipantSignaling.tracks.get(trackStat.trackId);\n    var trackSender = localParticipantSignaling.getSender(publication);\n    return trackSender ? [Object.assign({}, trackStat, {\n      trackId: trackSender.id\n    })].concat(trackStats) : trackStats;\n  }, []);\n}\n/**\n * A {@link Room.SID} is a 34-character string starting with \"RM\"\n * that uniquely identifies a {@link Room}.\n * @type string\n * @typedef Room.SID\n */\n/**\n * The Dominant Speaker in the {@link Room} changed. Either the Dominant Speaker\n * is a new {@link RemoteParticipant} or the Dominant Speaker has been reset and\n * is now null.\n * @param {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @event Room#dominantSpeakerChanged\n */\n/**\n * Your {@link LocalParticipant} was disconnected from the {@link Room} and all\n * other {@link RemoteParticipant}s.\n * @param {Room} room - The {@link Room} your\n *   {@link LocalParticipant} was disconnected from\n * @param {?TwilioError} error - Present when the {@link LocalParticipant} got\n *   disconnected from the {@link Room} unexpectedly\n * @event Room#disconnected\n * @example\n * myRoom.on('disconnected', function(room, error) {\n *   if (error) {\n *     console.log('Unexpectedly disconnected:', error);\n *   }\n *   myRoom.localParticipant.tracks.forEach(function(track) {\n *     track.stop();\n *     track.detach();\n *   });\n * });\n */\n/**\n * A {@link RemoteParticipant} joined the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * publishes at least one {@link LocalTrack}.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who joined\n * @event Room#participantConnected\n * @example\n * myRoom.on('participantConnected', function(participant) {\n *   console.log(participant.identity + ' joined the Room');\n * });\n */\n/**\n * A {@link RemoteParticipant} left the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * unpublishes all its {@link LocalTrack}s.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who left\n * @event Room#participantDisconnected\n * @example\n * myRoom.on('participantDisconnected', function(participant) {\n *   console.log(participant.identity + ' left the Room');\n *   participant.tracks.forEach(function(track) {\n *     track.detach().forEach(function(mediaElement) {\n *       mediaElement.remove();\n *     });\n *   });\n * });\n */\n/**\n * A {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that has reconnected.\n * @event Room#participantReconnected\n * @example\n * myRoom.on('participantReconnected', participant => {\n *   console.log(participant.identity + ' reconnected to the Room');\n * });\n */\n/**\n * A {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that is reconnecting.\n * @event Room#participantReconnecting\n * @example\n * myRoom.on('participantReconnecting', participant => {\n *   console.log(participant.identity + ' is reconnecting to the Room');\n * });\n */\n/**\n * Your application successfully reconnected to the {@link Room}. When this\n * event is emitted, the {@link Room} is in state \"connected\".\n * @event Room#reconnected\n * @example\n * myRoom.on('reconnected', () => {\n *   console.log('Reconnected!');\n * });\n */\n/**\n * Your application is reconnecting to the {@link Room}. This happens when there\n * is a disruption in your signaling connection and/or your media connection. When\n * this event is emitted, the {@link Room} is in state \"reconnecting\". If reconnecting\n * succeeds, the {@link Room} will emit a \"reconnected\" event.\n * @param {MediaConnectionError|SignalingConnectionDisconnectedError} error - A\n *   {@link MediaConnectionError} if your application is reconnecting due to a\n *   disruption in your media connection, or a {@link SignalingConnectionDisconnectedError}\n *   if your application is reconnecting due to a disruption in your signaling connection\n * @event Room#reconnecting\n * @example\n * myRoom.on('reconnecting', error => {\n *   if (error.code === 53001) {\n *     console.log('Reconnecting your signaling connection!', error.message);\n *   } else if (error.code === 53405) {\n *     console.log('Reconnecting your media connection!', error.message);\n *   }\n * });\n */\n/**\n * The {@link Room} is now being recorded\n * @event Room#recordingStarted\n */\n/**\n * The {@link Room} is no longer being recorded\n * @event Room#recordingStopped\n */\n/**\n * One of the {@link RemoteParticipant}'s {@link VideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteVideoTrack}'s dimensions changed\n * @event Room#trackDimensionsChanged\n */\n/**\n * A {@link RemoteTrack} was disabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents disabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   disabled the {@link RemoteTrack}\n * @event Room#trackDisabled\n */\n/**\n * A {@link RemoteTrack} was enabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents enabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   enabled the {@link RemoteTrack}\n * @event Room#trackEnabled\n */\n/**\n * A message was received over one of the {@link RemoteParticipant}'s\n * {@link RemoteDataTrack}'s.\n * @param {string|ArrayBuffer} data\n * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the\n *   message was received\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteDataTrack} received the message\n * @event Room#trackMessage\n */\n/**\n * A {@link RemoteTrack} was published by a {@link RemoteParticipant} after\n * connecting to the {@link Room}. This event is not emitted for\n * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}\n * was connecting to the {@link Room}.\n * @event Room#trackPublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the published {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   published the {@link RemoteTrack}\n * @example\n * function trackPublished(publication, participant) {\n *   console.log(`RemoteParticipant ${participant.sid} published Track ${publication.trackSid}`);\n * }\n *\n * // Handle RemoteTracks published after connecting to the Room.\n * room.on('trackPublished', trackPublished);\n *\n * room.on('participantConnected', participant => {\n *   // Handle RemoteTracks published while connecting to the Room.\n *   participant.trackPublications.forEach(publication => trackPublished(publication, participant));\n * });\n */\n/**\n * One of a {@link RemoteParticipant}'s {@link RemoteTrack}s in the {@link Room} started.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that started\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} started\n * @event Room#trackStarted\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was subscribed\n * @event Room#trackSubscribed\n * @example\n * room.on('trackSubscribed', function(track, publication, participant) {\n *   var participantView = document.getElementById('participant-view-' + participant.identity);\n *   participantView.appendChild(track.attach());\n * });\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched off\n * @event Room#trackSwitchedOff\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched on\n * @event Room#trackSwitchedOn\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.\n * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be\n *   subscribed to\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not\n *   be subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} could not be subscribed to\n * @event Room#trackSubscriptionFailed\n */\n/**\n * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the\n * {@link RemoteParticipant}.\n * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish\n *   {@link Track.Priority};\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} changed priority\n * @event Room#trackPublishPriorityChanged\n */\n/**\n * A {@link RemoteTrack} was unpublished by a {@link RemoteParticipant} to the {@link Room}.\n * @event Room#trackUnpublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the unpublished {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   unpublished the {@link RemoteTrack}\n */\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was unsubscribed from\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was unsubscribed\n * @event Room#trackUnsubscribed\n * @example\n * room.on('trackUnsubscribed', function(track, publication, participant) {\n *   track.detach().forEach(function(mediaElement) {\n *     mediaElement.remove();\n *   });\n * });\n */\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} encountered a warning.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {string} name - The warning that was raised.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that encountered the warning.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarning\n * @example\n * room.on('trackWarning', (name, publication, participant) => {\n *   if (name === 'recording-media-lost') {\n *     log(`LocalTrack ${publication.track.name} is not recording media.`,\n *       name, publication, participant);\n *\n *     // Wait a reasonable amount of time to clear the warning.\n *     const timer = setTimeout(() => {\n *       // If the warning is not cleared, you can manually\n *       // reconnect to the room, or show a dialog to the user\n *     }, 5000);\n *\n *     room.once('trackWarningsCleared', (publication, participant) => {\n *       log('LocalTrack warnings have cleared!',\n *         publication, participant);\n *       clearTimeout(timer);\n *     });\n *   }\n});\n */\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} cleared all warnings.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that cleared all warnings.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarningsCleared\n */\nfunction connectParticipant(room, participantSignaling) {\n  var log = room._log,\n    clientTrackSwitchOffControl = room._clientTrackSwitchOffControl,\n    contentPreferencesMode = room._contentPreferencesMode;\n  var participant = new RemoteParticipant(participantSignaling, {\n    log: log,\n    clientTrackSwitchOffControl: clientTrackSwitchOffControl,\n    contentPreferencesMode: contentPreferencesMode\n  });\n  log.info('A new RemoteParticipant connected:', participant);\n  room._participants.set(participant.sid, participant);\n  room.emit('participantConnected', participant);\n  // Reemit Track and RemoteParticipant events.\n  var eventListeners = [['reconnected', 'participantReconnected'], ['reconnecting', 'participantReconnecting'], 'trackDimensionsChanged', 'trackDisabled', 'trackEnabled', 'trackMessage', 'trackPublished', 'trackPublishPriorityChanged', 'trackStarted', 'trackSubscribed', 'trackSubscriptionFailed', 'trackSwitchedOff', 'trackSwitchedOn', 'trackUnpublished', 'trackUnsubscribed'].map(function (eventOrPair) {\n    var _a = __read(Array.isArray(eventOrPair) ? eventOrPair : [eventOrPair, eventOrPair], 2),\n      event = _a[0],\n      participantEvent = _a[1];\n    function reemit() {\n      var args = [].slice.call(arguments);\n      args.unshift(participantEvent);\n      args.push(participant);\n      room.emit.apply(room, __spreadArray([], __read(args)));\n    }\n    participant.on(event, reemit);\n    return [event, reemit];\n  });\n  participant.once('disconnected', function participantDisconnected() {\n    var dominantSpeaker = room.dominantSpeaker;\n    log.info('RemoteParticipant disconnected:', participant);\n    room._participants.delete(participant.sid);\n    eventListeners.forEach(function (args) {\n      participant.removeListener(args[0], args[1]);\n    });\n    room.emit('participantDisconnected', participant);\n    if (participant === dominantSpeaker) {\n      room.emit('dominantSpeakerChanged', room.dominantSpeaker);\n    }\n  });\n}\nfunction handleLocalParticipantEvents(room, localParticipant) {\n  var events = ['trackWarning', 'trackWarningsCleared'].map(function (event) {\n    return {\n      eventName: event,\n      handler: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return room.emit.apply(room, __spreadArray([event], __read(__spreadArray(__spreadArray([], __read(args)), [localParticipant]))));\n      }\n    };\n  });\n  events.forEach(function (_a) {\n    var eventName = _a.eventName,\n      handler = _a.handler;\n    return localParticipant.on(eventName, handler);\n  });\n  room.once('disconnected', function () {\n    return events.forEach(function (_a) {\n      var eventName = _a.eventName,\n        handler = _a.handler;\n      return localParticipant.removeListener(eventName, handler);\n    });\n  });\n}\nfunction handleRecordingEvents(room, recording) {\n  recording.on('updated', function updated() {\n    var started = recording.isEnabled;\n    room._log.info(\"Recording \" + (started ? 'started' : 'stopped'));\n    room.emit(\"recording\" + (started ? 'Started' : 'Stopped'));\n  });\n}\nfunction handleSignalingEvents(room, signaling) {\n  var log = room._log;\n  // Reemit RemoteParticipant events from the RoomSignaling.\n  log.debug('Creating a new RemoteParticipant for each ParticipantSignaling ' + 'in the RoomSignaling');\n  signaling.participants.forEach(connectParticipant.bind(null, room));\n  log.debug('Setting up RemoteParticipant creation for all subsequent ' + 'ParticipantSignalings that connect to the RoomSignaling');\n  signaling.on('participantConnected', connectParticipant.bind(null, room));\n  signaling.on('dominantSpeakerChanged', function () {\n    return room.emit('dominantSpeakerChanged', room.dominantSpeaker);\n  });\n  // Reemit state transition events from the RoomSignaling.\n  signaling.on('stateChanged', function stateChanged(state, error) {\n    log.info('Transitioned to state:', state);\n    switch (state) {\n      case 'disconnected':\n        room.participants.forEach(function (participant) {\n          participant._unsubscribeTracks();\n        });\n        room.emit(state, room, error);\n        room.localParticipant.tracks.forEach(function (publication) {\n          publication.unpublish();\n        });\n        signaling.removeListener('stateChanged', stateChanged);\n        break;\n      case 'reconnecting':\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(function () {\n          return room.emit('reconnecting', error);\n        }, 0);\n        break;\n      default:\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(function () {\n          return room.emit('reconnected');\n        }, 0);\n    }\n  });\n}\nmodule.exports = Room;","map":{"version":3,"mappings":"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","names":["EventEmitter","require","RemoteParticipant","StatsReport","flatMap","valueToJSON","nInstances","__extends","localParticipant","signaling","options","_super","log","createLog","_this","participants","Map","Object","defineProperties","_log","value","_clientTrackSwitchOffControl","clientTrackSwitchOffControl","_contentPreferencesMode","contentPreferencesMode","_instanceId","_options","_participants","_signaling","dominantSpeaker","enumerable","get","dominantSpeakerSid","isRecording","recording","isEnabled","name","sid","state","mediaRegion","handleLocalParticipantEvents","handleRecordingEvents","handleSignalingEvents","verifyNoiseCancellation","info","debug","Array","from","values","Room","disconnect","getStats","then","responses","map","_a","_b","id","response","assign","localAudioTrackStats","rewriteLocalTrackIds","localVideoTrackStats","localTrackPublications","localMediaTracks","filter","kind","track","remoteMediaTracks","tracks","mediaTracks","concat","unmuteEvent","Event","forEach","isMuted","mediaStreamTrack","dispatchEvent","pauseEvent","attachments","elShims","shim","el","isInadvertentlyPaused","paused","pausedIntentionally","room","allowedAudioProcessors","audioProcessors","audioTracks","noiseCancellation","includes","vendor","warn","disablePermanently","trackStats","localParticipantSignaling","reduce","trackStat","publication","trackId","trackSender","getSender","connectParticipant","participantSignaling","participant","set","emit","eventListeners","isArray","eventOrPair","event","participantEvent","reemit","args","slice","call","arguments","unshift","push","on","once","participantDisconnected","delete","removeListener","events","eventName","handler","_i","updated","started","bind","stateChanged","error","_unsubscribeTracks","unpublish","setTimeout","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/room.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('./eventemitter');\nconst RemoteParticipant = require('./remoteparticipant');\nconst StatsReport = require('./stats/statsreport');\nconst { flatMap, valueToJSON } = require('./util');\n\nlet nInstances = 0;\n\n/**\n * A {@link Room} represents communication between you and one or more\n * {@link RemoteParticipant}s sharing {@link AudioTrack}s and\n * {@link VideoTrack}s.\n * <br><br>\n * You can connect to a {@link Room} by calling {@link module:twilio-video.connect}.\n * @extends EventEmitter\n * @property {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @property {boolean} isRecording - Whether or not the {@link Room} is being\n *   recorded\n * @property {LocalParticipant} localParticipant - Your {@link LocalParticipant}\n *   in the {@link Room}\n * @property {string} mediaRegion - String indicating geographical region\n *    where  media is processed for the {@link Room}.\n * @property {string} name - The {@link Room}'s name\n * @property {Map<Participant.SID, RemoteParticipant>} participants -\n *   The {@link RemoteParticipant}s participating in this {@link Room}\n * @property {Room.SID} sid - The {@link Room}'s SID\n * @property {string} state - \"connected\", \"reconnecting\", or \"disconnected\"\n * @throws {SignalingConnectionDisconnectedError}\n * @emits Room#disconnected\n * @emits Room#participantConnected\n * @emits Room#participantDisconnected\n * @emits Room#participantReconnected\n * @emits Room#participantReconnecting\n * @emits Room#reconnected\n * @emits Room#reconnecting\n * @emits Room#recordingStarted\n * @emits Room#recordingStopped\n * @emits Room#trackDimensionsChanged\n * @emits Room#trackDisabled\n * @emits Room#trackEnabled\n * @emits Room#trackMessage\n * @emits Room#trackPublished\n * @emits Room#trackPublishPriorityChanged\n * @emits Room#trackStarted\n * @emits Room#trackSubscribed\n * @emits Room#trackSwitchedOff\n * @emits Room#trackSwitchedOn\n * @emits Room#trackUnpublished\n * @emits Room#trackUnsubscribed\n * @emits Room#trackWarning\n * @emits Room#trackWarningsCleared\n */\nclass Room extends EventEmitter {\n  /**\n   * Construct a {@link Room}.\n   * @param {RoomSignaling} signaling\n   * @param {?object} [options={}]\n   */\n  constructor(localParticipant, signaling, options) {\n    super();\n\n    const log = options.log.createLog('default', this);\n    const participants = new Map();\n\n    /* istanbul ignore next */\n    Object.defineProperties(this, {\n      _log: {\n        value: log\n      },\n      _clientTrackSwitchOffControl: {\n        value: options.clientTrackSwitchOffControl || 'disabled'\n      },\n      _contentPreferencesMode: {\n        value: options.contentPreferencesMode || 'disabled'\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _options: {\n        value: options\n      },\n      _participants: {\n        value: participants\n      },\n      _signaling: {\n        value: signaling\n      },\n      dominantSpeaker: {\n        enumerable: true,\n        get() {\n          return this.participants.get(signaling.dominantSpeakerSid) || null;\n        }\n      },\n      isRecording: {\n        enumerable: true,\n        get() {\n          return signaling.recording.isEnabled || false;\n        }\n      },\n      localParticipant: {\n        enumerable: true,\n        value: localParticipant\n      },\n      name: {\n        enumerable: true,\n        value: signaling.name\n      },\n      participants: {\n        enumerable: true,\n        value: participants\n      },\n      sid: {\n        enumerable: true,\n        value: signaling.sid\n      },\n      state: {\n        enumerable: true,\n        get() {\n          return signaling.state;\n        }\n      },\n      mediaRegion: {\n        enumerable: true,\n        value: signaling.mediaRegion\n      }\n    });\n\n    handleLocalParticipantEvents(this, localParticipant);\n    handleRecordingEvents(this, signaling.recording);\n    handleSignalingEvents(this, signaling);\n    verifyNoiseCancellation(this);\n\n    log.info('Created a new Room:', this.name);\n    log.debug('Initial RemoteParticipants:', Array.from(this._participants.values()));\n  }\n\n  toString() {\n    return `[Room #${this._instanceId}: ${this.sid}]`;\n  }\n\n\n  /**\n   * Disconnect from the {@link Room}.\n   * @returns {this}\n   */\n  disconnect() {\n    this._log.info('Disconnecting');\n    this._signaling.disconnect();\n    return this;\n  }\n\n  /**\n   * Get the {@link Room}'s media statistics. This is not supported in Safari 12.0 or below\n   * due to this bug : https://bugs.webkit.org/show_bug.cgi?id=192601\n   *\n   * @returns {Promise.<Array<StatsReport>>}\n   */\n  getStats() {\n    return this._signaling.getStats().then(responses =>\n      Array.from(responses).map(([id, response]) =>\n        new StatsReport(id, Object.assign({}, response, {\n          localAudioTrackStats: rewriteLocalTrackIds(this, response.localAudioTrackStats),\n          localVideoTrackStats: rewriteLocalTrackIds(this, response.localVideoTrackStats)\n        }))\n      )\n    );\n  }\n\n  /**\n   * Restart the muted local media {@link Track}s and play inadvertently paused HTMLMediaElements\n   * that are attached to local and remote media {@link Track}s. This method is useful mainly on\n   * mobile browsers (Safari and Chrome on iOS), where there is a possibility that the muted local\n   * media {@link Track}s are never unmuted and inadvertently paused HTMLMediaElements are never\n   * played again, especially after handling an incoming phone call.\n   * @returns {this}\n   */\n  refreshInactiveMedia() {\n    const { tracks: localTrackPublications } = this.localParticipant;\n\n    const localMediaTracks = Array.from(localTrackPublications.values())\n      .filter(({ track: { kind } }) => kind !== 'data')\n      .map(({ track }) => track);\n\n    const remoteMediaTracks = flatMap(this.participants, participants => Array.from(participants.tracks.values()))\n      .filter(({ track }) => track && track.kind !== 'data')\n      .map(({ track }) => track);\n\n    const mediaTracks = localMediaTracks.concat(remoteMediaTracks);\n\n    const unmuteEvent = new Event('unmute');\n    localMediaTracks.forEach(({ isMuted, mediaStreamTrack }) => {\n      if (isMuted) {\n        mediaStreamTrack.dispatchEvent(unmuteEvent);\n      }\n    });\n\n    const pauseEvent = new Event('pause');\n    mediaTracks.forEach(({ _attachments: attachments, _elShims: elShims }) => attachments.forEach(el => {\n      const shim = elShims.get(el);\n      const isInadvertentlyPaused = el.paused && shim && !shim.pausedIntentionally();\n      if (isInadvertentlyPaused) {\n        el.dispatchEvent(pauseEvent);\n      }\n    }));\n\n    return this;\n  }\n\n  toJSON() {\n    return valueToJSON(this);\n  }\n}\n\nfunction verifyNoiseCancellation(room) {\n  const allowedAudioProcessors = room.localParticipant._signaling.audioProcessors;\n  room.localParticipant.audioTracks.forEach(({ track }) => {\n    const noiseCancellation = track.noiseCancellation;\n    if (noiseCancellation && !allowedAudioProcessors.includes(noiseCancellation.vendor)) {\n      room._log.warn(`${noiseCancellation.vendor} is not supported in this room. disabling it permanently`);\n      noiseCancellation.disablePermanently();\n    }\n  });\n}\n\nfunction rewriteLocalTrackIds(room, trackStats) {\n  const localParticipantSignaling = room.localParticipant._signaling;\n  return trackStats.reduce((trackStats, trackStat) => {\n    const publication = localParticipantSignaling.tracks.get(trackStat.trackId);\n    const trackSender = localParticipantSignaling.getSender(publication);\n    return trackSender\n      ? [Object.assign({}, trackStat, { trackId: trackSender.id })].concat(trackStats)\n      : trackStats;\n  }, []);\n}\n\n/**\n * A {@link Room.SID} is a 34-character string starting with \"RM\"\n * that uniquely identifies a {@link Room}.\n * @type string\n * @typedef Room.SID\n */\n\n/**\n * The Dominant Speaker in the {@link Room} changed. Either the Dominant Speaker\n * is a new {@link RemoteParticipant} or the Dominant Speaker has been reset and\n * is now null.\n * @param {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the\n *   {@link Room}, if any\n * @event Room#dominantSpeakerChanged\n */\n\n/**\n * Your {@link LocalParticipant} was disconnected from the {@link Room} and all\n * other {@link RemoteParticipant}s.\n * @param {Room} room - The {@link Room} your\n *   {@link LocalParticipant} was disconnected from\n * @param {?TwilioError} error - Present when the {@link LocalParticipant} got\n *   disconnected from the {@link Room} unexpectedly\n * @event Room#disconnected\n * @example\n * myRoom.on('disconnected', function(room, error) {\n *   if (error) {\n *     console.log('Unexpectedly disconnected:', error);\n *   }\n *   myRoom.localParticipant.tracks.forEach(function(track) {\n *     track.stop();\n *     track.detach();\n *   });\n * });\n */\n\n/**\n * A {@link RemoteParticipant} joined the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * publishes at least one {@link LocalTrack}.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who joined\n * @event Room#participantConnected\n * @example\n * myRoom.on('participantConnected', function(participant) {\n *   console.log(participant.identity + ' joined the Room');\n * });\n */\n\n/**\n * A {@link RemoteParticipant} left the {@link Room}. In Large Group Rooms (Maximum\n * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}\n * unpublishes all its {@link LocalTrack}s.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who left\n * @event Room#participantDisconnected\n * @example\n * myRoom.on('participantDisconnected', function(participant) {\n *   console.log(participant.identity + ' left the Room');\n *   participant.tracks.forEach(function(track) {\n *     track.detach().forEach(function(mediaElement) {\n *       mediaElement.remove();\n *     });\n *   });\n * });\n */\n\n/**\n * A {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that has reconnected.\n * @event Room#participantReconnected\n * @example\n * myRoom.on('participantReconnected', participant => {\n *   console.log(participant.identity + ' reconnected to the Room');\n * });\n */\n\n/**\n * A {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that is reconnecting.\n * @event Room#participantReconnecting\n * @example\n * myRoom.on('participantReconnecting', participant => {\n *   console.log(participant.identity + ' is reconnecting to the Room');\n * });\n */\n\n/**\n * Your application successfully reconnected to the {@link Room}. When this\n * event is emitted, the {@link Room} is in state \"connected\".\n * @event Room#reconnected\n * @example\n * myRoom.on('reconnected', () => {\n *   console.log('Reconnected!');\n * });\n */\n\n/**\n * Your application is reconnecting to the {@link Room}. This happens when there\n * is a disruption in your signaling connection and/or your media connection. When\n * this event is emitted, the {@link Room} is in state \"reconnecting\". If reconnecting\n * succeeds, the {@link Room} will emit a \"reconnected\" event.\n * @param {MediaConnectionError|SignalingConnectionDisconnectedError} error - A\n *   {@link MediaConnectionError} if your application is reconnecting due to a\n *   disruption in your media connection, or a {@link SignalingConnectionDisconnectedError}\n *   if your application is reconnecting due to a disruption in your signaling connection\n * @event Room#reconnecting\n * @example\n * myRoom.on('reconnecting', error => {\n *   if (error.code === 53001) {\n *     console.log('Reconnecting your signaling connection!', error.message);\n *   } else if (error.code === 53405) {\n *     console.log('Reconnecting your media connection!', error.message);\n *   }\n * });\n */\n\n/**\n * The {@link Room} is now being recorded\n * @event Room#recordingStarted\n */\n\n/**\n * The {@link Room} is no longer being recorded\n * @event Room#recordingStopped\n */\n\n/**\n * One of the {@link RemoteParticipant}'s {@link VideoTrack}'s dimensions changed.\n * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteVideoTrack}'s dimensions changed\n * @event Room#trackDimensionsChanged\n */\n\n/**\n * A {@link RemoteTrack} was disabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents disabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   disabled the {@link RemoteTrack}\n * @event Room#trackDisabled\n */\n\n/**\n * A {@link RemoteTrack} was enabled by a {@link RemoteParticipant} in the {@link Room}.\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents enabled {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   enabled the {@link RemoteTrack}\n * @event Room#trackEnabled\n */\n\n/**\n * A message was received over one of the {@link RemoteParticipant}'s\n * {@link RemoteDataTrack}'s.\n * @param {string|ArrayBuffer} data\n * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the\n *   message was received\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteDataTrack} received the message\n * @event Room#trackMessage\n */\n\n/**\n * A {@link RemoteTrack} was published by a {@link RemoteParticipant} after\n * connecting to the {@link Room}. This event is not emitted for\n * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}\n * was connecting to the {@link Room}.\n * @event Room#trackPublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the published {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   published the {@link RemoteTrack}\n * @example\n * function trackPublished(publication, participant) {\n *   console.log(`RemoteParticipant ${participant.sid} published Track ${publication.trackSid}`);\n * }\n *\n * // Handle RemoteTracks published after connecting to the Room.\n * room.on('trackPublished', trackPublished);\n *\n * room.on('participantConnected', participant => {\n *   // Handle RemoteTracks published while connecting to the Room.\n *   participant.trackPublications.forEach(publication => trackPublished(publication, participant));\n * });\n */\n\n/**\n * One of a {@link RemoteParticipant}'s {@link RemoteTrack}s in the {@link Room} started.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that started\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} started\n * @event Room#trackStarted\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was subscribed\n * @event Room#trackSubscribed\n * @example\n * room.on('trackSubscribed', function(track, publication, participant) {\n *   var participantView = document.getElementById('participant-view-' + participant.identity);\n *   participantView.appendChild(track.attach());\n * });\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched off\n * @event Room#trackSwitchedOff\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was switched on\n * @event Room#trackSwitchedOn\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.\n * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be\n *   subscribed to\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not\n *   be subscribed to\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} could not be subscribed to\n * @event Room#trackSubscriptionFailed\n */\n\n/**\n * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the\n * {@link RemoteParticipant}.\n * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish\n *   {@link Track.Priority};\n * @param {RemoteTrackPublication} publication - The\n *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} changed priority\n * @event Room#trackPublishPriorityChanged\n */\n\n/**\n * A {@link RemoteTrack} was unpublished by a {@link RemoteParticipant} to the {@link Room}.\n * @event Room#trackUnpublished\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   which represents the unpublished {@link RemoteTrack}\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who\n *   unpublished the {@link RemoteTrack}\n */\n\n/**\n * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.\n * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed\n * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}\n *   for the {@link RemoteTrack} that was unsubscribed from\n * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose\n *   {@link RemoteTrack} was unsubscribed\n * @event Room#trackUnsubscribed\n * @example\n * room.on('trackUnsubscribed', function(track, publication, participant) {\n *   track.detach().forEach(function(mediaElement) {\n *     mediaElement.remove();\n *   });\n * });\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} encountered a warning.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {string} name - The warning that was raised.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that encountered the warning.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarning\n * @example\n * room.on('trackWarning', (name, publication, participant) => {\n *   if (name === 'recording-media-lost') {\n *     log(`LocalTrack ${publication.track.name} is not recording media.`,\n *       name, publication, participant);\n *\n *     // Wait a reasonable amount of time to clear the warning.\n *     const timer = setTimeout(() => {\n *       // If the warning is not cleared, you can manually\n *       // reconnect to the room, or show a dialog to the user\n *     }, 5000);\n *\n *     room.once('trackWarningsCleared', (publication, participant) => {\n *       log('LocalTrack warnings have cleared!',\n *         publication, participant);\n *       clearTimeout(timer);\n *     });\n *   }\n});\n */\n\n/**\n * One of the {@link LocalParticipant}'s {@link LocalTrackPublication}s in the {@link Room} cleared all warnings.\n * This event is only raised if you enabled warnings using <code>notifyWarnings</code> in <code>ConnectOptions</code>.\n * @param {LocalTrackPublication} publication - The {@link LocalTrackPublication} that cleared all warnings.\n * @param {LocalParticipant} participant - The {@link LocalParticipant}\n * @event Room#trackWarningsCleared\n */\n\nfunction connectParticipant(room, participantSignaling) {\n  const { _log: log, _clientTrackSwitchOffControl: clientTrackSwitchOffControl, _contentPreferencesMode: contentPreferencesMode } = room;\n  const participant = new RemoteParticipant(participantSignaling, { log, clientTrackSwitchOffControl, contentPreferencesMode });\n\n  log.info('A new RemoteParticipant connected:', participant);\n  room._participants.set(participant.sid, participant);\n  room.emit('participantConnected', participant);\n\n  // Reemit Track and RemoteParticipant events.\n  const eventListeners = [\n    ['reconnected', 'participantReconnected'],\n    ['reconnecting', 'participantReconnecting'],\n    'trackDimensionsChanged',\n    'trackDisabled',\n    'trackEnabled',\n    'trackMessage',\n    'trackPublished',\n    'trackPublishPriorityChanged',\n    'trackStarted',\n    'trackSubscribed',\n    'trackSubscriptionFailed',\n    'trackSwitchedOff',\n    'trackSwitchedOn',\n    'trackUnpublished',\n    'trackUnsubscribed'\n  ].map(eventOrPair => {\n    const [event, participantEvent] = Array.isArray(eventOrPair)\n      ? eventOrPair\n      : [eventOrPair, eventOrPair];\n\n    function reemit() {\n      const args = [].slice.call(arguments);\n      args.unshift(participantEvent);\n      args.push(participant);\n      room.emit(...args);\n    }\n    participant.on(event, reemit);\n    return [event, reemit];\n  });\n\n  participant.once('disconnected', function participantDisconnected() {\n    const dominantSpeaker = room.dominantSpeaker;\n    log.info('RemoteParticipant disconnected:', participant);\n    room._participants.delete(participant.sid);\n    eventListeners.forEach(args => {\n      participant.removeListener(args[0], args[1]);\n    });\n    room.emit('participantDisconnected', participant);\n    if (participant === dominantSpeaker) {\n      room.emit('dominantSpeakerChanged', room.dominantSpeaker);\n    }\n  });\n}\n\nfunction handleLocalParticipantEvents(room, localParticipant) {\n  const events = ['trackWarning', 'trackWarningsCleared'].map(event => ({\n    eventName: event,\n    handler: (...args) => room.emit(event, ...[...args, localParticipant]),\n  }));\n\n  events.forEach(({ eventName, handler }) =>\n    localParticipant.on(eventName, handler));\n\n  room.once('disconnected', () =>\n    events.forEach(({ eventName, handler }) =>\n      localParticipant.removeListener(eventName, handler)));\n}\n\nfunction handleRecordingEvents(room, recording) {\n  recording.on('updated', function updated() {\n    const started = recording.isEnabled;\n    room._log.info(`Recording ${started ? 'started' : 'stopped'}`);\n    room.emit(`recording${started ? 'Started' : 'Stopped'}`);\n  });\n}\n\nfunction handleSignalingEvents(room, signaling) {\n  const log = room._log;\n\n  // Reemit RemoteParticipant events from the RoomSignaling.\n  log.debug('Creating a new RemoteParticipant for each ParticipantSignaling '\n    + 'in the RoomSignaling');\n  signaling.participants.forEach(connectParticipant.bind(null, room));\n  log.debug('Setting up RemoteParticipant creation for all subsequent '\n    + 'ParticipantSignalings that connect to the RoomSignaling');\n  signaling.on('participantConnected', connectParticipant.bind(null, room));\n\n  signaling.on('dominantSpeakerChanged', () => room.emit('dominantSpeakerChanged', room.dominantSpeaker));\n\n  // Reemit state transition events from the RoomSignaling.\n  signaling.on('stateChanged', function stateChanged(state, error) {\n    log.info('Transitioned to state:', state);\n    switch (state) {\n      case 'disconnected':\n        room.participants.forEach(participant => {\n          participant._unsubscribeTracks();\n        });\n        room.emit(state, room, error);\n        room.localParticipant.tracks.forEach(publication => {\n          publication.unpublish();\n        });\n        signaling.removeListener('stateChanged', stateChanged);\n        break;\n      case 'reconnecting':\n\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(() => room.emit('reconnecting', error), 0);\n\n        break;\n      default:\n\n        // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.\n        // Do not signal  public events synchronously with lock held.\n        setTimeout(() => room.emit('reconnected'), 0);\n    }\n  });\n}\n\nmodule.exports = Room;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}