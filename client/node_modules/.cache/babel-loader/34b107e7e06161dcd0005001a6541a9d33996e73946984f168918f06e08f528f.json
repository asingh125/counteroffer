{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar guessBrowser = require('../../webrtc/util').guessBrowser;\nvar PeerConnectionV2 = require('./peerconnection');\nvar MediaTrackSender = require('../../media/track/sender');\nvar QueueingEventEmitter = require('../../queueingeventemitter');\nvar util = require('../../util');\nvar MediaConnectionError = require('../../util/twilio-video-errors').MediaConnectionError;\nvar isFirefox = guessBrowser() === 'firefox';\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\nvar PeerConnectionManager = /** @class */function (_super) {\n  __extends(PeerConnectionManager, _super);\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n  function PeerConnectionManager(encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this) || this;\n    options = Object.assign({\n      audioContextFactory: isFirefox ? require('../../webaudio/audiocontext') : null,\n      PeerConnectionV2: PeerConnectionV2\n    }, options);\n    var audioContext = options.audioContextFactory ? options.audioContextFactory.getOrCreate(_this) : null;\n    // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n    var offerOptions = audioContext ? {\n      offerToReceiveVideo: true\n    } : {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true\n    };\n    Object.defineProperties(_this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext)) : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n    return _this;\n  }\n  PeerConnectionManager.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(function (pc) {\n      return pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast);\n    });\n    this._preferredCodecs.video.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n  Object.defineProperty(PeerConnectionManager.prototype, \"connectionState\", {\n    /**\n     * A summarized RTCPeerConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function () {\n      return this._connectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionManager.prototype, \"iceConnectionState\", {\n    /**\n     * A summarized RTCIceConnectionState across all the\n     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n     * @property {RTCIceConnectionState}\n     */\n    get: function () {\n      return this._iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype._closeAbsentPeerConnections = function (peerConnectionStates) {\n    var peerConnectionIds = new Set(peerConnectionStates.map(function (peerConnectionState) {\n      return peerConnectionState.id;\n    }));\n    this._peerConnections.forEach(function (peerConnection) {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n    return this;\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n  PeerConnectionManager.prototype._getConfiguration = function () {\n    return this._configurationDeferred.promise;\n  };\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n  PeerConnectionManager.prototype._getOrCreate = function (id, configuration) {\n    var _this = this;\n    var self = this;\n    var peerConnection = this._peerConnections.get(id);\n    if (!peerConnection) {\n      var PeerConnectionV2_1 = this._PeerConnectionV2;\n      var options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender ? this._dummyAudioTrackSender.track : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n      try {\n        peerConnection = new PeerConnectionV2_1(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n      this._peerConnections.set(peerConnection.id, peerConnection);\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n          self._dataTrackSenders.forEach(function (sender) {\n            return peerConnection.removeDataTrackSender(sender);\n          });\n          self._mediaTrackSenders.forEach(function (sender) {\n            return peerConnection.removeMediaTrackSender(sender);\n          });\n          self._peerConnections.delete(peerConnection.id);\n          self._closedPeerConnectionIds.add(peerConnection.id);\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', function () {\n        return updateConnectionState(_this);\n      });\n      peerConnection.on('iceConnectionStateChanged', function () {\n        return updateIceConnectionState(_this);\n      });\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      updateIceConnectionState(this);\n    }\n    return peerConnection;\n  };\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.close = function () {\n    this._peerConnections.forEach(function (peerConnection) {\n      peerConnection.close();\n    });\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n    updateIceConnectionState(this);\n    return this;\n  };\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n  PeerConnectionManager.prototype.createAndOffer = function () {\n    var _this = this;\n    return this._getConfiguration().then(function (configuration) {\n      var id;\n      do {\n        id = util.makeUUID();\n      } while (_this._peerConnections.has(id));\n      return _this._getOrCreate(id, configuration);\n    }).then(function (peerConnection) {\n      return peerConnection.offer();\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  PeerConnectionManager.prototype.getTrackReceivers = function () {\n    return util.flatMap(this._peerConnections, function (peerConnection) {\n      return peerConnection.getTrackReceivers();\n    });\n  };\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n  PeerConnectionManager.prototype.getStates = function () {\n    var peerConnectionStates = [];\n    this._peerConnections.forEach(function (peerConnection) {\n      var peerConnectionState = peerConnection.getState();\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n    return peerConnectionStates;\n  };\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.setConfiguration = function (configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n    this._configuration = configuration;\n    this._configurationDeferred.resolve(configuration);\n    return this;\n  };\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.setIceReconnectTimeout = function (period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(function (peerConnection) {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n      this._sessionTimeout = period;\n    }\n    return this;\n  };\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n  PeerConnectionManager.prototype.setTrackSenders = function (trackSenders) {\n    var dataTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender.kind === 'data';\n    }));\n    var mediaTrackSenders = new Set(trackSenders.filter(function (trackSender) {\n      return trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video');\n    }));\n    var changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n  PeerConnectionManager.prototype.update = function (peerConnectionStates, synced) {\n    var _this = this;\n    if (synced === void 0) {\n      synced = false;\n    }\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n    return this._getConfiguration().then(function (configuration) {\n      return Promise.all(peerConnectionStates.map(function (peerConnectionState) {\n        if (_this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n        var peerConnection = _this._getOrCreate(peerConnectionState.id, configuration);\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(function () {\n      return _this;\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n  PeerConnectionManager.prototype.getStats = function () {\n    var peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(function (peerConnection) {\n      return peerConnection.getStats().then(function (response) {\n        return [peerConnection.id, response];\n      });\n    })).then(function (responses) {\n      return new Map(responses);\n    });\n  };\n  return PeerConnectionManager;\n}(QueueingEventEmitter);\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  var mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size || changes.data.remove.size || changes.media.add.size || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(function (peerConnection) {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      if (changes.media.add.size || changes.media.remove.size || changes.data.add.size && !peerConnection.isApplicationSectionNegotiated) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  var dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  var dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  var mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  var mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\nvar toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\nvar fromRank;\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\nfunction createFromRank() {\n  return Object.keys(toRank).reduce(function (fromRank, state) {\n    var _a;\n    return Object.assign(fromRank, (_a = {}, _a[toRank[state]] = state, _a));\n  }, {});\n}\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n  fromRank = fromRank || createFromRank();\n  return states.reduce(function (state1, state2) {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.iceConnectionState;\n  }));\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) {\n    return pcv2.connectionState;\n  }));\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\nmodule.exports = PeerConnectionManager;","map":{"version":3,"mappings":"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","names":["require","PeerConnectionV2","MediaTrackSender","QueueingEventEmitter","util","isFirefox","guessBrowser","__extends","encodingParameters","preferredCodecs","options","_super","Object","assign","audioContextFactory","audioContext","getOrCreate","_this","offerOptions","offerToReceiveVideo","offerToReceiveAudio","defineProperties","_audioContextFactory","value","_closedPeerConnectionIds","Set","_configuration","writable","_configurationDeferred","defer","_connectionState","_dummyAudioTrackSender","createDummyAudioMediaStreamTrack","_encodingParameters","_iceConnectionState","_dataTrackSenders","_lastConnectionState","_lastIceConnectionState","_mediaTrackSenders","_offerOptions","_peerConnections","Map","_preferredCodecs","_sessionTimeout","_PeerConnectionV2","PeerConnectionManager","effectiveAdaptiveSimulcast","forEach","setEffectiveAdaptiveSimulcast","video","cs","adaptiveSimulcast","peerConnectionStates","peerConnectionIds","map","id","has","peerConnection","_close","promise","configuration","self","get","PeerConnectionV2_1","dummyAudioMediaStreamTrack","track","sessionTimeout","e","MediaConnectionError","set","on","queue","bind","stateChanged","state","removeListener","removeDataTrackSender","sender","removeMediaTrackSender","delete","add","updateConnectionState","updateIceConnectionState","addDataTrackSender","addMediaTrackSender","close","stop","release","_getConfiguration","then","makeUUID","_getOrCreate","offer","flatMap","getTrackReceivers","peerConnectionState","getState","push","setConfiguration","resolve","period","setIceReconnectTimeout","trackSenders","dataTrackSenders","filter","kind","mediaTrackSenders","trackSender","changes","getTrackSenderChanges","applyTrackSenderChanges","synced","_closeAbsentPeerConnections","Promise","all","update","peerConnections","Array","from","values","getStats","response","responses","mediaStreamDestination","createMediaStreamDestination","stream","getAudioTracks","peerConnectionManager","data","size","remove","media","isApplicationSectionNegotiated","getDataTrackSenderChanges","dataTrackSendersToAdd","difference","dataTrackSendersToRemove","getMediaTrackSenderChanges","mediaTrackSendersToAdd","mediaTrackSendersToRemove","toRank","new","checking","connecting","connected","completed","disconnected","failed","closed","fromRank","createFromRank","keys","reduce","_a","summarizeIceOrPeerConnectionStates","states","length","state1","state2","Math","max","pcm","iceConnectionState","__spreadArray","emit","connectionState","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/signaling/v2/peerconnectionmanager.js"],"sourcesContent":["'use strict';\n\nconst { guessBrowser } = require('../../webrtc/util');\nconst PeerConnectionV2 = require('./peerconnection');\nconst MediaTrackSender = require('../../media/track/sender');\nconst QueueingEventEmitter = require('../../queueingeventemitter');\nconst util = require('../../util');\nconst { MediaConnectionError } = require('../../util/twilio-video-errors');\n\nconst isFirefox = guessBrowser() === 'firefox';\n\n/**\n * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.\n * @extends QueueingEventEmitter\n * @emits PeerConnectionManager#candidates\n * @emits PeerConnectionManager#connectionStateChanged\n * @emits PeerConnectionManager#description\n * @emits PeerConnectionManager#iceConnectionStateChanged\n * @emits PeerConnectionManager#trackAdded\n */\nclass PeerConnectionManager extends QueueingEventEmitter {\n  /**\n   * Construct {@link PeerConnectionManager}.\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} options\n   */\n  constructor(encodingParameters, preferredCodecs, options) {\n    super();\n\n    options = Object.assign({\n      audioContextFactory: isFirefox\n        ? require('../../webaudio/audiocontext')\n        : null,\n      PeerConnectionV2\n    }, options);\n\n    const audioContext = options.audioContextFactory\n      ? options.audioContextFactory.getOrCreate(this)\n      : null;\n\n    // NOTE(mroberts): If we're using an AudioContext, we don't need to specify\n    // `offerToReceiveAudio` in RTCOfferOptions.\n    const offerOptions = audioContext\n      ? { offerToReceiveVideo: true }\n      : { offerToReceiveAudio: true, offerToReceiveVideo: true };\n\n    Object.defineProperties(this, {\n      _audioContextFactory: {\n        value: options.audioContextFactory\n      },\n      _closedPeerConnectionIds: {\n        value: new Set()\n      },\n      _configuration: {\n        writable: true,\n        value: null\n      },\n      _configurationDeferred: {\n        writable: true,\n        value: util.defer()\n      },\n      _connectionState: {\n        value: 'new',\n        writable: true\n      },\n      _dummyAudioTrackSender: {\n        value: audioContext\n          ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext))\n          : null\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _iceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _dataTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _lastConnectionState: {\n        value: 'new',\n        writable: true\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: 'new'\n      },\n      _mediaTrackSenders: {\n        writable: true,\n        value: new Set()\n      },\n      _offerOptions: {\n        value: offerOptions\n      },\n      _peerConnections: {\n        value: new Map()\n      },\n      _preferredCodecs: {\n        value: preferredCodecs\n      },\n      _sessionTimeout: {\n        value: null,\n        writable: true\n      },\n      _PeerConnectionV2: {\n        value: options.PeerConnectionV2\n      }\n    });\n  }\n\n  setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast) {\n    this._peerConnections.forEach(pc => pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast));\n    this._preferredCodecs.video.forEach(cs => {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  }\n\n  /**\n   * A summarized RTCPeerConnectionState across all the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @property {RTCPeerConnectionState}\n   */\n  get connectionState() {\n    return this._connectionState;\n  }\n\n  /**\n   * A summarized RTCIceConnectionState across all the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @property {RTCIceConnectionState}\n   */\n  get iceConnectionState() {\n    return this._iceConnectionState;\n  }\n\n  /**\n   * Close the {@link PeerConnectionV2}s which are no longer relevant.\n   * @param {Array<object>} peerConnectionStates\n   * @returns {this}\n   */\n  _closeAbsentPeerConnections(peerConnectionStates) {\n    const peerConnectionIds = new Set(peerConnectionStates.map(peerConnectionState => peerConnectionState.id));\n    this._peerConnections.forEach(peerConnection => {\n      if (!peerConnectionIds.has(peerConnection.id)) {\n        peerConnection._close();\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Get the {@link PeerConnectionManager}'s configuration.\n   * @private\n   * @returns {Promise<object>}\n   */\n  _getConfiguration() {\n    return this._configurationDeferred.promise;\n  }\n\n  /**\n   * Get or create a {@link PeerConnectionV2}.\n   * @private\n   * @param {string} id\n   * @param {object} [configuration]\n   * @returns {PeerConnectionV2}\n   */\n  _getOrCreate(id, configuration) {\n    const self = this;\n    let peerConnection = this._peerConnections.get(id);\n    if (!peerConnection) {\n      const PeerConnectionV2 = this._PeerConnectionV2;\n\n      const options = Object.assign({\n        dummyAudioMediaStreamTrack: this._dummyAudioTrackSender\n          ? this._dummyAudioTrackSender.track\n          : null,\n        offerOptions: this._offerOptions\n      }, this._sessionTimeout ? {\n        sessionTimeout: this._sessionTimeout\n      } : {}, configuration);\n\n      try {\n        peerConnection = new PeerConnectionV2(id, this._encodingParameters, this._preferredCodecs, options);\n      } catch (e) {\n        throw new MediaConnectionError();\n      }\n\n      this._peerConnections.set(peerConnection.id, peerConnection);\n      peerConnection.on('candidates', this.queue.bind(this, 'candidates'));\n      peerConnection.on('description', this.queue.bind(this, 'description'));\n      peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));\n      peerConnection.on('stateChanged', function stateChanged(state) {\n        if (state === 'closed') {\n          peerConnection.removeListener('stateChanged', stateChanged);\n          self._dataTrackSenders.forEach(sender => peerConnection.removeDataTrackSender(sender));\n          self._mediaTrackSenders.forEach(sender => peerConnection.removeMediaTrackSender(sender));\n          self._peerConnections.delete(peerConnection.id);\n          self._closedPeerConnectionIds.add(peerConnection.id);\n          updateConnectionState(self);\n          updateIceConnectionState(self);\n        }\n      });\n      peerConnection.on('connectionStateChanged', () => updateConnectionState(this));\n      peerConnection.on('iceConnectionStateChanged', () => updateIceConnectionState(this));\n\n      this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);\n      this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);\n\n      updateIceConnectionState(this);\n    }\n    return peerConnection;\n  }\n\n  /**\n   * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.\n   * @returns {this}\n   */\n  close() {\n    this._peerConnections.forEach(peerConnection => {\n      peerConnection.close();\n    });\n    if (this._dummyAudioTrackSender) {\n      this._dummyAudioTrackSender.stop();\n    }\n    if (this._audioContextFactory) {\n      this._audioContextFactory.release(this);\n    }\n    updateIceConnectionState(this);\n    return this;\n  }\n\n  /**\n   * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.\n   * Then, create a new offer with the newly-created {@link PeerConnectionV2}.\n   * @return {Promise<this>}\n   */\n  createAndOffer() {\n    return this._getConfiguration().then(configuration => {\n      let id;\n      do {\n        id = util.makeUUID();\n      } while (this._peerConnections.has(id));\n\n      return this._getOrCreate(id, configuration);\n    }).then(peerConnection => {\n      return peerConnection.offer();\n    }).then(() => {\n      return this;\n    });\n  }\n\n  /**\n   * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all\n   * the {@link PeerConnectionV2}s.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  getTrackReceivers() {\n    return util.flatMap(this._peerConnections, peerConnection => peerConnection.getTrackReceivers());\n  }\n\n  /**\n   * Get the states of all {@link PeerConnectionV2}s.\n   * @returns {Array<object>}\n   */\n  getStates() {\n    const peerConnectionStates = [];\n    this._peerConnections.forEach(peerConnection => {\n      const peerConnectionState = peerConnection.getState();\n      if (peerConnectionState) {\n        peerConnectionStates.push(peerConnectionState);\n      }\n    });\n    return peerConnectionStates;\n  }\n\n  /**\n   * Set the {@link PeerConnectionManager}'s configuration.\n   * @param {object} configuration\n   * @returns {this}\n   */\n  setConfiguration(configuration) {\n    if (this._configuration) {\n      this._configurationDeferred = util.defer();\n      this._peerConnections.forEach(peerConnection => {\n        peerConnection.setConfiguration(configuration);\n      });\n    }\n    this._configuration = configuration;\n    this._configurationDeferred.resolve(configuration);\n    return this;\n  }\n\n  /**\n   * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  setIceReconnectTimeout(period) {\n    if (this._sessionTimeout === null) {\n      this._peerConnections.forEach(peerConnection => {\n        peerConnection.setIceReconnectTimeout(period);\n      });\n      this._sessionTimeout = period;\n    }\n    return this;\n  }\n\n  /**\n   * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the\n   * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.\n   * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders\n   * @returns {this}\n   */\n  setTrackSenders(trackSenders) {\n    const dataTrackSenders = new Set(trackSenders.filter(trackSender => trackSender.kind === 'data'));\n\n    const mediaTrackSenders = new Set(trackSenders\n      .filter(trackSender => trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video')));\n\n    const changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);\n    this._dataTrackSenders = dataTrackSenders;\n    this._mediaTrackSenders = mediaTrackSenders;\n    applyTrackSenderChanges(this, changes);\n\n    return this;\n  }\n\n  /**\n   * Update the {@link PeerConnectionManager}.\n   * @param {Array<object>} peerConnectionStates\n   * @param {boolean} [synced=false]\n   * @returns {Promise<this>}\n   */\n  update(peerConnectionStates, synced = false) {\n    if (synced) {\n      this._closeAbsentPeerConnections(peerConnectionStates);\n    }\n    return this._getConfiguration().then(configuration => {\n      return Promise.all(peerConnectionStates.map(peerConnectionState => {\n        if (this._closedPeerConnectionIds.has(peerConnectionState.id)) {\n          return null;\n        }\n        const peerConnection = this._getOrCreate(peerConnectionState.id, configuration);\n        return peerConnection.update(peerConnectionState);\n      }));\n    }).then(() => {\n      return this;\n    });\n  }\n\n  /**\n   * Get the {@link PeerConnectionManager}'s media statistics.\n   * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}\n   */\n  getStats() {\n    const peerConnections = Array.from(this._peerConnections.values());\n    return Promise.all(peerConnections.map(peerConnection => peerConnection.getStats().then(response => [\n      peerConnection.id,\n      response\n    ]))).then(responses => new Map(responses));\n  }\n}\n\n/**\n * Create a dummy audio MediaStreamTrack with the given AudioContext.\n * @private\n * @param {AudioContext} audioContext\n * @return {MediaStreamTrack}\n */\nfunction createDummyAudioMediaStreamTrack(audioContext) {\n  const mediaStreamDestination = audioContext.createMediaStreamDestination();\n  return mediaStreamDestination.stream.getAudioTracks()[0];\n}\n\n/**\n * @event {PeerConnectionManager#candidates}\n * @param {object} candidates\n */\n\n/**\n * @event {PeerConnectionManager#connectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#description}\n * @param {object} description\n */\n\n/**\n * @event {PeerConnectionManager#iceConnectionStateChanged}\n */\n\n/**\n * @event {PeerConnectionManager#trackAdded}\n * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver\n */\n\n/**\n * Apply {@link TrackSenderChanges}.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {TrackSenderChanges} changes\n * @returns {void}\n */\nfunction applyTrackSenderChanges(peerConnectionManager, changes) {\n  if (changes.data.add.size\n    || changes.data.remove.size\n    || changes.media.add.size\n    || changes.media.remove.size) {\n    peerConnectionManager._peerConnections.forEach(peerConnection => {\n      changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);\n      changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);\n      changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);\n      changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);\n      if (changes.media.add.size\n        || changes.media.remove.size\n        || (changes.data.add.size && !peerConnection.isApplicationSectionNegotiated)) {\n        peerConnection.offer();\n      }\n    });\n  }\n}\n\n/**\n * @interface DataTrackSenderChanges\n * @property {Set<DataTrackSender>} add\n * @property {Set<DataTrackSender>} remove\n */\n\n/**\n * Get the {@Link DataTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @returns {DataTrackSenderChanges} changes\n */\nfunction getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {\n  const dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);\n  const dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);\n  return {\n    add: dataTrackSendersToAdd,\n    remove: dataTrackSendersToRemove\n  };\n}\n\n/**\n * @interface TrackSenderChanges\n * @property {DataTrackSenderChanges} data\n * @property {MediaTrackSenderChanges} media\n */\n\n/**\n * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<DataTrackSender>} dataTrackSenders\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {TrackSenderChanges} changes\n */\nfunction getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {\n  return {\n    data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),\n    media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)\n  };\n}\n\n/**\n * @interface MediaTrackSenderChanges\n * @property {Set<MediaTrackSender>} add\n * @property {Set<MediaTrackSender>} remove\n */\n\n/**\n * Get the {@link MediaTrackSender} changes.\n * @param {PeerConnectionManager} peerConnectionManager\n * @param {Array<MediaTrackSender>} mediaTrackSenders\n * @returns {MediaTrackSenderChanges} changes\n */\nfunction getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {\n  const mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);\n  const mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);\n  return {\n    add: mediaTrackSendersToAdd,\n    remove: mediaTrackSendersToRemove\n  };\n}\n\n/**\n * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a \"rank\".\n */\nconst toRank = {\n  new: 0,\n  checking: 1,\n  connecting: 2,\n  connected: 3,\n  completed: 4,\n  disconnected: -1,\n  failed: -2,\n  closed: -3\n};\n\n/**\n * This object maps \"rank\" back to RTCIceConnectionState or RTCPeerConnectionState values.\n */\nlet fromRank;\n\n/**\n * `Object.keys` is not supported in older browsers, so we can't just\n * synchronously call it in this module; we need to defer invoking it until we\n * know we're in a modern environment (i.e., anything that supports WebRTC).\n * @returns {object} fromRank\n */\nfunction createFromRank() {\n  return Object.keys(toRank).reduce((fromRank, state) => {\n    return Object.assign(fromRank, { [toRank[state]]: state });\n  }, {});\n}\n\n/**\n * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.\n * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states\n * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary\n */\nfunction summarizeIceOrPeerConnectionStates(states) {\n  if (!states.length) {\n    return 'new';\n  }\n  fromRank = fromRank || createFromRank();\n  return states.reduce((state1, state2) => {\n    return fromRank[Math.max(toRank[state1], toRank[state2])];\n  });\n}\n\n/**\n * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an\n * \"iceConnectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateIceConnectionState(pcm) {\n  pcm._lastIceConnectionState = pcm.iceConnectionState;\n  pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(\n    [...pcm._peerConnections.values()].map(pcv2 => pcv2.iceConnectionState));\n  if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {\n    pcm.emit('iceConnectionStateChanged');\n  }\n}\n\n/**\n * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a\n * \"connectionStateChanged\" event, if necessary.\n * @param {PeerConnectionManager} pcm\n * @returns {void}\n */\nfunction updateConnectionState(pcm) {\n  pcm._lastConnectionState = pcm.connectionState;\n  pcm._connectionState = summarizeIceOrPeerConnectionStates(\n    [...pcm._peerConnections.values()].map(pcv2 => pcv2.connectionState));\n  if (pcm.connectionState !== pcm._lastConnectionState) {\n    pcm.emit('connectionStateChanged');\n  }\n}\n\nmodule.exports = PeerConnectionManager;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}