{"ast":null,"code":"/* globals RTCPeerConnection */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventTarget = require('../../eventtarget');\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\nvar _a = require('../util'),\n  delegateMethods = _a.delegateMethods,\n  interceptEvent = _a.interceptEvent,\n  legacyPromise = _a.legacyPromise,\n  proxyProperties = _a.proxyProperties;\n// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\nvar FirefoxRTCPeerConnection = /** @class */function (_super) {\n  __extends(FirefoxRTCPeerConnection, _super);\n  function FirefoxRTCPeerConnection(configuration) {\n    var _this = _super.call(this) || this;\n    interceptEvent(_this, 'signalingstatechange');\n    /* eslint new-cap:0 */\n    var peerConnection = new RTCPeerConnection(configuration);\n    Object.defineProperties(_this, {\n      _initiallyNegotiatedDtlsRole: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _rollingBack: {\n        value: false,\n        writable: true\n      },\n      _tracksToSSRCs: {\n        value: new Map()\n      },\n      // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n      // prototype's \"peerIdentity\" property is accessed. In order to overcome\n      // this, we ignore this property while delegating methods.\n      // Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n      peerIdentity: {\n        enumerable: true,\n        value: Promise.resolve({\n          idp: '',\n          name: ''\n        })\n      }\n    });\n    var previousSignalingState;\n    peerConnection.addEventListener('signalingstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (!_this._rollingBack && _this.signalingState !== previousSignalingState) {\n        previousSignalingState = _this.signalingState;\n        // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n        // triggered synchronously in the same tick after\n        // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n        // by triggering 'signalingstatechange' on the next tick.\n        if (_this._isClosed) {\n          setTimeout(function () {\n            return _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n          });\n        } else {\n          _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n        }\n      }\n    });\n    proxyProperties(RTCPeerConnection.prototype, _this, peerConnection);\n    return _this;\n  }\n  Object.defineProperty(FirefoxRTCPeerConnection.prototype, \"iceGatheringState\", {\n    get: function () {\n      return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirefoxRTCPeerConnection.prototype, \"localDescription\", {\n    get: function () {\n      return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirefoxRTCPeerConnection.prototype, \"signalingState\", {\n    get: function () {\n      return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FirefoxRTCPeerConnection.prototype.createAnswer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var promise;\n    promise = this._peerConnection.createAnswer().then(function (answer) {\n      saveInitiallyNegotiatedDtlsRole(_this, answer);\n      return overwriteWithInitiallyNegotiatedDtlsRole(answer, _this._initiallyNegotiatedDtlsRole);\n    });\n    return typeof args[0] === 'function' ? legacyPromise.apply(void 0, __spreadArray([promise], __read(args))) : promise;\n  };\n  // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n  // signalingState other than \"closed\"; however, Firefox has not yet implemented\n  // this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n  // this by rolling back if we are in state \"have-local-offer\" or\n  // \"have-remote-offer\". This is acceptable for our use case because we will\n  // apply the newly-created offer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  FirefoxRTCPeerConnection.prototype.createOffer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      arg1 = _a[0],\n      arg2 = _a[1],\n      arg3 = _a[2];\n    var options = arg3 || arg1 || {};\n    var promise;\n    if (this.signalingState === 'have-local-offer' || this.signalingState === 'have-remote-offer') {\n      var local = this.signalingState === 'have-local-offer';\n      promise = rollback(this, local, function () {\n        return _this.createOffer(options);\n      });\n    } else {\n      promise = this._peerConnection.createOffer(options);\n    }\n    promise = promise.then(function (offer) {\n      return new FirefoxRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTracksToSSRCs(_this._tracksToSSRCs, offer.sdp)\n      });\n    });\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  // NOTE(mroberts): While Firefox will reject the Promise returned by\n  // setLocalDescription when called from signalingState \"have-local-offer\" with\n  // an answer, it still updates the .localDescription property. We workaround\n  // this by explicitly handling this case.\n  FirefoxRTCPeerConnection.prototype.setLocalDescription = function () {\n    var _a;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _b = __read(args),\n      description = _b[0],\n      rest = _b.slice(1);\n    var promise;\n    if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n      promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n    }\n    if (promise) {\n      return args.length > 1 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(rest))) : promise;\n    }\n    return (_a = this._peerConnection).setLocalDescription.apply(_a, __spreadArray([], __read(args)));\n  };\n  // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n  // an offer multiple times in signalingState \"have-remote-offer\"; however,\n  // Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n  // We workaround this by rolling back if we are in state \"have-remote-offer\".\n  // This is acceptable for our use case; however, this may be unacceptable for\n  // other use cases.\n  //\n  // While Firefox will reject the Promise returned by setRemoteDescription when\n  // called from signalingState \"have-remote-offer\" with an answer, it sill\n  // updates the .remoteDescription property. We workaround this by explicitly\n  // handling this case.\n  FirefoxRTCPeerConnection.prototype.setRemoteDescription = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args),\n      description = _a[0],\n      rest = _a.slice(1);\n    var promise;\n    if (description && this.signalingState === 'have-remote-offer') {\n      if (description.type === 'answer') {\n        promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n      } else if (description.type === 'offer') {\n        promise = rollback(this, false, function () {\n          return _this._peerConnection.setRemoteDescription(description);\n        });\n      }\n    }\n    if (!promise) {\n      promise = this._peerConnection.setRemoteDescription(description);\n    }\n    promise = promise.then(function () {\n      return saveInitiallyNegotiatedDtlsRole(_this, description, true);\n    });\n    return args.length > 1 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(rest))) : promise;\n  };\n  // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n  // isClosed slot should immediately be set to true; however, in Firefox it\n  // occurs in the next tick. We workaround this by tracking isClosed manually.\n  FirefoxRTCPeerConnection.prototype.close = function () {\n    if (this.signalingState !== 'closed') {\n      this._isClosed = true;\n      this._peerConnection.close();\n    }\n  };\n  return FirefoxRTCPeerConnection;\n}(EventTarget);\ndelegateMethods(RTCPeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');\nfunction rollback(peerConnection, local, onceRolledBack) {\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(function (result) {\n    peerConnection._rollingBack = false;\n    return result;\n  }, function (error) {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n  var match = description.sdp.match(/a=setup:([a-z]+)/);\n  if (!match) {\n    return;\n  }\n  var dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n  return description;\n}\nmodule.exports = FirefoxRTCPeerConnection;","map":{"version":3,"mappings":"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","names":["EventTarget","require","FirefoxRTCSessionDescription","updateTracksToSSRCs","delegateMethods","interceptEvent","legacyPromise","proxyProperties","__extends","configuration","_super","_this","peerConnection","RTCPeerConnection","Object","defineProperties","_initiallyNegotiatedDtlsRole","value","writable","_isClosed","_peerConnection","_rollingBack","_tracksToSSRCs","Map","peerIdentity","enumerable","Promise","resolve","idp","name","previousSignalingState","addEventListener","_i","args","signalingState","setTimeout","dispatchEvent","prototype","FirefoxRTCPeerConnection","iceGatheringState","overwriteWithInitiallyNegotiatedDtlsRole","localDescription","promise","createAnswer","then","saveInitiallyNegotiatedDtlsRole","answer","arg1","arg2","arg3","options","local","rollback","createOffer","type","offer","sdp","length","description","rest","reject","Error","setLocalDescription","setRemoteDescription","close","onceRolledBack","result","error","remote","match","dtlsRole","active","passive","replace","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/firefox.js"],"sourcesContent":["/* globals RTCPeerConnection */\n'use strict';\n\nconst EventTarget = require('../../eventtarget');\nconst FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\nconst { updateUnifiedPlanTrackIdsToSSRCs: updateTracksToSSRCs } = require('../util/sdp');\nconst { delegateMethods, interceptEvent, legacyPromise, proxyProperties } = require('../util');\n\n// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\nclass FirefoxRTCPeerConnection extends EventTarget {\n  constructor(configuration) {\n    super();\n\n    interceptEvent(this, 'signalingstatechange');\n\n    /* eslint new-cap:0 */\n    const peerConnection = new RTCPeerConnection(configuration);\n\n    Object.defineProperties(this, {\n      _initiallyNegotiatedDtlsRole: {\n        value: null,\n        writable: true\n      },\n      _isClosed: {\n        value: false,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _rollingBack: {\n        value: false,\n        writable: true\n      },\n      _tracksToSSRCs: {\n        value: new Map()\n      },\n\n      // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n      // prototype's \"peerIdentity\" property is accessed. In order to overcome\n      // this, we ignore this property while delegating methods.\n      // Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n      peerIdentity: {\n        enumerable: true,\n        value: Promise.resolve({\n          idp: '',\n          name: ''\n        })\n      }\n    });\n\n    let previousSignalingState;\n\n    peerConnection.addEventListener('signalingstatechange', (...args) => {\n      if (!this._rollingBack && this.signalingState !== previousSignalingState) {\n        previousSignalingState = this.signalingState;\n\n        // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n        // triggered synchronously in the same tick after\n        // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n        // by triggering 'signalingstatechange' on the next tick.\n        if (this._isClosed) {\n          setTimeout(() => this.dispatchEvent(...args));\n        } else {\n          this.dispatchEvent(...args);\n        }\n      }\n    });\n\n    proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n  }\n\n  get iceGatheringState() {\n    return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n  }\n\n  get localDescription() {\n    return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n  }\n\n  get signalingState() {\n    return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n  }\n\n  createAnswer(...args) {\n    let promise;\n\n    promise = this._peerConnection.createAnswer().then(answer => {\n      saveInitiallyNegotiatedDtlsRole(this, answer);\n      return overwriteWithInitiallyNegotiatedDtlsRole(answer, this._initiallyNegotiatedDtlsRole);\n    });\n\n    return typeof args[0] === 'function'\n      ? legacyPromise(promise, ...args)\n      : promise;\n  }\n\n  // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n  // signalingState other than \"closed\"; however, Firefox has not yet implemented\n  // this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n  // this by rolling back if we are in state \"have-local-offer\" or\n  // \"have-remote-offer\". This is acceptable for our use case because we will\n  // apply the newly-created offer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  createOffer(...args) {\n    const [arg1, arg2, arg3] = args;\n    const options = arg3 || arg1 || {};\n    let promise;\n\n    if (this.signalingState === 'have-local-offer' ||\n      this.signalingState === 'have-remote-offer') {\n      const local = this.signalingState === 'have-local-offer';\n      promise = rollback(this, local, () => this.createOffer(options));\n    } else {\n      promise = this._peerConnection.createOffer(options);\n    }\n\n    promise = promise.then(offer => {\n      return new FirefoxRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTracksToSSRCs(this._tracksToSSRCs, offer.sdp)\n      });\n    });\n\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n\n  // NOTE(mroberts): While Firefox will reject the Promise returned by\n  // setLocalDescription when called from signalingState \"have-local-offer\" with\n  // an answer, it still updates the .localDescription property. We workaround\n  // this by explicitly handling this case.\n  setLocalDescription(...args) {\n    const [description, ...rest] = args;\n    let promise;\n\n    if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n      promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n    }\n\n    if (promise) {\n      return args.length > 1\n        ? legacyPromise(promise, ...rest)\n        : promise;\n    }\n\n    return this._peerConnection.setLocalDescription(...args);\n  }\n\n  // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n  // an offer multiple times in signalingState \"have-remote-offer\"; however,\n  // Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n  // We workaround this by rolling back if we are in state \"have-remote-offer\".\n  // This is acceptable for our use case; however, this may be unacceptable for\n  // other use cases.\n  //\n  // While Firefox will reject the Promise returned by setRemoteDescription when\n  // called from signalingState \"have-remote-offer\" with an answer, it sill\n  // updates the .remoteDescription property. We workaround this by explicitly\n  // handling this case.\n  setRemoteDescription(...args) {\n    const [description, ...rest] = args;\n\n    let promise;\n\n    if (description && this.signalingState === 'have-remote-offer') {\n      if (description.type === 'answer') {\n        promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n      } else if (description.type === 'offer') {\n        promise = rollback(this, false, () => this._peerConnection.setRemoteDescription(description));\n      }\n    }\n\n    if (!promise) {\n      promise = this._peerConnection.setRemoteDescription(description);\n    }\n\n    promise = promise.then(() => saveInitiallyNegotiatedDtlsRole(this, description, true));\n\n    return args.length > 1\n      ? legacyPromise(promise, ...rest)\n      : promise;\n  }\n\n  // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n  // isClosed slot should immediately be set to true; however, in Firefox it\n  // occurs in the next tick. We workaround this by tracking isClosed manually.\n  close() {\n    if (this.signalingState !== 'closed') {\n      this._isClosed = true;\n      this._peerConnection.close();\n    }\n  }\n}\n\ndelegateMethods(\n  RTCPeerConnection.prototype,\n  FirefoxRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction rollback(peerConnection, local, onceRolledBack) {\n  const setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(result => {\n    peerConnection._rollingBack = false;\n    return result;\n  }, error => {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n\n  const match = description.sdp.match(/a=setup:([a-z]+)/);\n  if (!match) {\n    return;\n  }\n\n  const dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n  return description;\n}\n\nmodule.exports = FirefoxRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}