{"ast":null,"code":"/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nvar EventTarget = require('../../eventtarget');\nvar Latch = require('../util/latch');\nvar MediaStream = require('../mediastream');\nvar RTCRtpSenderShim = require('../rtcrtpsender');\nvar _a = require('../util/sdp'),\n  getSdpFormat = _a.getSdpFormat,\n  updatePlanBTrackIdsToSSRCs = _a.updatePlanBTrackIdsToSSRCs,\n  updateUnifiedPlanTrackIdsToSSRCs = _a.updateUnifiedPlanTrackIdsToSSRCs;\nvar _b = require('../util'),\n  delegateMethods = _b.delegateMethods,\n  interceptEvent = _b.interceptEvent,\n  isIOSChrome = _b.isIOSChrome,\n  legacyPromise = _b.legacyPromise,\n  proxyProperties = _b.proxyProperties;\nvar isUnifiedPlan = getSdpFormat() === 'unified';\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nvar ChromeRTCPeerConnection = /** @class */function (_super) {\n  __extends(ChromeRTCPeerConnection, _super);\n  function ChromeRTCPeerConnection(configuration, constraints) {\n    if (configuration === void 0) {\n      configuration = {};\n    }\n    var _this = _super.call(this) || this;\n    var newConfiguration = Object.assign(configuration.iceTransportPolicy ? {\n      iceTransports: configuration.iceTransportPolicy\n    } : {}, configuration);\n    interceptEvent(_this, 'datachannel');\n    interceptEvent(_this, 'signalingstatechange');\n    var sdpFormat = getSdpFormat(newConfiguration.sdpSemantics);\n    var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n    Object.defineProperties(_this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _localStream: {\n        value: new MediaStream()\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _sdpFormat: {\n        value: sdpFormat\n      },\n      _senders: {\n        value: new Map()\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      }\n    });\n    peerConnection.addEventListener('datachannel', function (event) {\n      shimDataChannel(event.channel);\n      _this.dispatchEvent(event);\n    });\n    peerConnection.addEventListener('signalingstatechange', function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (peerConnection.signalingState === 'stable') {\n        _this._appliedTracksToSSRCs = new Map(_this._tracksToSSRCs);\n      }\n      if (!_this._pendingLocalOffer && !_this._pendingRemoteOffer) {\n        _this.dispatchEvent.apply(_this, __spreadArray([], __read(args)));\n      }\n    });\n    peerConnection.ontrack = function () {\n      // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n      // the ontrack property of the RTCPeerConnection.\n    };\n    if (typeof peerConnection.addTrack !== 'function') {\n      peerConnection.addStream(_this._localStream);\n    }\n    proxyProperties(RTCPeerConnection.prototype, _this, peerConnection);\n    return _this;\n  }\n  Object.defineProperty(ChromeRTCPeerConnection.prototype, \"localDescription\", {\n    get: function () {\n      return this._pendingLocalOffer ? this._pendingLocalOffer : this._peerConnection.localDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChromeRTCPeerConnection.prototype, \"remoteDescription\", {\n    get: function () {\n      return this._pendingRemoteOffer ? this._pendingRemoteOffer : this._peerConnection.remoteDescription;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ChromeRTCPeerConnection.prototype, \"signalingState\", {\n    get: function () {\n      if (this._pendingLocalOffer) {\n        return 'have-local-offer';\n      } else if (this._pendingRemoteOffer) {\n        return 'have-remote-offer';\n      }\n      return this._peerConnection.signalingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function (track) {\n    var _a;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return (_a = this._peerConnection).addTrack.apply(_a, __spreadArray([track], __read(rest)));\n    }\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error(\"Cannot add MediaStreamTrack [\" + track.id + \", \\n        \" + track.kind + \"]: RTCPeerConnection is closed\");\n    }\n    var sender = this._senders.get(track);\n    if (sender && sender.track) {\n      throw new Error(\"Cannot add MediaStreamTrack ['\" + track.id + \", \\n        \" + track.kind + \"]: RTCPeerConnection already has it\");\n    }\n    this._peerConnection.removeStream(this._localStream);\n    this._localStream.addTrack(track);\n    this._peerConnection.addStream(this._localStream);\n    sender = new RTCRtpSenderShim(track);\n    this._senders.set(track, sender);\n    return sender;\n  };\n  // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.removeTrack = function (sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n    if (typeof this._peerConnection.addTrack === 'function') {\n      try {\n        return this._peerConnection.removeTrack(sender);\n      } catch (e) {\n        // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n        // created by this peer connection'. This behavior does not seem to be\n        // spec compliant, so a temporary shim is introduced. A bug has been filed,\n        // and is tracked here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n      }\n    } else {\n      var track = sender.track;\n      if (!track) {\n        return;\n      }\n      sender = this._senders.get(track);\n      if (sender && sender.track) {\n        sender.track = null;\n        this._peerConnection.removeStream(this._localStream);\n        this._localStream.removeTrack(track);\n        this._peerConnection.addStream(this._localStream);\n      }\n    }\n  };\n  ChromeRTCPeerConnection.prototype.getSenders = function () {\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return this._peerConnection.getSenders();\n    }\n    return Array.from(this._senders.values());\n  };\n  ChromeRTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n    var _this = this;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    var promise;\n    if (this.signalingState === 'have-remote-offer') {\n      // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n      // \"have-remote-offer\" signalingStates, we only want to invoke the true\n      // addIceCandidates method when the remote description has been applied.\n      promise = this._signalingStateLatch.when('low').then(function () {\n        return _this._peerConnection.addIceCandidate(candidate);\n      });\n    } else {\n      promise = this._peerConnection.addIceCandidate(candidate);\n    }\n    return rest.length > 0 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(rest))) : promise;\n  };\n  // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n  // Error; however, in Chrome it does. We workaround this by checking the\n  // signalingState manually.\n  ChromeRTCPeerConnection.prototype.close = function () {\n    if (this.signalingState !== 'closed') {\n      this._pendingLocalOffer = null;\n      this._pendingRemoteOffer = null;\n      this._peerConnection.close();\n    }\n  };\n  // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n  // \"faking\" setRemoteDescription, we cannot create an answer until we actually\n  // apply the remote description. This means, once you call createAnswer, you\n  // can no longer rollback. This is acceptable for our use case because we will\n  // apply the newly-created answer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  ChromeRTCPeerConnection.prototype.createAnswer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var promise;\n    if (this._pendingRemoteOffer) {\n      promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function () {\n        // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n        // and the underlying RTCPeerConnection implementation have converged. We\n        // can unblock any pending calls to addIceCandidate now.\n        _this._signalingStateLatch.lower();\n        return _this._peerConnection.createAnswer();\n      }).then(function (answer) {\n        _this._pendingRemoteOffer = null;\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        _this._rolledBackTracksToSSRCs.clear();\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(_this._sdpFormat, _this._tracksToSSRCs, answer.sdp)\n        });\n      }, function (error) {\n        _this._pendingRemoteOffer = null;\n        throw error;\n      });\n    } else {\n      promise = this._peerConnection.createAnswer().then(function (answer) {\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        _this._rolledBackTracksToSSRCs.clear();\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(_this._sdpFormat, _this._tracksToSSRCs, answer.sdp)\n        });\n      });\n    }\n    return args.length > 1 ? legacyPromise.apply(void 0, __spreadArray([promise], __read(args))) : promise;\n  };\n  ChromeRTCPeerConnection.prototype.createOffer = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      arg1 = _a[0],\n      arg2 = _a[1],\n      arg3 = _a[2];\n    var options = arg3 || arg1 || {};\n    if (isIOSChrome()) {\n      // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n      if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n        delete options.offerToReceiveAudio;\n        try {\n          this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n            direction: 'recvonly'\n          }) : this.addTransceiver('audio');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n        delete options.offerToReceiveVideo;\n        try {\n          this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n            direction: 'recvonly'\n          }) : this.addTransceiver('video');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }\n    var promise = this._peerConnection.createOffer(options).then(function (offer) {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      _this._rolledBackTracksToSSRCs.clear();\n      return new ChromeRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(_this._sdpFormat, _this._tracksToSSRCs, offer.sdp)\n      });\n    });\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  ChromeRTCPeerConnection.prototype.createDataChannel = function (label, dataChannelDict) {\n    dataChannelDict = shimDataChannelInit(dataChannelDict);\n    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  };\n  ChromeRTCPeerConnection.prototype.setLocalDescription = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      description = _a[0],\n      arg1 = _a[1],\n      arg2 = _a[2];\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n    var promise = setDescription(this, true, description);\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  ChromeRTCPeerConnection.prototype.setRemoteDescription = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(args, 3),\n      description = _a[0],\n      arg1 = _a[1],\n      arg2 = _a[2];\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n    var promise = setDescription(this, false, description);\n    return args.length > 1 ? legacyPromise(promise, arg1, arg2) : promise;\n  };\n  return ChromeRTCPeerConnection;\n}(EventTarget);\ndelegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection');\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error(\"Cannot set \" + (local ? 'local' : 'remote') + \" offer in state \" + peerConnection.signalingState));\n    }\n    // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve();\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function () {\n        return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error(\"Cannot rollback \" + (local ? 'local' : 'remote') + \" description in \" + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer();\n      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n      promise = Promise.resolve();\n      promise.then(function () {\n        return peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function () {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function () {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (_a) {\n    var _b = _a.receiver,\n      receiver = _b === void 0 ? {} : _b;\n    var _c = receiver.track,\n      track = _c === void 0 ? {} : _c;\n    return track.kind === kind;\n  });\n}\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n  return new RTCSessionDescription(description);\n}\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n  return dataChannelDict;\n}\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n  });\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535 ? null : dataChannel.maxRetransmitTime\n    });\n  }\n  return dataChannel;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified' ? updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp) : updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\nmodule.exports = ChromeRTCPeerConnection;","map":{"version":3,"mappings":"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","names":["ChromeRTCSessionDescription","require","EventTarget","Latch","MediaStream","RTCRtpSenderShim","getSdpFormat","updatePlanBTrackIdsToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","delegateMethods","interceptEvent","isIOSChrome","legacyPromise","proxyProperties","isUnifiedPlan","__extends","configuration","constraints","_super","newConfiguration","Object","assign","iceTransportPolicy","iceTransports","_this","sdpFormat","sdpSemantics","peerConnection","RTCPeerConnection","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_localStream","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_sdpFormat","_senders","_signalingStateLatch","_tracksToSSRCs","addEventListener","shimDataChannel","event","channel","dispatchEvent","_i","args","signalingState","ontrack","addTrack","addStream","prototype","ChromeRTCPeerConnection","localDescription","remoteDescription","track","rest","Error","id","kind","sender","get","removeStream","set","removeTrack","e","getSenders","Array","from","values","candidate","promise","when","then","addIceCandidate","length","close","setRemoteDescription","lower","createAnswer","clear","type","sdp","updateTrackIdsToSSRCs","answer","error","arg1","arg2","arg3","options","offerToReceiveVideo","_audioTransceiver","hasReceiversForTracksOfKind","offerToReceiveAudio","addTransceiver","direction","Promise","reject","_videoTransceiver","createOffer","offer","label","dataChannelDict","shimDataChannelInit","dataChannel","createDataChannel","description","size","setDescription","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setLocalDescription","setRemoteAnswer","state","raise","previousSignalingState","unwrap","resolve","Event","getTransceivers","find","_a","_b","receiver","_description","RTCSessionDescription","needsMaxPacketLifeTimeShim","RTCDataChannel","maxRetransmitTime","maxPacketLifeTime","defineProperty","maxRetransmits","tracksToSSRCs","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/webrtc/rtcpeerconnection/chrome.js"],"sourcesContent":["/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nconst ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nconst EventTarget = require('../../eventtarget');\nconst Latch = require('../util/latch');\nconst MediaStream = require('../mediastream');\nconst RTCRtpSenderShim = require('../rtcrtpsender');\nconst { getSdpFormat, updatePlanBTrackIdsToSSRCs, updateUnifiedPlanTrackIdsToSSRCs } = require('../util/sdp');\nconst { delegateMethods, interceptEvent, isIOSChrome, legacyPromise, proxyProperties } = require('../util');\n\nconst isUnifiedPlan = getSdpFormat() === 'unified';\n\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nclass ChromeRTCPeerConnection extends EventTarget {\n  constructor(configuration = {}, constraints) {\n    super();\n\n    const newConfiguration = Object.assign(configuration.iceTransportPolicy\n      ? { iceTransports: configuration.iceTransportPolicy }\n      : {}, configuration);\n\n    interceptEvent(this, 'datachannel');\n    interceptEvent(this, 'signalingstatechange');\n    const sdpFormat = getSdpFormat(newConfiguration.sdpSemantics);\n    const peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n\n    Object.defineProperties(this, {\n      _appliedTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _localStream: {\n        value: new MediaStream()\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _pendingLocalOffer: {\n        value: null,\n        writable: true\n      },\n      _pendingRemoteOffer: {\n        value: null,\n        writable: true\n      },\n      _rolledBackTracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      },\n      _sdpFormat: {\n        value: sdpFormat\n      },\n      _senders: {\n        value: new Map()\n      },\n      _signalingStateLatch: {\n        value: new Latch()\n      },\n      _tracksToSSRCs: {\n        value: new Map(),\n        writable: true\n      }\n    });\n\n    peerConnection.addEventListener('datachannel', event => {\n      shimDataChannel(event.channel);\n      this.dispatchEvent(event);\n    });\n\n    peerConnection.addEventListener('signalingstatechange', (...args) => {\n      if (peerConnection.signalingState === 'stable') {\n        this._appliedTracksToSSRCs = new Map(this._tracksToSSRCs);\n      }\n      if (!this._pendingLocalOffer && !this._pendingRemoteOffer) {\n        this.dispatchEvent(...args);\n      }\n    });\n\n    peerConnection.ontrack = () => {\n      // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n      // the ontrack property of the RTCPeerConnection.\n    };\n\n    if (typeof peerConnection.addTrack !== 'function') {\n      peerConnection.addStream(this._localStream);\n    }\n    proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n  }\n\n  get localDescription() {\n    return this._pendingLocalOffer ? this._pendingLocalOffer : this._peerConnection.localDescription;\n  }\n\n  get remoteDescription() {\n    return this._pendingRemoteOffer ? this._pendingRemoteOffer : this._peerConnection.remoteDescription;\n  }\n\n  get signalingState() {\n    if (this._pendingLocalOffer) {\n      return 'have-local-offer';\n    } else if (this._pendingRemoteOffer) {\n      return 'have-remote-offer';\n    }\n    return this._peerConnection.signalingState;\n  }\n\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  addTrack(track, ...rest) {\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return this._peerConnection.addTrack(track, ...rest);\n    }\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error(`Cannot add MediaStreamTrack [${track.id}, \n        ${track.kind}]: RTCPeerConnection is closed`);\n    }\n\n    let sender = this._senders.get(track);\n    if (sender && sender.track) {\n      throw new Error(`Cannot add MediaStreamTrack ['${track.id}, \n        ${track.kind}]: RTCPeerConnection already has it`);\n    }\n    this._peerConnection.removeStream(this._localStream);\n    this._localStream.addTrack(track);\n    this._peerConnection.addStream(this._localStream);\n    sender = new RTCRtpSenderShim(track);\n    this._senders.set(track, sender);\n    return sender;\n  }\n\n  // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n  removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n    if (typeof this._peerConnection.addTrack === 'function') {\n      try {\n        return this._peerConnection.removeTrack(sender);\n      } catch (e) {\n        // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n        // created by this peer connection'. This behavior does not seem to be\n        // spec compliant, so a temporary shim is introduced. A bug has been filed,\n        // and is tracked here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n      }\n    } else {\n      const { track } = sender;\n      if (!track) {\n        return;\n      }\n      sender = this._senders.get(track);\n      if (sender && sender.track) {\n        sender.track = null;\n        this._peerConnection.removeStream(this._localStream);\n        this._localStream.removeTrack(track);\n        this._peerConnection.addStream(this._localStream);\n      }\n    }\n  }\n\n  getSenders() {\n    if (typeof this._peerConnection.addTrack === 'function') {\n      return this._peerConnection.getSenders();\n    }\n    return Array.from(this._senders.values());\n  }\n\n  addIceCandidate(candidate, ...rest) {\n    let promise;\n\n    if (this.signalingState === 'have-remote-offer') {\n      // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n      // \"have-remote-offer\" signalingStates, we only want to invoke the true\n      // addIceCandidates method when the remote description has been applied.\n      promise = this._signalingStateLatch.when('low').then(() =>\n        this._peerConnection.addIceCandidate(candidate));\n    } else {\n      promise = this._peerConnection.addIceCandidate(candidate);\n    }\n\n    return rest.length > 0\n      ? legacyPromise(promise, ...rest)\n      : promise;\n  }\n\n  // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n  // Error; however, in Chrome it does. We workaround this by checking the\n  // signalingState manually.\n  close() {\n    if (this.signalingState !== 'closed') {\n      this._pendingLocalOffer = null;\n      this._pendingRemoteOffer = null;\n      this._peerConnection.close();\n    }\n  }\n\n  // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n  // \"faking\" setRemoteDescription, we cannot create an answer until we actually\n  // apply the remote description. This means, once you call createAnswer, you\n  // can no longer rollback. This is acceptable for our use case because we will\n  // apply the newly-created answer almost immediately; however, this may be\n  // unacceptable for other use cases.\n  createAnswer(...args) {\n    let promise;\n\n    if (this._pendingRemoteOffer) {\n      promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(() => {\n        // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n        // and the underlying RTCPeerConnection implementation have converged. We\n        // can unblock any pending calls to addIceCandidate now.\n        this._signalingStateLatch.lower();\n        return this._peerConnection.createAnswer();\n      }).then(answer => {\n        this._pendingRemoteOffer = null;\n\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        this._rolledBackTracksToSSRCs.clear();\n\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(this._sdpFormat, this._tracksToSSRCs, answer.sdp)\n        });\n      }, error => {\n        this._pendingRemoteOffer = null;\n        throw error;\n      });\n    } else {\n      promise = this._peerConnection.createAnswer().then(answer => {\n        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n        // longer need to retain the rolled back tracks to SSRCs Map.\n        this._rolledBackTracksToSSRCs.clear();\n\n        return new ChromeRTCSessionDescription({\n          type: 'answer',\n          sdp: updateTrackIdsToSSRCs(this._sdpFormat, this._tracksToSSRCs, answer.sdp)\n        });\n      });\n    }\n\n    return args.length > 1\n      ? legacyPromise(promise, ...args)\n      : promise;\n  }\n\n  createOffer(...args) {\n    const [arg1, arg2, arg3] = args;\n    const options = arg3 || arg1 || {};\n\n    if (isIOSChrome()) {\n      // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.\n      if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n        delete options.offerToReceiveAudio;\n        try {\n          this._audioTransceiver = isUnifiedPlan\n            ? this.addTransceiver('audio', { direction: 'recvonly' })\n            : this.addTransceiver('audio');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n\n      if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n        delete options.offerToReceiveVideo;\n        try {\n          this._videoTransceiver = isUnifiedPlan\n            ? this.addTransceiver('video', { direction: 'recvonly' })\n            : this.addTransceiver('video');\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }\n\n    const promise = this._peerConnection.createOffer(options).then(offer => {\n      // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      this._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: offer.type,\n        sdp: updateTrackIdsToSSRCs(this._sdpFormat, this._tracksToSSRCs, offer.sdp)\n      });\n    });\n\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n\n  createDataChannel(label, dataChannelDict) {\n    dataChannelDict = shimDataChannelInit(dataChannelDict);\n    const dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n    shimDataChannel(dataChannel);\n    return dataChannel;\n  }\n\n  setLocalDescription(...args) {\n    const [description, arg1, arg2] = args;\n\n    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n    // then we need to restore the rolled back tracks to SSRCs Map.\n    if (this._rolledBackTracksToSSRCs.size > 0) {\n      this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n      this._rolledBackTracksToSSRCs.clear();\n    }\n\n    const promise = setDescription(this, true, description);\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n\n  setRemoteDescription(...args) {\n    const [description, arg1, arg2] = args;\n\n    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    this._rolledBackTracksToSSRCs.clear();\n\n    const promise = setDescription(this, false, description);\n    return args.length > 1\n      ? legacyPromise(promise, arg1, arg2)\n      : promise;\n  }\n}\n\ndelegateMethods(\n  RTCPeerConnection.prototype,\n  ChromeRTCPeerConnection.prototype,\n  '_peerConnection');\n\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  const pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  const pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  const intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  const setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  let promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error(`Cannot set ${local ? 'local' : 'remote'} offer in state ${peerConnection.signalingState}`));\n    }\n\n    // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    const previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve();\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n    }\n\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error(`Cannot rollback ${local ? 'local' : 'remote'} description in ${peerConnection.signalingState}`));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer();\n\n      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n      promise = Promise.resolve();\n      promise.then(() => peerConnection.dispatchEvent(new Event('signalingstatechange')));\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  const pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(() => {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(() => {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\n/**\n * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {ChromeRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(({ receiver = {} }) => {\n    const { track = {} } = receiver;\n    return track.kind === kind;\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n  return new RTCSessionDescription(description);\n}\n\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype\n    && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n  return dataChannelDict;\n}\n\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535\n      ? null\n      : dataChannel.maxRetransmits\n  });\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535\n        ? null\n        : dataChannel.maxRetransmitTime\n    });\n  }\n  return dataChannel;\n}\n\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified'\n    ? updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)\n    : updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}