{"ast":null,"code":"/* eslint-disable camelcase */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar EventEmitter = require('events').EventEmitter;\nvar getUserAgent = require('..').getUserAgent;\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar RECONNECT_INTERVAL_MS = 50;\nvar WS_CLOSE_NORMAL = 1000;\nvar toplevel = globalThis;\nvar WebSocket = toplevel.WebSocket ? toplevel.WebSocket : require('ws');\nvar _a = require('../constants'),\n  hardwareDevicePublisheriPad = _a.hardwareDevicePublisheriPad,\n  hardwareDevicePublisheriPhone = _a.hardwareDevicePublisheriPhone;\nvar util = require('../../util');\nvar browserdetection = require('../browserdetection');\n/**\n * Publish events to the Insights gateway.\n * @extends EventEmitter\n * @emits InsightsPublisher#connected\n * @emits InsightsPublisher#disconnected\n * @emits InsightsPublisher#reconnecting\n */\nvar InsightsPublisher = /** @class */function (_super) {\n  __extends(InsightsPublisher, _super);\n  /**\n   * @param {string} token - Insights gateway token\n   * @param {string} sdkName - Name of the SDK using the {@link InsightsPublisher}\n   * @param {string} sdkVersion - Version of the SDK using the {@link InsightsPublisher}\n   * @param {string} environment - One of 'dev', 'stage' or 'prod'\n   * @param {string} realm - Region identifier\n   * @param {InsightsPublisherOptions} options - Override default behavior\n   */\n  function InsightsPublisher(token, sdkName, sdkVersion, environment, realm, options) {\n    var _this = _super.call(this) || this;\n    options = Object.assign({\n      gateway: createGateway(environment, realm) + \"/v1/VideoEvents\",\n      maxReconnectAttempts: MAX_RECONNECT_ATTEMPTS,\n      reconnectIntervalMs: RECONNECT_INTERVAL_MS,\n      userAgent: getUserAgent(),\n      WebSocket: WebSocket\n    }, options);\n    Object.defineProperties(_this, {\n      _connectTimestamp: {\n        value: 0,\n        writable: true\n      },\n      _eventQueue: {\n        value: []\n      },\n      _readyToConnect: {\n        value: util.defer()\n      },\n      _reconnectAttemptsLeft: {\n        value: options.maxReconnectAttempts,\n        writable: true\n      },\n      _ws: {\n        value: null,\n        writable: true\n      },\n      _WebSocket: {\n        value: options.WebSocket\n      }\n    });\n    _this._readyToConnect.promise.then(function (_a) {\n      var roomSid = _a.roomSid,\n        participantSid = _a.participantSid;\n      var self = _this;\n      _this.on('disconnected', function maybeReconnect(error) {\n        self._session = null;\n        if (error && self._reconnectAttemptsLeft > 0) {\n          self.emit('reconnecting');\n          reconnect(self, token, sdkName, sdkVersion, roomSid, participantSid, options);\n          return;\n        }\n        self.removeListener('disconnected', maybeReconnect);\n      });\n      connect(_this, token, sdkName, sdkVersion, roomSid, participantSid, options);\n    }).catch(function () {\n      // ignore failures to connect\n    });\n    return _this;\n  }\n  /**\n   * Start connecting to the Insights gateway.\n   * @param {string} roomSid\n   * @param {string} participantSid\n   * @returns {void}\n   */\n  InsightsPublisher.prototype.connect = function (roomSid, participantSid) {\n    this._readyToConnect.resolve({\n      roomSid: roomSid,\n      participantSid: participantSid\n    });\n  };\n  /**\n   * Publish an event to the Insights gateway.\n   * @private\n   * @param {*} event\n   */\n  InsightsPublisher.prototype._publish = function (event) {\n    event.session = this._session;\n    this._ws.send(JSON.stringify(event));\n  };\n  /**\n   * Disconnect from the Insights gateway.\n   * @returns {boolean} true if called when connecting/open, false if not\n   */\n  InsightsPublisher.prototype.disconnect = function () {\n    if (this._ws === null || this._ws.readyState === this._WebSocket.CLOSING || this._ws.readyState === this._WebSocket.CLOSED) {\n      return false;\n    }\n    try {\n      this._ws.close();\n    } catch (error) {\n      // Do nothing.\n    }\n    this.emit('disconnected');\n    return true;\n  };\n  /**\n   * Publish (or queue, if not connected) an event to the Insights gateway.\n   * @param {string} groupName - Event group name\n   * @param {string} eventName - Event name\n   * @param {object} payload - Event payload\n   * @returns {boolean} true if queued or published, false if disconnect() called\n   */\n  InsightsPublisher.prototype.publish = function (groupName, eventName, payload) {\n    if (this._ws !== null && (this._ws.readyState === this._WebSocket.CLOSING || this._ws.readyState === this._WebSocket.CLOSED)) {\n      return false;\n    }\n    var publishOrEnqueue = typeof this._session === 'string' ? this._publish.bind(this) : this._eventQueue.push.bind(this._eventQueue);\n    publishOrEnqueue({\n      group: groupName,\n      name: eventName,\n      payload: payload,\n      timestamp: Date.now(),\n      type: 'event',\n      version: 1\n    });\n    return true;\n  };\n  return InsightsPublisher;\n}(EventEmitter);\n/**\n * Start connecting to the Insights gateway.\n * @private\n * @param {InsightsPublisher} publisher\n * @param {string} name\n * @param {string} token\n * @param {string} sdkName\n * @param {string} sdkVersion\n * @param {string} roomSid\n * @param {string} participantSid\n * @param {InsightsPublisherOptions} options\n */\nfunction connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {\n  publisher._connectTimestamp = Date.now();\n  publisher._reconnectAttemptsLeft--;\n  publisher._ws = new options.WebSocket(options.gateway);\n  var ws = publisher._ws;\n  ws.addEventListener('close', function (event) {\n    if (event.code === WS_CLOSE_NORMAL) {\n      publisher.emit('disconnected');\n      return;\n    }\n    publisher.emit('disconnected', new Error(\"WebSocket Error \" + event.code + \": \" + event.reason));\n  });\n  ws.addEventListener('message', function (message) {\n    handleConnectResponse(publisher, JSON.parse(message.data), options);\n  });\n  ws.addEventListener('open', function () {\n    var connectRequest = {\n      type: 'connect',\n      token: token,\n      version: 1\n    };\n    connectRequest.publisher = {\n      name: sdkName,\n      sdkVersion: sdkVersion,\n      userAgent: options.userAgent,\n      participantSid: participantSid,\n      roomSid: roomSid\n    };\n    if (browserdetection.isIpad()) {\n      connectRequest.publisher = __assign(__assign({}, connectRequest.publisher), hardwareDevicePublisheriPad);\n    } else if (browserdetection.isIphone()) {\n      connectRequest.publisher = __assign(__assign({}, connectRequest.publisher), hardwareDevicePublisheriPhone);\n    }\n    ws.send(JSON.stringify(connectRequest));\n  });\n}\n/**\n * Create the Insights Websocket gateway URL.\n * @param {string} environment\n * @param {string} realm\n * @returns {string}\n */\nfunction createGateway(environment, realm) {\n  return environment === 'prod' ? \"wss://sdkgw.\" + realm + \".twilio.com\" : \"wss://sdkgw.\" + environment + \"-\" + realm + \".twilio.com\";\n}\n/**\n * Handle connect response from the Insights gateway.\n * @param {InsightsPublisher} publisher\n * @param {*} response\n * @param {InsightsPublisherOptions} options\n */\nfunction handleConnectResponse(publisher, response, options) {\n  switch (response.type) {\n    case 'connected':\n      publisher._session = response.session;\n      publisher._reconnectAttemptsLeft = options.maxReconnectAttempts;\n      publisher._eventQueue.splice(0).forEach(publisher._publish, publisher);\n      publisher.emit('connected');\n      break;\n    case 'error':\n      publisher._ws.close();\n      publisher.emit('disconnected', new Error(response.message));\n      break;\n  }\n}\n/**\n * Start re-connecting to the Insights gateway with an appropriate delay based\n * on InsightsPublisherOptions#reconnectIntervalMs.\n * @private\n * @param {InsightsPublisher} publisher\n * @param {string} token\n * @param {string} sdkName\n * @param {string} sdkVersion\n * @param {string} roomSid\n * @param {string} participantSid\n * @param {InsightsPublisherOptions} options\n */\nfunction reconnect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {\n  var connectInterval = Date.now() - publisher._connectTimestamp;\n  var timeToWait = options.reconnectIntervalMs - connectInterval;\n  if (timeToWait > 0) {\n    setTimeout(function () {\n      connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);\n    }, timeToWait);\n    return;\n  }\n  connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);\n}\n/**\n * The {@link InsightsPublisher} is connected to the gateway.\n * @event InsightsPublisher#connected\n */\n/**\n * The {@link InsightsPublisher} is disconnected from the gateway.\n * @event InsightsPublisher#disconnected\n * @param {Error} [error] - Optional error if disconnected unintentionally\n */\n/**\n * The {@link InsightsPublisher} is re-connecting to the gateway.\n * @event InsightsPublisher#reconnecting\n */\n/**\n * {@link InsightsPublisher} options.\n * @typedef {object} InsightsPublisherOptions\n * @property {string} [gateway=sdkgw.{environment}-{realm}.twilio.com] - Insights WebSocket gateway url\n * @property {number} [maxReconnectAttempts=5] - Max re-connect attempts\n * @property {number} [reconnectIntervalMs=50] - Re-connect interval in ms\n */\nmodule.exports = InsightsPublisher;","map":{"version":3,"mappings":"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","names":["EventEmitter","require","MAX_RECONNECT_ATTEMPTS","RECONNECT_INTERVAL_MS","WS_CLOSE_NORMAL","toplevel","globalThis","WebSocket","hardwareDevicePublisheriPad","hardwareDevicePublisheriPhone","util","browserdetection","__extends","token","sdkName","sdkVersion","environment","realm","options","_super","Object","assign","gateway","createGateway","maxReconnectAttempts","reconnectIntervalMs","userAgent","getUserAgent","defineProperties","_this","_connectTimestamp","value","writable","_eventQueue","_readyToConnect","defer","_reconnectAttemptsLeft","_ws","_WebSocket","promise","then","_a","roomSid","participantSid","self","on","maybeReconnect","error","_session","emit","reconnect","removeListener","connect","catch","InsightsPublisher","resolve","event","session","send","JSON","stringify","readyState","CLOSING","CLOSED","close","groupName","eventName","payload","publishOrEnqueue","_publish","bind","push","group","name","timestamp","Date","now","type","version","publisher","ws","addEventListener","code","Error","reason","handleConnectResponse","parse","message","data","connectRequest","isIpad","isIphone","response","splice","forEach","connectInterval","timeToWait","setTimeout","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/util/insightspublisher/index.js"],"sourcesContent":["/* eslint-disable camelcase */\n'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst { getUserAgent } = require('..');\n\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_INTERVAL_MS = 50;\nconst WS_CLOSE_NORMAL = 1000;\n\nconst toplevel = globalThis;\nconst WebSocket = toplevel.WebSocket ? toplevel.WebSocket : require('ws');\nconst { hardwareDevicePublisheriPad, hardwareDevicePublisheriPhone } = require('../constants');\nconst util = require('../../util');\nconst browserdetection = require('../browserdetection');\n\n/**\n * Publish events to the Insights gateway.\n * @extends EventEmitter\n * @emits InsightsPublisher#connected\n * @emits InsightsPublisher#disconnected\n * @emits InsightsPublisher#reconnecting\n */\nclass InsightsPublisher extends EventEmitter {\n  /**\n   * @param {string} token - Insights gateway token\n   * @param {string} sdkName - Name of the SDK using the {@link InsightsPublisher}\n   * @param {string} sdkVersion - Version of the SDK using the {@link InsightsPublisher}\n   * @param {string} environment - One of 'dev', 'stage' or 'prod'\n   * @param {string} realm - Region identifier\n   * @param {InsightsPublisherOptions} options - Override default behavior\n   */\n  constructor(token, sdkName, sdkVersion, environment, realm, options) {\n    super();\n\n    options = Object.assign({\n      gateway: `${createGateway(environment, realm)}/v1/VideoEvents`,\n      maxReconnectAttempts: MAX_RECONNECT_ATTEMPTS,\n      reconnectIntervalMs: RECONNECT_INTERVAL_MS,\n      userAgent: getUserAgent(),\n      WebSocket,\n    }, options);\n\n    Object.defineProperties(this, {\n      _connectTimestamp: {\n        value: 0,\n        writable: true\n      },\n      _eventQueue: {\n        value: []\n      },\n      _readyToConnect: {\n        value: util.defer()\n      },\n      _reconnectAttemptsLeft: {\n        value: options.maxReconnectAttempts,\n        writable: true\n      },\n      _ws: {\n        value: null,\n        writable: true\n      },\n      _WebSocket: {\n        value: options.WebSocket\n      }\n    });\n\n    this._readyToConnect.promise.then(({ roomSid, participantSid }) => {\n      const self = this;\n      this.on('disconnected', function maybeReconnect(error) {\n        self._session = null;\n        if (error && self._reconnectAttemptsLeft > 0) {\n          self.emit('reconnecting');\n          reconnect(self, token, sdkName, sdkVersion, roomSid, participantSid, options);\n          return;\n        }\n        self.removeListener('disconnected', maybeReconnect);\n      });\n      connect(this, token, sdkName, sdkVersion, roomSid, participantSid, options);\n    }).catch(() => {\n      // ignore failures to connect\n    });\n  }\n\n  /**\n   * Start connecting to the Insights gateway.\n   * @param {string} roomSid\n   * @param {string} participantSid\n   * @returns {void}\n   */\n  connect(roomSid, participantSid) {\n    this._readyToConnect.resolve({ roomSid, participantSid });\n  }\n\n  /**\n   * Publish an event to the Insights gateway.\n   * @private\n   * @param {*} event\n   */\n  _publish(event) {\n    event.session = this._session;\n    this._ws.send(JSON.stringify(event));\n  }\n\n  /**\n   * Disconnect from the Insights gateway.\n   * @returns {boolean} true if called when connecting/open, false if not\n   */\n  disconnect() {\n    if (this._ws === null\n      || this._ws.readyState === this._WebSocket.CLOSING\n      || this._ws.readyState === this._WebSocket.CLOSED) {\n      return false;\n    }\n\n    try {\n      this._ws.close();\n    } catch (error) {\n      // Do nothing.\n    }\n    this.emit('disconnected');\n\n    return true;\n  }\n\n  /**\n   * Publish (or queue, if not connected) an event to the Insights gateway.\n   * @param {string} groupName - Event group name\n   * @param {string} eventName - Event name\n   * @param {object} payload - Event payload\n   * @returns {boolean} true if queued or published, false if disconnect() called\n   */\n  publish(groupName, eventName, payload) {\n    if (this._ws !== null\n      && (this._ws.readyState === this._WebSocket.CLOSING\n        || this._ws.readyState === this._WebSocket.CLOSED)) {\n      return false;\n    }\n\n    const publishOrEnqueue = typeof this._session === 'string'\n      ? this._publish.bind(this)\n      : this._eventQueue.push.bind(this._eventQueue);\n\n    publishOrEnqueue({\n      group: groupName,\n      name: eventName,\n      payload,\n      timestamp: Date.now(),\n      type: 'event',\n      version: 1\n    });\n\n    return true;\n  }\n}\n\n/**\n * Start connecting to the Insights gateway.\n * @private\n * @param {InsightsPublisher} publisher\n * @param {string} name\n * @param {string} token\n * @param {string} sdkName\n * @param {string} sdkVersion\n * @param {string} roomSid\n * @param {string} participantSid\n * @param {InsightsPublisherOptions} options\n */\nfunction connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {\n  publisher._connectTimestamp = Date.now();\n  publisher._reconnectAttemptsLeft--;\n  publisher._ws = new options.WebSocket(options.gateway);\n  const ws = publisher._ws;\n\n  ws.addEventListener('close', event => {\n    if (event.code === WS_CLOSE_NORMAL) {\n      publisher.emit('disconnected');\n      return;\n    }\n    publisher.emit('disconnected', new Error(`WebSocket Error ${event.code}: ${event.reason}`));\n  });\n\n  ws.addEventListener('message', message => {\n    handleConnectResponse(publisher, JSON.parse(message.data), options);\n  });\n\n  ws.addEventListener('open', () => {\n    const connectRequest = {\n      type: 'connect',\n      token,\n      version: 1\n    };\n\n    connectRequest.publisher = {\n      name: sdkName,\n      sdkVersion,\n      userAgent: options.userAgent,\n      participantSid: participantSid,\n      roomSid: roomSid,\n    };\n\n    if (browserdetection.isIpad()) {\n      connectRequest.publisher = { ...connectRequest.publisher, ...hardwareDevicePublisheriPad };\n    } else if (browserdetection.isIphone()) {\n      connectRequest.publisher = { ...connectRequest.publisher, ...hardwareDevicePublisheriPhone };\n    }\n\n    ws.send(JSON.stringify(connectRequest));\n  });\n}\n\n/**\n * Create the Insights Websocket gateway URL.\n * @param {string} environment\n * @param {string} realm\n * @returns {string}\n */\nfunction createGateway(environment, realm) {\n  return environment === 'prod' ? `wss://sdkgw.${realm}.twilio.com`\n    : `wss://sdkgw.${environment}-${realm}.twilio.com`;\n}\n\n/**\n * Handle connect response from the Insights gateway.\n * @param {InsightsPublisher} publisher\n * @param {*} response\n * @param {InsightsPublisherOptions} options\n */\nfunction handleConnectResponse(publisher, response, options) {\n  switch (response.type) {\n    case 'connected':\n      publisher._session = response.session;\n      publisher._reconnectAttemptsLeft = options.maxReconnectAttempts;\n      publisher._eventQueue.splice(0).forEach(publisher._publish, publisher);\n      publisher.emit('connected');\n      break;\n    case 'error':\n      publisher._ws.close();\n      publisher.emit('disconnected', new Error(response.message));\n      break;\n  }\n}\n\n/**\n * Start re-connecting to the Insights gateway with an appropriate delay based\n * on InsightsPublisherOptions#reconnectIntervalMs.\n * @private\n * @param {InsightsPublisher} publisher\n * @param {string} token\n * @param {string} sdkName\n * @param {string} sdkVersion\n * @param {string} roomSid\n * @param {string} participantSid\n * @param {InsightsPublisherOptions} options\n */\nfunction reconnect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {\n  const connectInterval = Date.now() - publisher._connectTimestamp;\n  const timeToWait = options.reconnectIntervalMs - connectInterval;\n\n  if (timeToWait > 0) {\n    setTimeout(() => {\n      connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);\n    }, timeToWait);\n    return;\n  }\n\n  connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);\n}\n\n/**\n * The {@link InsightsPublisher} is connected to the gateway.\n * @event InsightsPublisher#connected\n */\n\n/**\n * The {@link InsightsPublisher} is disconnected from the gateway.\n * @event InsightsPublisher#disconnected\n * @param {Error} [error] - Optional error if disconnected unintentionally\n */\n\n/**\n * The {@link InsightsPublisher} is re-connecting to the gateway.\n * @event InsightsPublisher#reconnecting\n */\n\n/**\n * {@link InsightsPublisher} options.\n * @typedef {object} InsightsPublisherOptions\n * @property {string} [gateway=sdkgw.{environment}-{realm}.twilio.com] - Insights WebSocket gateway url\n * @property {number} [maxReconnectAttempts=5] - Max re-connect attempts\n * @property {number} [reconnectIntervalMs=50] - Re-connect interval in ms\n */\n\nmodule.exports = InsightsPublisher;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}