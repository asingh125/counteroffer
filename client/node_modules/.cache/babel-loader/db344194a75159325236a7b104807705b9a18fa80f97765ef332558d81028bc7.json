{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n  var isProperty = false;\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {\n    // its okay to eat failure here.\n  }\n  // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n  if (isProperty) {\n    return;\n  }\n  var type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    return flattened.concat(mapFn(item));\n  }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' ? navigator.userAgent : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n  if (!prefix) {\n    return null;\n  }\n  var regex = new RegExp(\"(\" + prefix + \")/([^\\\\s]+)\");\n  var _a = __read(userAgent.match(regex) || [], 3),\n    match = _a[2];\n  if (!match) {\n    return null;\n  }\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  return /Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent);\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function () {\n      return currentListener;\n    },\n    set: function (newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  return onSuccess ? promise.then(onSuccess, onFailure) : promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return wrapper.dispatchEvent.apply(wrapper, __spreadArray([], __read(args)));\n    });\n    return;\n  }\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function () {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n  return typeof navigator === 'object' && typeof navigator.mediaDevices === 'object' && typeof navigator.mediaDevices.getUserMedia === 'function' && typeof RTCPeerConnection === 'function';\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;","map":{"version":3,"mappings":"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","names":["defer","deferred","promise","Promise","resolve","reject","delegateMethod","source","wrapper","target","methodName","match","isProperty","propDesc","Object","getOwnPropertyDescriptor","get","error","type","apply","arguments","delegateMethods","difference","list1","list2","Array","isArray","Set","values","forEach","has","item","add","flatMap","list","mapFn","listArray","Map","from","reduce","flattened","concat","getUserAgent","navigator","userAgent","guessBrowser","test","guessBrowserVersion","prefix","chrome","firefox","safari","regex","RegExp","versions","split","map","Number","major","isNaN","minor","isIOSChrome","interceptEvent","currentListener","defineProperty","set","newListener","removeEventListener","addEventListener","legacyPromise","onSuccess","onFailure","then","makeUUID","replace","r","Math","random","v","c","toString","proxyProperties","getOwnPropertyNames","proxyProperty","propertyName","value","writable","slice","_i","args","dispatchEvent","enumerable","support","mediaDevices","getUserMedia","RTCPeerConnection","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/webrtc/util/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  const deferred = {};\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n\n  let isProperty = false;\n  try {\n    const propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {\n    // its okay to eat failure here.\n  }\n\n  // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n  if (isProperty) {\n    return;\n  }\n\n  let type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function() {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (const methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n\n  const difference = new Set();\n\n  list1.forEach(item => {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n\n  return difference;\n}\n\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  const listArray = list instanceof Map || list instanceof Set\n    ? Array.from(list.values())\n    : list;\n\n  return listArray.reduce((flattened, item) => flattened.concat(mapFn(item)), []);\n}\n\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'\n    ? navigator.userAgent\n    : null;\n}\n\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  const prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n  const regex = new RegExp(`(${prefix})/([^\\\\s]+)`);\n  const [, , match] = userAgent.match(regex) || [];\n\n  if (!match) {\n    return null;\n  }\n  const versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));\n}\n\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  let currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function() {\n      return currentListener;\n    },\n    set: function(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  return onSuccess\n    ? promise.then(onSuccess, onFailure)\n    : promise;\n}\n\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(propertyName => {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n\n    target.addEventListener(\n      propertyName.slice(2),\n      (...args) => wrapper.dispatchEvent(...args)\n    );\n\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function() {\n      return target[propertyName];\n    }\n  });\n}\n\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n  return typeof navigator === 'object'\n    && typeof navigator.mediaDevices === 'object'\n    && typeof navigator.mediaDevices.getUserMedia === 'function'\n    && typeof RTCPeerConnection === 'function';\n}\n\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}