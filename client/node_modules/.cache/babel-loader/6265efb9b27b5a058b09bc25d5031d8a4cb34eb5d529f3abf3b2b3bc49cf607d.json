{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('./util');\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\nvar StateMachine = /** @class */function (_super) {\n  __extends(StateMachine, _super);\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n  function StateMachine(initialState, states) {\n    var _this = _super.call(this) || this;\n    var lock = null;\n    var state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(_this, {\n      _lock: {\n        get: function () {\n          return lock;\n        },\n        set: function (_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get: function () {\n          return state;\n        },\n        set: function (_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get: function () {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function () {\n          return state;\n        }\n      }\n    });\n    _this.on('stateChanged', function (state) {\n      _this._whenDeferreds.forEach(function (deferred) {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n    return _this;\n  }\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n  StateMachine.prototype._whenPromise = function (when) {\n    var _this = this;\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n    var deferred = util.defer();\n    deferred.when = when;\n    this._whenDeferreds.add(deferred);\n    return deferred.promise.then(function (payload) {\n      _this._whenDeferreds.delete(deferred);\n      return payload;\n    }, function (error) {\n      _this._whenDeferreds.delete(deferred);\n      throw error;\n    });\n  };\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n  StateMachine.prototype.bracket = function (name, transitionFunction) {\n    var key;\n    var self = this;\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n      if (error) {\n        throw error;\n      }\n    }\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  };\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n  StateMachine.prototype.hasLock = function (key) {\n    return this._lock === key;\n  };\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n  StateMachine.prototype.preempt = function (newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    }\n    // 2. Release the old lock, if any.\n    var oldLock;\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    }\n    // 3. Take the lock, if requested.\n    var key = null;\n    if (name) {\n      key = this.takeLockSync(name);\n    }\n    // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n    var preemptionKey = key ? null : this.takeLockSync('preemption');\n    // 5. Transition.\n    this.transition(newState, key || preemptionKey, payload);\n    // 6. Preempt anyone blocked on the old lock.\n    if (oldLock) {\n      oldLock.resolve();\n    }\n    // 7. Release the \"preemption\" lock, if we took it.\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n    return key;\n  };\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  StateMachine.prototype.releaseLock = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  };\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  StateMachine.prototype.releaseLockCompletely = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  };\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n  StateMachine.prototype.takeLock = function (nameOrKey) {\n    var _this = this;\n    // Reentrant lock\n    if (typeof nameOrKey === 'object') {\n      var key_1 = nameOrKey;\n      return new Promise(function (resolve) {\n        resolve(_this.takeLockSync(key_1));\n      });\n    }\n    // New lock\n    var name = nameOrKey;\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n    return Promise.resolve(this.takeLockSync(name));\n  };\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n  StateMachine.prototype.takeLockSync = function (nameOrKey) {\n    var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    var name = key ? key.name : nameOrKey;\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(\"Could not take the lock for \" + name + \" because the lock for \" + this._lock.name + \" was not released\");\n    }\n    // Reentrant lock\n    if (key) {\n      key.depth++;\n      return key;\n    }\n    // New lock\n    var lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  };\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n  StateMachine.prototype.transition = function (newState, key, payload) {\n    payload = payload || [];\n    // 1. If we're locked, required the key.\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' + 'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(\"Could not transition using the key for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n      }\n    } else if (key) {\n      throw new Error(\"Key provided for \" + key.name + \", but the StateMachine was not locked (possibly due to preemption)\");\n    }\n    // 2. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    }\n    // 3. Update the state and emit an event.\n    this._state = newState;\n    this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));\n  };\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n  StateMachine.prototype.tryTransition = function (newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  };\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  StateMachine.prototype.when = function (state) {\n    var _this = this;\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n    return this._whenPromise(function (newState, resolve, reject) {\n      if (newState === state) {\n        resolve(_this);\n      } else if (!isValidTransition(_this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  };\n  return StateMachine;\n}(EventEmitter);\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n/**\n * @typedef {object} StateMachine#Key\n */\nfunction makeLock(name) {\n  var lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce(function (newGraph, from) {\n    return newGraph.set(from, reachableFrom(graph, from));\n  }, new Map());\n}\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(function (node) {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\nfunction transformStates(states) {\n  var newStates = new Map();\n  for (var key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n  return newStates;\n}\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n  return new Error(\"\\\"\" + there + \"\\\" cannot be reached from \\\"\" + here + \"\\\"\");\n}\nmodule.exports = StateMachine;","map":{"version":3,"mappings":"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","names":["EventEmitter","require","util","__extends","initialState","states","_super","lock","state","transformStates","Object","defineProperties","_this","_lock","get","set","_reachableStates","value","reachable","_state","_states","_whenDeferreds","Set","isLocked","enumerable","on","forEach","deferred","when","resolve","reject","StateMachine","Promise","Error","defer","add","promise","then","delete","payload","error","name","transitionFunction","key","self","releaseLock","hasLock","releaseLockCompletely","takeLock","gotKey","_key","success","result","newState","isValidTransition","oldLock","takeLockSync","preemptionKey","transition","depth","nameOrKey","key_1","bind","makeLock","emit","concat","createUnreachableError","_whenPromise","graph","from","to","has","Array","keys","reduce","newGraph","reachableFrom","Map","node","newStates","here","there","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/statemachine.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst util = require('./util');\n\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\nclass StateMachine extends EventEmitter {\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n  constructor(initialState, states) {\n    super();\n    let lock = null;\n    let state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(this, {\n      _lock: {\n        get() {\n          return lock;\n        },\n        set(_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get() {\n          return state;\n        },\n        set(_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get() {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get() {\n          return state;\n        }\n      }\n    });\n\n    this.on('stateChanged', state => {\n      this._whenDeferreds.forEach(deferred => {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n  }\n\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n  _whenPromise(when) {\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n\n    const deferred = util.defer();\n\n    deferred.when = when;\n    this._whenDeferreds.add(deferred);\n\n    return deferred.promise.then(payload => {\n      this._whenDeferreds.delete(deferred);\n      return payload;\n    }, error => {\n      this._whenDeferreds.delete(deferred);\n      throw error;\n    });\n  }\n\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n  bracket(name, transitionFunction) {\n    let key;\n    const self = this;\n\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n      if (error) {\n        throw error;\n      }\n    }\n\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  }\n\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n  hasLock(key) {\n    return this._lock === key;\n  }\n\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n  preempt(newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(`Cannot transition from \"${this.state}\" to \"${newState}\"`);\n    }\n\n    // 2. Release the old lock, if any.\n    let oldLock;\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    }\n\n    // 3. Take the lock, if requested.\n    let key = null;\n    if (name) {\n      key = this.takeLockSync(name);\n    }\n\n    // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n    const preemptionKey = key ? null : this.takeLockSync('preemption');\n\n    // 5. Transition.\n    this.transition(newState, key || preemptionKey, payload);\n\n    // 6. Preempt anyone blocked on the old lock.\n    if (oldLock) {\n      oldLock.resolve();\n    }\n\n    // 7. Release the \"preemption\" lock, if we took it.\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n\n    return key;\n  }\n\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  releaseLock(key) {\n    if (!this.isLocked) {\n      throw new Error(`Could not release the lock for ${key.name} because the StateMachine is not locked`);\n    } else if (!this.hasLock(key)) {\n      throw new Error(`Could not release the lock for ${key.name} because ${this._lock.name} has the lock`);\n    }\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  }\n\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n  releaseLockCompletely(key) {\n    if (!this.isLocked) {\n      throw new Error(`Could not release the lock for ${key.name} because the StateMachine is not locked`);\n    } else if (!this.hasLock(key)) {\n      throw new Error(`Could not release the lock for ${key.name} because ${this._lock.name} has the lock`);\n    }\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  }\n\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n  takeLock(nameOrKey) {\n    // Reentrant lock\n    if (typeof nameOrKey === 'object') {\n      const key = nameOrKey;\n      return new Promise(resolve => {\n        resolve(this.takeLockSync(key));\n      });\n    }\n\n    // New lock\n    const name = nameOrKey;\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n    return Promise.resolve(this.takeLockSync(name));\n  }\n\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n  takeLockSync(nameOrKey) {\n    const key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    const name = key ? key.name : nameOrKey;\n\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(`Could not take the lock for ${name} because the lock for ${this._lock.name} was not released`);\n    }\n\n    // Reentrant lock\n    if (key) {\n      key.depth++;\n      return key;\n    }\n\n    // New lock\n    const lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  }\n\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n  transition(newState, key, payload) {\n    payload = payload || [];\n\n    // 1. If we're locked, required the key.\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' +\n          'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(`Could not transition using the key for ${key.name} because ${this._lock.name} has the lock`);\n      }\n    } else if (key) {\n      throw new Error(`Key provided for ${key.name}, but the StateMachine was not locked (possibly due to preemption)`);\n    }\n\n    // 2. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(`Cannot transition from \"${this.state}\" to \"${newState}\"`);\n    }\n\n    // 3. Update the state and emit an event.\n    this._state = newState;\n    this.emit(...['stateChanged', newState].concat(payload));\n  }\n\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n  tryTransition(newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  when(state) {\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n    return this._whenPromise((newState, resolve, reject) => {\n      if (newState === state) {\n        resolve(this);\n      } else if (!isValidTransition(this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  }\n}\n\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n\n/**\n * @typedef {object} StateMachine#Key\n */\n\nfunction makeLock(name) {\n  const lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce((newGraph, from) => newGraph.set(from, reachableFrom(graph, from)), new Map());\n}\n\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(node => {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  const newStates = new Map();\n  for (const key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n  return newStates;\n}\n\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n  return new Error(`\"${there}\" cannot be reached from \"${here}\"`);\n}\n\nmodule.exports = StateMachine;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}