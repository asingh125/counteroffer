{"ast":null,"code":"'use strict';\n\nvar defer = require('./').defer;\nvar states = {\n  high: new Set(['low']),\n  low: new Set(['high'])\n};\n/**\n * Construct a {@link Latch}.\n * @class\n * @classdesc A {@link Latch} has two states (\"high\" and \"low\") and methods for\n * transitioning between them ({@link Latch#raise} and {@link Latch#lower}).\n * @param {string} [initialState=\"low\"] - either \"high\" or \"low\"\n */\nvar Latch = /** @class */function () {\n  function Latch(initialState) {\n    if (initialState === void 0) {\n      initialState = 'low';\n    }\n    var state = initialState;\n    Object.defineProperties(this, {\n      _state: {\n        set: function (_state) {\n          var _this = this;\n          if (state !== _state) {\n            state = _state;\n            var whenDeferreds = this._whenDeferreds.get(state);\n            whenDeferreds.forEach(function (deferred) {\n              return deferred.resolve(_this);\n            });\n            whenDeferreds.clear();\n          }\n        },\n        get: function () {\n          return state;\n        }\n      },\n      _whenDeferreds: {\n        value: new Map([['high', new Set()], ['low', new Set()]])\n      }\n    });\n  }\n  Object.defineProperty(Latch.prototype, \"state\", {\n    get: function () {\n      return this._state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Transition to \"low\".\n   * @returns {this}\n   * @throws {Error}\n   */\n  Latch.prototype.lower = function () {\n    return this.transition('low');\n  };\n  /**\n   * Transition to \"high\".\n   * @returns {this}\n   * @throws {Error}\n   */\n  Latch.prototype.raise = function () {\n    return this.transition('high');\n  };\n  /**\n   * Transition to a new state.\n   * @param {string} newState\n   * @returns {this}\n   * @throws {Error}\n   */\n  Latch.prototype.transition = function (newState) {\n    if (!states[this.state].has(newState)) {\n      throw createUnreachableStateError(this.state, newState);\n    }\n    this._state = newState;\n    return this;\n  };\n  /**\n   * Return a Promise that resolves when the {@link Latch} transitions to\n   * the specified state.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  Latch.prototype.when = function (state) {\n    if (this.state === state) {\n      return Promise.resolve(this);\n    }\n    if (!states[this.state].has(state)) {\n      return Promise.reject(createUnreachableStateError(this.state, state));\n    }\n    var deferred = defer();\n    this._whenDeferreds.get(state).add(deferred);\n    return deferred.promise;\n  };\n  return Latch;\n}();\n/**\n   * Create an unreachable state Error.\n   * @param {string} from - state to be transitioned from\n   * @param {string} to - state to be transitioned to\n   * @return {Error}\n   */\nfunction createUnreachableStateError(from, to) {\n  return new Error(\"Cannot transition from \\\"\" + from + \"\\\" to \\\"\" + to + \"\\\"\");\n}\nmodule.exports = Latch;","map":{"version":3,"mappings":"AAAA,YAAY;;AAEJ,SAAK,GAAKA,OAAO,CAAC,IAAI,CAAC,MAAlB;AAEb,IAAMC,MAAM,GAAG;EACbC,IAAI,EAAE,IAAIC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;EACtBC,GAAG,EAAE,IAAID,GAAG,CAAC,CAAC,MAAM,CAAC;CACtB;AAED;;;;;;;AAOA;EACE,eAAYE,YAAoB;IAApB;MAAAA,oBAAoB;IAAA;IAC9B,IAAIC,KAAK,GAAGD,YAAY;IACxBE,MAAM,CAACC,gBAAgB,CAAC,IAAI,EAAE;MAC5BC,MAAM,EAAE;QACNC,GAAG,EAAE,UAASD,MAAM;UAAf;UACH,IAAIH,KAAK,KAAKG,MAAM,EAAE;YACpBH,KAAK,GAAGG,MAAM;YACd,IAAME,aAAa,GAAG,IAAI,CAACC,cAAc,CAACC,GAAG,CAACP,KAAK,CAAC;YACpDK,aAAa,CAACG,OAAO,CAAC,kBAAQ;cAAI,eAAQ,CAACC,OAAO,CAACC,KAAI,CAAC;YAAtB,CAAsB,CAAC;YACzDL,aAAa,CAACM,KAAK,EAAE;;QAEzB,CAAC;QACDJ,GAAG,EAAE;UACH,OAAOP,KAAK;QACd;OACD;MACDM,cAAc,EAAE;QACdM,KAAK,EAAE,IAAIC,GAAG,CAAC,CACb,CAAC,MAAM,EAAE,IAAIhB,GAAG,EAAE,CAAC,EACnB,CAAC,KAAK,EAAE,IAAIA,GAAG,EAAE,CAAC,CACnB;;KAEJ,CAAC;EACJ;EAEAI,sBAAIa,wBAAK;SAAT;MACE,OAAO,IAAI,CAACX,MAAM;IACpB,CAAC;;;;EAED;;;;;EAKAW,qBAAK,GAAL;IACE,OAAO,IAAI,CAACC,UAAU,CAAC,KAAK,CAAC;EAC/B,CAAC;EAED;;;;;EAKAD,qBAAK,GAAL;IACE,OAAO,IAAI,CAACC,UAAU,CAAC,MAAM,CAAC;EAChC,CAAC;EAED;;;;;;EAMAD,0BAAU,GAAV,UAAWE,QAAQ;IACjB,IAAI,CAACrB,MAAM,CAAC,IAAI,CAACK,KAAK,CAAC,CAACiB,GAAG,CAACD,QAAQ,CAAC,EAAE;MACrC,MAAME,2BAA2B,CAAC,IAAI,CAAClB,KAAK,EAAEgB,QAAQ,CAAC;;IAEzD,IAAI,CAACb,MAAM,GAAGa,QAAQ;IACtB,OAAO,IAAI;EACb,CAAC;EAED;;;;;;EAMAF,oBAAI,GAAJ,UAAKd,KAAK;IACR,IAAI,IAAI,CAACA,KAAK,KAAKA,KAAK,EAAE;MACxB,OAAOmB,OAAO,CAACV,OAAO,CAAC,IAAI,CAAC;;IAE9B,IAAI,CAACd,MAAM,CAAC,IAAI,CAACK,KAAK,CAAC,CAACiB,GAAG,CAACjB,KAAK,CAAC,EAAE;MAClC,OAAOmB,OAAO,CAACC,MAAM,CAACF,2BAA2B,CAAC,IAAI,CAAClB,KAAK,EAAEA,KAAK,CAAC,CAAC;;IAEvE,IAAMqB,QAAQ,GAAGC,KAAK,EAAE;IACxB,IAAI,CAAChB,cAAc,CAACC,GAAG,CAACP,KAAK,CAAC,CAACuB,GAAG,CAACF,QAAQ,CAAC;IAC5C,OAAOA,QAAQ,CAACG,OAAO;EACzB,CAAC;EACH,YAAC;AAAD,CAAC,EA/ED;AAiFA;;;;;;AAMA,SAASN,2BAA2B,CAACO,IAAI,EAAEC,EAAE;EAC3C,OAAO,IAAIC,KAAK,CAAC,8BAA2BF,IAAI,gBAASC,EAAE,OAAG,CAAC;AACjE;AAEAE,MAAM,CAACC,OAAO,GAAGf,KAAK","names":["require","states","high","Set","low","initialState","state","Object","defineProperties","_state","set","whenDeferreds","_whenDeferreds","get","forEach","resolve","_this","clear","value","Map","Latch","transition","newState","has","createUnreachableStateError","Promise","reject","deferred","defer","add","promise","from","to","Error","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/webrtc/util/latch.js"],"sourcesContent":["'use strict';\n\nconst { defer } = require('./');\n\nconst states = {\n  high: new Set(['low']),\n  low: new Set(['high'])\n};\n\n/**\n * Construct a {@link Latch}.\n * @class\n * @classdesc A {@link Latch} has two states (\"high\" and \"low\") and methods for\n * transitioning between them ({@link Latch#raise} and {@link Latch#lower}).\n * @param {string} [initialState=\"low\"] - either \"high\" or \"low\"\n */\nclass Latch {\n  constructor(initialState = 'low') {\n    let state = initialState;\n    Object.defineProperties(this, {\n      _state: {\n        set: function(_state) {\n          if (state !== _state) {\n            state = _state;\n            const whenDeferreds = this._whenDeferreds.get(state);\n            whenDeferreds.forEach(deferred => deferred.resolve(this));\n            whenDeferreds.clear();\n          }\n        },\n        get: function() {\n          return state;\n        }\n      },\n      _whenDeferreds: {\n        value: new Map([\n          ['high', new Set()],\n          ['low', new Set()]\n        ])\n      }\n    });\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  /**\n   * Transition to \"low\".\n   * @returns {this}\n   * @throws {Error}\n   */\n  lower() {\n    return this.transition('low');\n  }\n\n  /**\n   * Transition to \"high\".\n   * @returns {this}\n   * @throws {Error}\n   */\n  raise() {\n    return this.transition('high');\n  }\n\n  /**\n   * Transition to a new state.\n   * @param {string} newState\n   * @returns {this}\n   * @throws {Error}\n   */\n  transition(newState) {\n    if (!states[this.state].has(newState)) {\n      throw createUnreachableStateError(this.state, newState);\n    }\n    this._state = newState;\n    return this;\n  }\n\n  /**\n   * Return a Promise that resolves when the {@link Latch} transitions to\n   * the specified state.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n  when(state) {\n    if (this.state === state) {\n      return Promise.resolve(this);\n    }\n    if (!states[this.state].has(state)) {\n      return Promise.reject(createUnreachableStateError(this.state, state));\n    }\n    const deferred = defer();\n    this._whenDeferreds.get(state).add(deferred);\n    return deferred.promise;\n  }\n}\n\n/**\n   * Create an unreachable state Error.\n   * @param {string} from - state to be transitioned from\n   * @param {string} to - state to be transitioned to\n   * @return {Error}\n   */\nfunction createUnreachableStateError(from, to) {\n  return new Error(`Cannot transition from \"${from}\" to \"${to}\"`);\n}\n\nmodule.exports = Latch;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}