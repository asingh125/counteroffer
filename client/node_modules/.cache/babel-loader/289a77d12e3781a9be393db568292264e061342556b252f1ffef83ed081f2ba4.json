{"ast":null,"code":"'use strict';\n\nvar _a = require('../../util/constants'),\n  ICE_ACTIVITY_CHECK_PERIOD_MS = _a.ICE_ACTIVITY_CHECK_PERIOD_MS,\n  ICE_INACTIVITY_THRESHOLD_MS = _a.ICE_INACTIVITY_THRESHOLD_MS;\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\nvar IceConnectionMonitor = /** @class */function () {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  function IceConnectionMonitor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS\n    }, options);\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n  IceConnectionMonitor.prototype._getActivePairStat = function (stats) {\n    var statsArray = Array.from(stats.values());\n    var activePairStats = statsArray.find(function (stat) {\n      return stat.type === 'candidate-pair' && stat.nominated;\n    });\n    // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round(new Date().getTime())\n    };\n  };\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n  IceConnectionMonitor.prototype._getIceConnectionStats = function () {\n    var _this = this;\n    return this._peerConnection.getStats().then(function (stats) {\n      return _this._getActivePairStat(stats);\n    }).catch(function () {\n      return null;\n    });\n  };\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n  IceConnectionMonitor.prototype._scheduleInactivityCallback = function (callback) {\n    var _this = this;\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = function () {\n        if (_this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n      this._onIceConnectionStateChanged = null;\n    }\n  };\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n  IceConnectionMonitor.prototype.start = function (onIceConnectionInactive) {\n    var _this = this;\n    this.stop();\n    this._timer = setInterval(function () {\n      _this._getIceConnectionStats().then(function (iceStats) {\n        if (!iceStats) {\n          return;\n        }\n        // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n        if (!_this._lastActivity || _this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          _this._lastActivity = iceStats;\n          // detected activity, cancel scheduled callback if any.\n          _this._scheduleInactivityCallback(null);\n        }\n        if (iceStats.timestamp - _this._lastActivity.timestamp >= _this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (_this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (_this._onIceConnectionStateChanged === null) {\n            _this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  };\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n  IceConnectionMonitor.prototype.stop = function () {\n    this._scheduleInactivityCallback(null);\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  };\n  return IceConnectionMonitor;\n}();\nmodule.exports = IceConnectionMonitor;","map":{"version":3,"mappings":"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","names":["require","ICE_ACTIVITY_CHECK_PERIOD_MS","ICE_INACTIVITY_THRESHOLD_MS","peerConnection","options","Object","assign","activityCheckPeriodMs","inactivityThresholdMs","defineProperties","_activityCheckPeriodMs","value","_inactivityThresholdMs","_lastActivity","writable","_peerConnection","_timer","_onIceConnectionStateChanged","IceConnectionMonitor","stats","statsArray","Array","from","values","activePairStats","find","type","stat","nominated","bytesReceived","timestamp","Math","round","Date","getTime","getStats","then","_getActivePairStat","catch","callback","_this","iceConnectionState","addEventListener","removeEventListener","onIceConnectionInactive","stop","setInterval","_getIceConnectionStats","iceStats","_scheduleInactivityCallback","clearInterval","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/signaling/v2/iceconnectionmonitor.js"],"sourcesContent":["'use strict';\n\nconst { ICE_ACTIVITY_CHECK_PERIOD_MS, ICE_INACTIVITY_THRESHOLD_MS } = require('../../util/constants');\n\n/**\n * Monitors a {@link RTCPeerConnection}'s stats and notifies\n * caller when inactivity is detected.\n */\nclass IceConnectionMonitor {\n  /**\n   * Construct an {@link IceConnectionMonitor}.\n   * @param {RTCPeerConnection} peerConnection\n   * @param {object} [options]\n   */\n  constructor(peerConnection, options) {\n    options = Object.assign({\n      activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,\n      inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS,\n    }, options);\n\n    Object.defineProperties(this, {\n      _activityCheckPeriodMs: {\n        value: options.activityCheckPeriodMs\n      },\n      _inactivityThresholdMs: {\n        value: options.inactivityThresholdMs\n      },\n      _lastActivity: {\n        value: null,\n        writable: true\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _timer: {\n        value: null,\n        writable: true,\n      },\n      _onIceConnectionStateChanged: {\n        value: null,\n        writable: true\n      }\n    });\n  }\n\n  _getActivePairStat(stats) {\n    const statsArray = Array.from(stats.values());\n    const activePairStats = statsArray.find(stat => stat.type === 'candidate-pair' && stat.nominated);\n    // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network\n    // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.\n    return activePairStats || {\n      bytesReceived: 0,\n      timestamp: Math.round((new Date()).getTime())\n    };\n  }\n\n  /**\n   * Get ICE connection stats, and extract received and send bytes.\n   * @returns Promise<?RTCIceCandidatePairStats>\n   */\n  _getIceConnectionStats() {\n    return this._peerConnection.getStats().then(stats => this._getActivePairStat(stats)).catch(() => {\n      return null;\n    });\n  }\n\n  /**\n   * schedules/un-schedules inactivity callback.\n   */\n  _scheduleInactivityCallback(callback) {\n    if (callback && this._onIceConnectionStateChanged === null) {\n      // schedule callback\n      this._onIceConnectionStateChanged = () => {\n        if (this._peerConnection.iceConnectionState === 'disconnected') {\n          // eslint-disable-next-line callback-return\n          callback();\n        }\n      };\n      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n    } else if (!callback && this._onIceConnectionStateChanged) {\n      // unschedule callback\n      this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);\n      this._onIceConnectionStateChanged = null;\n    }\n  }\n\n  /**\n   * Start monitoring the ICE connection.\n   * Monitors bytes received on active ice connection pair,\n   * invokes onIceConnectionInactive when inactivity is detected.\n   * @param {function} onIceConnectionInactive\n   */\n  start(onIceConnectionInactive) {\n    this.stop();\n\n    this._timer = setInterval(() => {\n      this._getIceConnectionStats().then(iceStats => {\n        if (!iceStats) {\n          return;\n        }\n\n        // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.\n        // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value\n        // includes RTCP traffic and is +ve even when there are no tracks subscribed to.\n        if (!this._lastActivity || this._lastActivity.bytesReceived !== iceStats.bytesReceived) {\n          this._lastActivity = iceStats;\n          // detected activity, cancel scheduled callback if any.\n          this._scheduleInactivityCallback(null);\n        }\n\n        if (iceStats.timestamp - this._lastActivity.timestamp >= this._inactivityThresholdMs) {\n          // detected inactivity.\n          if (this._peerConnection.iceConnectionState === 'disconnected') {\n            onIceConnectionInactive();\n          } else if (this._onIceConnectionStateChanged === null) {\n            this._scheduleInactivityCallback(onIceConnectionInactive);\n          }\n        }\n      });\n    }, this._activityCheckPeriodMs);\n  }\n\n  /**\n   * Stop monitoring the ICE connection state.\n   * @returns {void}\n   */\n  stop() {\n    this._scheduleInactivityCallback(null);\n    if (this._timer !== null) {\n      clearInterval(this._timer);\n      this._timer = null;\n      this._lastActivity = null;\n    }\n  }\n}\n\nmodule.exports = IceConnectionMonitor;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}