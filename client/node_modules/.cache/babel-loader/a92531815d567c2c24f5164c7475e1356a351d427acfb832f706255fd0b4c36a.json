{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar getUserMedia = require('../../webrtc').getUserMedia;\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar _a = require('../../util'),\n  capitalize = _a.capitalize,\n  defer = _a.defer,\n  isUserMediaTrack = _a.isUserMediaTrack,\n  waitForSometime = _a.waitForSometime,\n  waitForEvent = _a.waitForEvent;\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\nvar detectSilentAudio = require('../../util/detectsilentaudio');\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nvar MediaTrackSender = require('./sender');\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#muted\n   * @emits LocalMediaTrack#stopped\n   * @emits LocalMediaTrack#unmuted\n   */\n  return (/** @class */function (_super) {\n      __extends(LocalMediaTrack, _super);\n      /**\n       * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n       * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n       * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n       */\n      function LocalMediaTrack(mediaStreamTrack, options) {\n        var _this = this;\n        var workaroundWebKitBug1208516 = isIOS() && isUserMediaTrack(mediaStreamTrack) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n        options = Object.assign({\n          getUserMedia: getUserMedia,\n          isCreatedByCreateLocalTracks: false,\n          workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n          gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n        }, options);\n        var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n        var kind = mediaTrackSender.kind;\n        _this = _super.call(this, mediaTrackSender, options) || this;\n        Object.defineProperties(_this, {\n          _constraints: {\n            value: typeof options[kind] === 'object' ? options[kind] : {},\n            writable: true\n          },\n          _getUserMedia: {\n            value: options.getUserMedia\n          },\n          _gUMSilentTrackWorkaround: {\n            value: options.gUMSilentTrackWorkaround\n          },\n          _eventsToReemitters: {\n            value: new Map([['muted', function () {\n              return _this.emit('muted', _this);\n            }], ['unmuted', function () {\n              return _this.emit('unmuted', _this);\n            }]])\n          },\n          _workaroundWebKitBug1208516: {\n            value: options.workaroundWebKitBug1208516\n          },\n          _workaroundWebKitBug1208516Cleanup: {\n            value: null,\n            writable: true\n          },\n          _didCallEnd: {\n            value: false,\n            writable: true\n          },\n          _isCreatedByCreateLocalTracks: {\n            value: options.isCreatedByCreateLocalTracks\n          },\n          _trackSender: {\n            value: mediaTrackSender\n          },\n          id: {\n            enumerable: true,\n            value: mediaTrackSender.id\n          },\n          isEnabled: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.enabled;\n            }\n          },\n          isMuted: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.muted;\n            }\n          },\n          isStopped: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.readyState === 'ended';\n            }\n          }\n        });\n        // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n        // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n        if (_this._workaroundWebKitBug1208516) {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        }\n        _this._reemitTrackSenderEvents();\n        return _this;\n      }\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._end = function () {\n        var _this = this;\n        if (this._didCallEnd) {\n          return;\n        }\n        _super.prototype._end.call(this);\n        this._didCallEnd = true;\n        this._eventsToReemitters.forEach(function (reemitter, event) {\n          return _this._trackSender.removeListener(event, reemitter);\n        });\n        this.emit('stopped', this);\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._initialize = function () {\n        if (this._didCallEnd) {\n          this._didCallEnd = false;\n        }\n        if (this._eventsToReemitters) {\n          this._reemitTrackSenderEvents();\n        }\n        _super.prototype._initialize.call(this);\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n        var _a;\n        var _b = this,\n          getUserMedia = _b._getUserMedia,\n          gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n          log = _b._log,\n          kind = _b.mediaStreamTrack.kind;\n        log.info('Re-acquiring the MediaStreamTrack');\n        log.debug('Constraints:', constraints);\n        var gUMConstraints = Object.assign({\n          audio: false,\n          video: false\n        }, (_a = {}, _a[kind] = constraints, _a));\n        var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n        return gUMPromise.then(function (mediaStream) {\n          return mediaStream.getTracks()[0];\n        });\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._reemitTrackSenderEvents = function () {\n        var _this = this;\n        this._eventsToReemitters.forEach(function (reemitter, event) {\n          return _this._trackSender.on(event, reemitter);\n        });\n        this._trackSender.dequeue('muted');\n        this._trackSender.dequeue('unmuted');\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._restart = function (constraints) {\n        var _this = this;\n        var log = this._log;\n        constraints = constraints || this._constraints;\n        // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n        // without stopping it first, then a NotReadableError is raised in case of\n        // video, or the restarted audio will still be silent. Hence, we stop the\n        // MediaStreamTrack here.\n        this._stop();\n        return this._reacquireTrack(constraints).catch(function (error) {\n          log.error('Failed to re-acquire the MediaStreamTrack:', {\n            error: error,\n            constraints: constraints\n          });\n          throw error;\n        }).then(function (newMediaStreamTrack) {\n          log.info('Re-acquired the MediaStreamTrack');\n          log.debug('MediaStreamTrack:', newMediaStreamTrack);\n          _this._constraints = Object.assign({}, constraints);\n          return _this._setMediaStreamTrack(newMediaStreamTrack);\n        });\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n        var _this = this;\n        // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n        mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n        // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n        // stopped, this should fire a \"stopped\" event.\n        this._stop();\n        // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n        // the processedTrack already set, we don't want to replace that.\n        return (this._unprocessedTrack ? Promise.resolve().then(function () {\n          _this._unprocessedTrack = mediaStreamTrack;\n        }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n          _this._log.warn('setMediaStreamTrack failed:', {\n            error: error,\n            mediaStreamTrack: mediaStreamTrack\n          });\n        })).then(function () {\n          _this._initialize();\n          _this._getAllAttachedElements().forEach(function (el) {\n            return _this._attach(el);\n          });\n        });\n      };\n      /**\n       * @private\n       */\n      LocalMediaTrack.prototype._stop = function () {\n        this.mediaStreamTrack.stop();\n        this._end();\n        return this;\n      };\n      LocalMediaTrack.prototype.enable = function (enabled) {\n        enabled = typeof enabled === 'boolean' ? enabled : true;\n        if (enabled !== this.mediaStreamTrack.enabled) {\n          this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n          this.mediaStreamTrack.enabled = enabled;\n          this.emit(enabled ? 'enabled' : 'disabled', this);\n        }\n        return this;\n      };\n      LocalMediaTrack.prototype.disable = function () {\n        return this.enable(false);\n      };\n      LocalMediaTrack.prototype.restart = function (constraints) {\n        var _this = this;\n        var kind = this.kind;\n        if (!this._isCreatedByCreateLocalTracks) {\n          return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n        }\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n        var promise = this._restart(constraints);\n        if (this._workaroundWebKitBug1208516) {\n          promise = promise.finally(function () {\n            _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n          });\n        }\n        return promise;\n      };\n      LocalMediaTrack.prototype.stop = function () {\n        this._log.info('Stopping');\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n        return this._stop();\n      };\n      return LocalMediaTrack;\n    }(AudioOrVideoTrack)\n  );\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n    kind = localMediaTrack.kind;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var el = localMediaTrack._dummyEl,\n    mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n  var trackChangeInProgress = null;\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n      isStopped = localMediaTrack.isStopped,\n      muted = localMediaTrack.mediaStreamTrack.muted;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(function (error) {\n          log.error('failed to restart track: ', error);\n        });\n      }\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    }).catch(function (ex) {\n      log.error(\"error in maybeRestart: \" + ex.message);\n    });\n  }\n  function onMute() {\n    var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  }\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  var onVisibilityChange = function (isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\nmodule.exports = mixinLocalMediaTrack;","map":{"version":3,"mappings":"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","names":["require","capitalize","defer","isUserMediaTrack","waitForSometime","waitForEvent","detectSilentAudio","detectSilentVideo","documentVisibilityMonitor","localMediaRestartDeferreds","gUMSilentTrackWorkaround","MediaTrackSender","mixinLocalMediaTrack","AudioOrVideoTrack","__extends","mediaStreamTrack","options","workaroundWebKitBug1208516","isIOS","document","addEventListener","visibilityState","Object","assign","getUserMedia","isCreatedByCreateLocalTracks","mediaTrackSender","_this","defineProperties","_constraints","value","kind","writable","_getUserMedia","_gUMSilentTrackWorkaround","_eventsToReemitters","Map","emit","_workaroundWebKitBug1208516","_workaroundWebKitBug1208516Cleanup","_didCallEnd","_isCreatedByCreateLocalTracks","_trackSender","id","enumerable","isEnabled","get","enabled","isMuted","muted","isStopped","readyState","restartWhenInadvertentlyStopped","_reemitTrackSenderEvents","LocalMediaTrack","_super","_end","call","forEach","reemitter","event","removeListener","_initialize","constraints","log","info","debug","gUMConstraints","audio","video","_a","gUMPromise","then","mediaStream","getTracks","on","dequeue","_stop","_reacquireTrack","catch","error","newMediaStreamTrack","_setMediaStreamTrack","_unprocessedTrack","Promise","resolve","setMediaStreamTrack","_log","warn","_getAllAttachedElements","_attach","el","stop","enable","reject","ILLEGAL_INVOKE","promise","_restart","finally","localMediaTrack","detectSilence","trackChangeInProgress","checkSilence","play","isSilent","pause","shouldReacquireTrack","isInadvertentlyStopped","maybeRestart","race","shouldReacquire","_dummyEl","removeMediaStreamTrackListeners","addMediaStreamTrackListeners","resolveDeferred","ex","message","onMute","startDeferred","removeEventListener","onVisibilityChange","isVisible","offVisibilityChange","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/media/track/localmediatrack.js"],"sourcesContent":["/* eslint new-cap:0 */\n'use strict';\n\nconst { getUserMedia } = require('../../webrtc');\nconst { isIOS } = require('../../util/browserdetection');\n\nconst { capitalize, defer, isUserMediaTrack, waitForSometime, waitForEvent } = require('../../util');\nconst { typeErrors: { ILLEGAL_INVOKE } } = require('../../util/constants');\nconst detectSilentAudio = require('../../util/detectsilentaudio');\nconst detectSilentVideo = require('../../util/detectsilentvideo');\nconst documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nconst MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#muted\n   * @emits LocalMediaTrack#stopped\n   * @emits LocalMediaTrack#unmuted\n   */\n  return class LocalMediaTrack extends AudioOrVideoTrack {\n    /**\n     * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    constructor(mediaStreamTrack, options) {\n      const workaroundWebKitBug1208516 = isIOS()\n        && isUserMediaTrack(mediaStreamTrack)\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string';\n\n      options = Object.assign({\n        getUserMedia,\n        isCreatedByCreateLocalTracks: false,\n        workaroundWebKitBug1208516,\n        gUMSilentTrackWorkaround\n      }, options);\n\n      const mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n      const { kind } = mediaTrackSender;\n\n      super(mediaTrackSender, options);\n\n      Object.defineProperties(this, {\n        _constraints: {\n          value: typeof options[kind] === 'object'\n            ? options[kind]\n            : {},\n          writable: true\n        },\n        _getUserMedia: {\n          value: options.getUserMedia\n        },\n        _gUMSilentTrackWorkaround: {\n          value: options.gUMSilentTrackWorkaround\n        },\n        _eventsToReemitters: {\n          value: new Map([\n            ['muted', () => this.emit('muted', this)],\n            ['unmuted', () => this.emit('unmuted', this)]\n          ])\n        },\n        _workaroundWebKitBug1208516: {\n          value: options.workaroundWebKitBug1208516\n        },\n        _workaroundWebKitBug1208516Cleanup: {\n          value: null,\n          writable: true\n        },\n        _didCallEnd: {\n          value: false,\n          writable: true\n        },\n        _isCreatedByCreateLocalTracks: {\n          value: options.isCreatedByCreateLocalTracks\n        },\n        _trackSender: {\n          value: mediaTrackSender\n        },\n        id: {\n          enumerable: true,\n          value: mediaTrackSender.id\n        },\n        isEnabled: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.enabled;\n          }\n        },\n        isMuted: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.muted;\n          }\n        },\n        isStopped: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.readyState === 'ended';\n          }\n        }\n      });\n\n      // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n      // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n      if (this._workaroundWebKitBug1208516) {\n        this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n      }\n\n      this._reemitTrackSenderEvents();\n    }\n\n    /**\n     * @private\n     */\n    _end() {\n      if (this._didCallEnd) {\n        return;\n      }\n      super._end.call(this);\n      this._didCallEnd = true;\n      this._eventsToReemitters.forEach((reemitter, event) => this._trackSender.removeListener(event, reemitter));\n      this.emit('stopped', this);\n    }\n\n    /**\n     * @private\n     */\n    _initialize() {\n      if (this._didCallEnd) {\n        this._didCallEnd = false;\n      }\n      if (this._eventsToReemitters) {\n        this._reemitTrackSenderEvents();\n      }\n      super._initialize.call(this);\n    }\n\n    /**\n     * @private\n     */\n    _reacquireTrack(constraints) {\n      const {\n        _getUserMedia: getUserMedia,\n        _gUMSilentTrackWorkaround: gUMSilentTrackWorkaround,\n        _log: log,\n        mediaStreamTrack: { kind }\n      } = this;\n\n      log.info('Re-acquiring the MediaStreamTrack');\n      log.debug('Constraints:', constraints);\n\n      const gUMConstraints = Object.assign({\n        audio: false,\n        video: false\n      }, { [kind]: constraints });\n\n      const gUMPromise = this._workaroundWebKitBug1208516Cleanup\n        ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)\n        : getUserMedia(gUMConstraints);\n\n      return gUMPromise.then(mediaStream => {\n        return mediaStream.getTracks()[0];\n      });\n    }\n\n    /**\n     * @private\n     */\n    _reemitTrackSenderEvents() {\n      this._eventsToReemitters.forEach((reemitter, event) => this._trackSender.on(event, reemitter));\n      this._trackSender.dequeue('muted');\n      this._trackSender.dequeue('unmuted');\n    }\n\n    /**\n     * @private\n     */\n    _restart(constraints) {\n      const { _log: log } = this;\n      constraints = constraints || this._constraints;\n\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised in case of\n      // video, or the restarted audio will still be silent. Hence, we stop the\n      // MediaStreamTrack here.\n      this._stop();\n\n      return this._reacquireTrack(constraints).catch(error => {\n        log.error('Failed to re-acquire the MediaStreamTrack:', { error, constraints });\n        throw error;\n      }).then(newMediaStreamTrack => {\n        log.info('Re-acquired the MediaStreamTrack');\n        log.debug('MediaStreamTrack:', newMediaStreamTrack);\n        this._constraints = Object.assign({}, constraints);\n        return this._setMediaStreamTrack(newMediaStreamTrack);\n      });\n    }\n\n    /**\n     * @private\n     */\n    _setMediaStreamTrack(mediaStreamTrack) {\n      // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n      mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n\n      // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n      // stopped, this should fire a \"stopped\" event.\n      this._stop();\n\n      // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n      // the processedTrack already set, we don't want to replace that.\n      return (this._unprocessedTrack ? Promise.resolve().then(() => {\n        this._unprocessedTrack = mediaStreamTrack;\n      }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(error => {\n        this._log.warn('setMediaStreamTrack failed:', { error, mediaStreamTrack });\n      })).then(() => {\n        this._initialize();\n        this._getAllAttachedElements().forEach(el => this._attach(el));\n      });\n    }\n\n    /**\n     * @private\n     */\n    _stop() {\n      this.mediaStreamTrack.stop();\n      this._end();\n      return this;\n    }\n\n    enable(enabled) {\n      enabled = typeof enabled === 'boolean' ? enabled : true;\n      if (enabled !== this.mediaStreamTrack.enabled) {\n        this._log.info(`${enabled ? 'En' : 'Dis'}abling`);\n        this.mediaStreamTrack.enabled = enabled;\n        this.emit(enabled ? 'enabled' : 'disabled', this);\n      }\n      return this;\n    }\n\n    disable() {\n      return this.enable(false);\n    }\n\n    restart(constraints) {\n      const { kind } = this;\n      if (!this._isCreatedByCreateLocalTracks) {\n        return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'\n          + ` Local${capitalize(kind)}Track that is created using createLocalTracks`\n          + ` or createLocal${capitalize(kind)}Track.`));\n      }\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      let promise = this._restart(constraints);\n\n      if (this._workaroundWebKitBug1208516) {\n        promise = promise.finally(() => {\n          this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n        });\n      }\n      return promise;\n    }\n\n    stop() {\n      this._log.info('Stopping');\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      return this._stop();\n    }\n  };\n}\n\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  const { _log: log, kind } = localMediaTrack;\n  const detectSilence = { audio: detectSilentAudio, video: detectSilentVideo }[kind];\n\n  let { _dummyEl: el, mediaStreamTrack } = localMediaTrack;\n  let trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(() => detectSilence(el)).then(isSilent => {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(error => {\n      log.warn('Failed to detect silence:', error);\n    }).finally(() => {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n\n  function shouldReacquireTrack() {\n    const {\n      _workaroundWebKitBug1208516Cleanup,\n      isStopped,\n      mediaStreamTrack: { muted }\n    } = localMediaTrack;\n\n    const isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(() => {\n      return document.visibilityState === 'visible'\n        && !trackChangeInProgress\n        && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([\n      waitForEvent(mediaStreamTrack, 'unmute'),\n      waitForSometime(50)\n    ]).then(() => shouldReacquireTrack()).then(shouldReacquire => {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(() => {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(error => {\n          log.error('failed to restart track: ', error);\n        });\n      }\n\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      const promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();\n      return promise.finally(() => localMediaRestartDeferreds.resolveDeferred(kind));\n    }).catch(ex => {\n      log.error(`error in maybeRestart: ${ex.message}`);\n    });\n  }\n\n  function onMute() {\n    const { _log: log, kind } = localMediaTrack;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  }\n\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  let onVisibilityChange = isVisible => {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n\n  return () => {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}