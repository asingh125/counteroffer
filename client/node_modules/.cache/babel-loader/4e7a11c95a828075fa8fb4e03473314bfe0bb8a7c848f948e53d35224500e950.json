{"ast":null,"code":"'use strict';\n\nvar detectSilence = require('./detectsilence');\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0;\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n  var AudioContextFactory = require('./audiocontext');\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n        log.warn(\"Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #\" + ++retry + \".\");\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\nmodule.exports = workaround;","map":{"version":3,"mappings":"AAAA,YAAY;;AAEZ,IAAMA,aAAa,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAEhD;;;;;;;;;;;;;;;;;;;;AAoBA,SAASC,UAAU,CAACC,GAAG,EAAEC,YAAY,EAAEC,WAAW,EAAEC,CAAC,EAAEC,OAAO;EAC5DD,CAAC,GAAG,OAAOA,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAG,CAAC;EACjC,IAAIE,KAAK,GAAG,CAAC;EAEb;EACA;EACA,IAAMC,mBAAmB,GAAGR,OAAO,CAAC,gBAAgB,CAAC;EACrD,IAAMS,MAAM,GAAG,EAAE;EACjB,IAAMC,YAAY,GAAGF,mBAAmB,CAACG,WAAW,CAACF,MAAM,CAAC;EAE5D;;;;EAIA,SAASG,YAAY;IACnB,OAAOT,YAAY,CAACC,WAAW,CAAC,CAACS,IAAI,CAAC,gBAAM;MAC1C,IAAMC,eAAe,GAAGV,WAAW,CAACW,KAAK,GACrChB,aAAa,CAACW,YAAY,EAAEM,MAAM,EAAEV,OAAO,CAAC,CAACW,KAAK,CAAC,aAAG;QACtDf,GAAG,CAACgB,IAAI,CAAC,8CAA8C,EAAEC,GAAG,CAAC;QAC7D,OAAO,IAAI;MACb,CAAC,CAAC,GACAC,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;MAC1B,OAAOP,eAAe,CAACD,IAAI,CAAC,kBAAQ;QAClC,IAAI,CAACS,QAAQ,EAAE;UACbpB,GAAG,CAACqB,IAAI,CAAC,wDAAwD,CAAC;UAClE,OAAOP,MAAM;SACd,MAAM,IAAIX,CAAC,IAAI,CAAC,EAAE;UACjBH,GAAG,CAACgB,IAAI,CAAC;sEACmD,CAAC;UAC7D,OAAOF,MAAM;;QAEfd,GAAG,CAACgB,IAAI,CAAC,wHAEd,EAAEX,KAAK,MAAG,CAAC;QACNS,MAAM,CAACQ,SAAS,EAAE,CAACC,OAAO,CAAC,eAAK;UAAI,YAAK,CAACC,IAAI,EAAE;QAAZ,CAAY,CAAC;QACjDrB,CAAC,EAAE;QACH,OAAOO,YAAY,EAAE;MACvB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA,OAAOA,YAAY,EAAE,CAACC,IAAI,CAAC,gBAAM;IAC/BL,mBAAmB,CAACmB,OAAO,CAAClB,MAAM,CAAC;IACnC,OAAOO,MAAM;EACf,CAAC,EAAE,eAAK;IACNR,mBAAmB,CAACmB,OAAO,CAAClB,MAAM,CAAC;IACnC,MAAMmB,KAAK;EACb,CAAC,CAAC;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAG7B,UAAU","names":["detectSilence","require","workaround","log","getUserMedia","constraints","n","timeout","retry","AudioContextFactory","holder","audioContext","getOrCreate","doWorkaround","then","isSilentPromise","audio","stream","catch","warn","err","Promise","resolve","isSilent","info","getTracks","forEach","stop","release","error","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/webaudio/workaround180748.js"],"sourcesContent":["'use strict';\n\nconst detectSilence = require('./detectsilence');\n\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  let retry = 0;\n\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n  const AudioContextFactory = require('./audiocontext');\n  const holder = {};\n  const audioContext = AudioContextFactory.getOrCreate(holder);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n  function doWorkaround() {\n    return getUserMedia(constraints).then(stream => {\n      const isSilentPromise = constraints.audio\n        ? detectSilence(audioContext, stream, timeout).catch(err => {\n          log.warn('Encountered an error while detecting silence', err);\n          return true;\n        })\n        : Promise.resolve(false);\n      return isSilentPromise.then(isSilent => {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n        log.warn(`Got a silent audio MediaStreamTrack. Stopping all \\\nMediaStreamTracks and calling getUserMedia again. This is retry \\\n#${++retry}.`);\n        stream.getTracks().forEach(track => track.stop());\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(stream => {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, error => {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}