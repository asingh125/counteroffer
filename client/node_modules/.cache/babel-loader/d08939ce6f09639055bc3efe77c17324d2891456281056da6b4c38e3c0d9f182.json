{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar MediaStream = require('../../webrtc').MediaStream;\nvar _a = require('../../util'),\n  waitForEvent = _a.waitForEvent,\n  waitForSometime = _a.waitForSometime;\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar Track = require('./');\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\nvar MediaTrack = /** @class */function (_super) {\n  __extends(MediaTrack, _super);\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  function MediaTrack(mediaTrackTransceiver, options) {\n    var _this = this;\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: isIOS() && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string'\n    }, options);\n    _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;\n    var isStarted = false;\n    options = Object.assign({\n      MediaStream: MediaStream\n    }, options);\n    /* istanbul ignore next */\n    Object.defineProperties(_this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get: function () {\n          return isStarted;\n        },\n        set: function (_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780 || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      isStarted: {\n        enumerable: true,\n        get: function () {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get: function () {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n    _this._initialize();\n    return _this;\n  }\n  /**\n   * @private\n   */\n  MediaTrack.prototype._start = function () {\n    this._log.debug('Started');\n    this._isStarted = true;\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    }\n    // eslint-disable-next-line no-use-before-define\n    this.emit('started', this);\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._initialize = function () {\n    var self = this;\n    this._log.debug('Initializing');\n    this._dummyEl = this._createElement();\n    this.mediaStreamTrack.addEventListener('ended', function onended() {\n      self._end();\n      self.mediaStreamTrack.removeEventListener('ended', onended);\n    });\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);\n      // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n      this._attachments.delete(this._dummyEl);\n    }\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._end = function () {\n    this._log.debug('Ended');\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n      this._dummyEl.srcObject = null;\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  };\n  MediaTrack.prototype.attach = function (el) {\n    var _this = this;\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n    this._log.debug('Attempting to attach to element:', el);\n    el = this._attach(el);\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded ? function () {\n        return playIfPausedAndNotBackgrounded(el, _this._log);\n      } : null;\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n    return el;\n  };\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n  MediaTrack.prototype._attach = function (el, mediaStreamTrack) {\n    if (mediaStreamTrack === void 0) {\n      mediaStreamTrack = this.processedTrack || this.mediaStreamTrack;\n    }\n    var mediaStream = el.srcObject;\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n    var getTracks = mediaStreamTrack.kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';\n    mediaStream[getTracks]().forEach(function (track) {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack);\n    // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    //\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n    return el;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._selectElement = function (selector) {\n    var el = document.querySelector(selector);\n    if (!el) {\n      throw new Error(\"Selector matched no element: \" + selector);\n    }\n    return el;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._updateElementsMediaStreamTrack = function () {\n    var _this = this;\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n    this._getAllAttachedElements().forEach(function (el) {\n      return _this._attach(el);\n    });\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._createElement = function () {\n    return typeof document !== 'undefined' ? document.createElement(this.kind) : null;\n  };\n  MediaTrack.prototype.detach = function (el) {\n    var els;\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n    this._log.debug('Attempting to detach from elements:', els);\n    this._detachElements(els);\n    return el ? els[0] : els;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._detachElements = function (elements) {\n    return elements.map(this._detachElement.bind(this));\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._detachElement = function (el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n    var mediaStream = el.srcObject;\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n    this._attachments.delete(el);\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      var shim = this._elShims.get(el);\n      shim.unShim();\n      this._elShims.delete(el);\n    }\n    return el;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._getAllAttachedElements = function () {\n    var els = [];\n    this._attachments.forEach(function (el) {\n      els.push(el);\n    });\n    return els;\n  };\n  return MediaTrack;\n}(Track);\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  var tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el);\n  // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n  Promise.race([waitForEvent(document, 'visibilitychange'), waitForSometime(1000)]).then(function () {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(function () {\n        log.info(\"Playing unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n        return el.play();\n      }).then(function () {\n        log.info(\"Successfully played unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n      }).catch(function (error) {\n        log.warn(\"Error while playing unintentionally paused <\" + tag + \"> element:\", {\n          error: error,\n          el: el\n        });\n      });\n    }\n  });\n}\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\nfunction shimMediaElement(el, onUnintentionallyPaused) {\n  if (onUnintentionallyPaused === void 0) {\n    onUnintentionallyPaused = null;\n  }\n  var origPause = el.pause;\n  var origPlay = el.play;\n  var pausedIntentionally = false;\n  el.pause = function () {\n    pausedIntentionally = true;\n    return origPause.call(el);\n  };\n  el.play = function () {\n    pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n  var onPause = onUnintentionallyPaused ? function () {\n    if (!pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n  return {\n    pausedIntentionally: function () {\n      return pausedIntentionally;\n    },\n    unShim: function () {\n      el.pause = origPause;\n      el.play = origPlay;\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\nmodule.exports = MediaTrack;","map":{"version":3,"mappings":"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","names":["require","waitForEvent","waitForSometime","localMediaRestartDeferreds","Track","__extends","mediaTrackTransceiver","options","Object","assign","playPausedElementsIfNotBackgrounded","isIOS","document","addEventListener","visibilityState","_this","id","kind","isStarted","MediaStream","defineProperties","_attachments","value","Set","_dummyEl","writable","_elShims","WeakMap","_isStarted","get","set","_playPausedElementsIfNotBackgrounded","_shouldShimAttachedElements","workaroundWebKitBug212780","_unprocessedTrack","_MediaStream","enumerable","mediaStreamTrack","track","processedTrack","_initialize","MediaTrack","_log","debug","oncanplay","emit","self","_createElement","onended","_end","removeEventListener","muted","_start","bind","_attach","delete","remove","srcObject","el","_selectElement","has","onUnintentionallyPaused","shimMediaElement","mediaStream","getTracks","forEach","removeTrack","addTrack","autoplay","playsInline","add","selector","querySelector","Error","_getAllAttachedElements","createElement","els","_detachElements","elements","map","_detachElement","shim","unShim","push","playIfPausedAndNotBackgrounded","log","tag","tagName","toLowerCase","warn","Promise","race","then","whenResolved","info","play","catch","error","origPause","pause","origPlay","pausedIntentionally","call","onPause","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/media/track/mediatrack.js"],"sourcesContent":["'use strict';\n\nconst { isIOS } = require('../../util/browserdetection');\nconst { MediaStream } = require('../../webrtc');\n\nconst { waitForEvent, waitForSometime } = require('../../util');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst Track = require('./');\n\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\nclass MediaTrack extends Track {\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  constructor(mediaTrackTransceiver, options) {\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: isIOS()\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string'\n    }, options);\n\n    super(mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options);\n    let isStarted = false;\n\n    options = Object.assign({\n      MediaStream\n    }, options);\n\n    /* istanbul ignore next */\n    Object.defineProperties(this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get() {\n          return isStarted;\n        },\n        set(_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780\n          || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      isStarted: {\n        enumerable: true,\n        get() {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get() {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    this._initialize();\n  }\n\n  /**\n   * @private\n   */\n  _start() {\n    this._log.debug('Started');\n    this._isStarted = true;\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    }\n    // eslint-disable-next-line no-use-before-define\n    this.emit('started', this);\n  }\n\n  /**\n   * @private\n   */\n  _initialize() {\n    const self = this;\n\n    this._log.debug('Initializing');\n    this._dummyEl = this._createElement();\n\n    this.mediaStreamTrack.addEventListener('ended', function onended() {\n      self._end();\n      self.mediaStreamTrack.removeEventListener('ended', onended);\n    });\n\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);\n\n      // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n\n      this._attachments.delete(this._dummyEl);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _end() {\n    this._log.debug('Ended');\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n      this._dummyEl.srcObject = null;\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  }\n\n  attach(el) {\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n    this._log.debug('Attempting to attach to element:', el);\n    el = this._attach(el);\n\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      const onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded\n        ? () => playIfPausedAndNotBackgrounded(el, this._log)\n        : null;\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n    return el;\n  }\n\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n  _attach(el, mediaStreamTrack = this.processedTrack || this.mediaStreamTrack) {\n    let mediaStream = el.srcObject;\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n\n    const getTracks = mediaStreamTrack.kind === 'audio'\n      ? 'getAudioTracks'\n      : 'getVideoTracks';\n\n    mediaStream[getTracks]().forEach(track => {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack);\n\n    // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    //\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _selectElement(selector) {\n    const el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error(`Selector matched no element: ${selector}`);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _updateElementsMediaStreamTrack() {\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n    this._getAllAttachedElements().forEach(el => this._attach(el));\n  }\n\n  /**\n   * @private\n   */\n  _createElement() {\n    return typeof document !== 'undefined'\n      ? document.createElement(this.kind)\n      : null;\n  }\n\n  detach(el) {\n    let els;\n\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n\n    this._log.debug('Attempting to detach from elements:', els);\n    this._detachElements(els);\n    return el ? els[0] : els;\n  }\n\n  /**\n   * @private\n   */\n  _detachElements(elements) {\n    return elements.map(this._detachElement.bind(this));\n  }\n\n  /**\n   * @private\n   */\n  _detachElement(el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n    const mediaStream = el.srcObject;\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n    this._attachments.delete(el);\n\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      const shim = this._elShims.get(el);\n      shim.unShim();\n      this._elShims.delete(el);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _getAllAttachedElements() {\n    const els = [];\n\n    this._attachments.forEach(el => {\n      els.push(el);\n    });\n\n    return els;\n  }\n}\n\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  const tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el);\n\n  // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n  Promise.race([\n    waitForEvent(document, 'visibilitychange'),\n    waitForSometime(1000)\n  ]).then(() => {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(() => {\n        log.info(`Playing unintentionally paused <${tag}> element`);\n        log.debug('Element:', el);\n        return el.play();\n      }).then(() => {\n        log.info(`Successfully played unintentionally paused <${tag}> element`);\n        log.debug('Element:', el);\n      }).catch(error => {\n        log.warn(`Error while playing unintentionally paused <${tag}> element:`, { error, el });\n      });\n    }\n  });\n}\n\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\nfunction shimMediaElement(el, onUnintentionallyPaused = null) {\n  const origPause = el.pause;\n  const origPlay = el.play;\n\n  let pausedIntentionally = false;\n\n  el.pause = () => {\n    pausedIntentionally = true;\n    return origPause.call(el);\n  };\n\n  el.play = () => {\n    pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n\n  const onPause = onUnintentionallyPaused ? () => {\n    if (!pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n\n  return {\n    pausedIntentionally() {\n      return pausedIntentionally;\n    },\n    unShim() {\n      el.pause = origPause;\n      el.play = origPlay;\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\n\nmodule.exports = MediaTrack;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}