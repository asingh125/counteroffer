{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar DefaultBackoff = require('../../util/backoff');\nvar _a = require('../../webrtc'),\n  DefaultRTCIceCandidate = _a.RTCIceCandidate,\n  DefaultRTCPeerConnection = _a.RTCPeerConnection,\n  DefaultRTCSessionDescription = _a.RTCSessionDescription,\n  getStatistics = _a.getStats;\nvar util = require('../../webrtc/util');\nvar _b = require('../../util/constants'),\n  DEFAULT_ICE_GATHERING_TIMEOUT_MS = _b.DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n  DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL,\n  DEFAULT_SESSION_TIMEOUT_SEC = _b.DEFAULT_SESSION_TIMEOUT_SEC,\n  iceRestartBackoffConfig = _b.iceRestartBackoffConfig;\nvar _c = require('../../util/sdp'),\n  addOrRewriteNewTrackIds = _c.addOrRewriteNewTrackIds,\n  addOrRewriteTrackIds = _c.addOrRewriteTrackIds,\n  createCodecMapForMediaSection = _c.createCodecMapForMediaSection,\n  disableRtx = _c.disableRtx,\n  enableDtxForOpus = _c.enableDtxForOpus,\n  filterLocalCodecs = _c.filterLocalCodecs,\n  getMediaSections = _c.getMediaSections,\n  removeSSRCAttributes = _c.removeSSRCAttributes,\n  revertSimulcast = _c.revertSimulcast,\n  setCodecPreferences = _c.setCodecPreferences,\n  setSimulcast = _c.setSimulcast;\nvar DefaultTimeout = require('../../util/timeout');\nvar _d = require('../../util/twilio-video-errors'),\n  MediaClientLocalDescFailedError = _d.MediaClientLocalDescFailedError,\n  MediaClientRemoteDescFailedError = _d.MediaClientRemoteDescFailedError;\nvar _e = require('../../util'),\n  buildLogLevels = _e.buildLogLevels,\n  getPlatform = _e.getPlatform,\n  isChromeScreenShareTrack = _e.isChromeScreenShareTrack,\n  oncePerTick = _e.oncePerTick,\n  defer = _e.defer;\nvar IceBox = require('./icebox');\nvar DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\nvar DataTrackReceiver = require('../../data/receiver');\nvar MediaTrackReceiver = require('../../media/track/receiver');\nvar StateMachine = require('../../statemachine');\nvar Log = require('../../util/log');\nvar TrackMatcher = require('../../util/sdp/trackmatcher');\nvar workaroundIssue8329 = require('../../util/sdp/issue8329');\nvar guess = util.guessBrowser();\nvar platform = getPlatform();\nvar isAndroid = /android/.test(platform);\nvar isChrome = guess === 'chrome';\nvar isFirefox = guess === 'firefox';\nvar isSafari = guess === 'safari';\nvar nInstances = 0;\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\nvar states = {\n  open: ['closed', 'updating'],\n  updating: ['closed', 'open'],\n  closed: []\n};\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\nvar PeerConnectionV2 = /** @class */function (_super) {\n  __extends(PeerConnectionV2, _super);\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n  function PeerConnectionV2(id, encodingParameters, preferredCodecs, options) {\n    var _this = _super.call(this, 'open', states) || this;\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack: isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast: revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences: setCodecPreferences,\n      setSimulcast: setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n    var configuration = getConfiguration(options);\n    var logLevels = buildLogLevels(options.logLevel);\n    var RTCPeerConnection = options.RTCPeerConnection;\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({\n        googDscp: true\n      });\n    }\n    var log = options.log ? options.log.createLog('webrtc', _this) : new Log('webrtc', _this, logLevels, options.loggerName);\n    var peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n    Object.defineProperties(_this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(function () {\n          return _this._handleIceGatheringTimeout();\n        }, DEFAULT_ICE_GATHERING_TIMEOUT_MS, false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(function () {\n          if (!_this._needsAnswer) {\n            updateEncodingParameters(_this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(function (_a) {\n          var codec = _a.codec;\n          return codec !== 'opus';\n        }) || preferredCodecs.audio.some(function (_a) {\n          var codec = _a.codec,\n            dtx = _a.dtx;\n          return codec === 'opus' && dtx;\n        })\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(function () {\n          log.debug('ICE reconnect timed out');\n          _this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264' ? function (sdp) {\n          return sdp;\n        } : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n    encodingParameters.on('changed', _this._onEncodingParametersChanged);\n    peerConnection.addEventListener('connectionstatechange', _this._handleConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('datachannel', _this._handleDataChannelEvent.bind(_this));\n    peerConnection.addEventListener('icecandidate', _this._handleIceCandidateEvent.bind(_this));\n    peerConnection.addEventListener('iceconnectionstatechange', _this._handleIceConnectionStateChange.bind(_this));\n    peerConnection.addEventListener('icegatheringstatechange', _this._handleIceGatheringStateChange.bind(_this));\n    peerConnection.addEventListener('signalingstatechange', _this._handleSignalingStateChange.bind(_this));\n    peerConnection.addEventListener('track', _this._handleTrackEvent.bind(_this));\n    var self = _this;\n    _this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n      self.removeListener('stateChanged', stateChanged);\n      self._dataChannels.forEach(function (dataChannel, dataTrackSender) {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n    return _this;\n  }\n  PeerConnectionV2.prototype.toString = function () {\n    return \"[PeerConnectionV2 #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n  PeerConnectionV2.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast);\n    // clear adaptive simulcast from codec preferences if it was set.\n    this._preferredVideoCodecs.forEach(function (cs) {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  };\n  Object.defineProperty(PeerConnectionV2.prototype, \"_shouldApplySimulcast\", {\n    get: function () {\n      if (!isChrome && !isSafari) {\n        return false;\n      }\n      // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n      var simulcast = this._preferredVideoCodecs.some(function (cs) {\n        return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n      });\n      return simulcast;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"connectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n     * if supported by the browser, its RTCIceConnectionState otherwise.\n     * @property {RTCPeerConnectionState}\n     */\n    get: function () {\n      return this.iceConnectionState === 'failed' ? 'failed' : this._peerConnection.connectionState || this.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"iceConnectionState\", {\n    /**\n     * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n     * RTCIceConnectionState.\n     * @property {RTCIceConnectionState}\n     */\n    get: function () {\n      return this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected' || this._iceGatheringFailed ? 'failed' : this._peerConnection.iceConnectionState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"isApplicationSectionNegotiated\", {\n    /**\n     * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n     * of negotiating the application m= section.\n     * @returns {boolean}\n     */\n    get: function () {\n      if (this._peerConnection.signalingState !== 'closed') {\n        // accessing .localDescription in 'closed' state causes it throw exceptions.\n        return this._peerConnection.localDescription ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0 : false;\n      }\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PeerConnectionV2.prototype, \"_isAdaptiveSimulcastEnabled\", {\n    /**\n     * Whether adaptive simulcast is enabled.\n     * @returns {boolean}\n     */\n    get: function () {\n      var adaptiveSimulcastEntry = this._preferredVideoCodecs.find(function (cs) {\n        return 'adaptiveSimulcast' in cs;\n      });\n      return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n  PeerConnectionV2.prototype._maybeUpdateEncodings = function (track, encodings, trackReplaced) {\n    if (trackReplaced === void 0) {\n      trackReplaced = false;\n    }\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n    // NOTE(mmalavalli): There is no guarantee that CanvasCaptureMediaStreamTracks will always have \"width\" and \"height\"\n    // in their settings. So, we don't update the encodings if they are not present.\n    // Chromium bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1367082\n    var _a = track.getSettings(),\n      height = _a.height,\n      width = _a.width;\n    if (typeof height !== 'number' || typeof width !== 'number') {\n      return false;\n    }\n    // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n    var browser = util.guessBrowser();\n    if (browser === 'safari' || browser === 'chrome' && this._isAdaptiveSimulcastEnabled) {\n      this._updateEncodings(track, encodings, trackReplaced);\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n  PeerConnectionV2.prototype._updateEncodings = function (track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      var screenShareActiveLayerConfig_1 = [{\n        scaleResolutionDownBy: 1\n      }, {\n        scaleResolutionDownBy: 1\n      }];\n      encodings.forEach(function (encoding, i) {\n        var activeLayerConfig = screenShareActiveLayerConfig_1[i];\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      var _a = track.getSettings(),\n        width = _a.width,\n        height = _a.height;\n      // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n      var pixelsToMaxActiveLayers = [{\n        pixels: 960 * 540,\n        maxActiveLayers: 3\n      }, {\n        pixels: 480 * 270,\n        maxActiveLayers: 2\n      }, {\n        pixels: 0,\n        maxActiveLayers: 1\n      }];\n      var trackPixels_1 = width * height;\n      var activeLayersInfo = pixelsToMaxActiveLayers.find(function (layer) {\n        return trackPixels_1 >= layer.pixels;\n      });\n      var activeLayers_1 = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach(function (encoding, i) {\n        var enabled = i < activeLayers_1;\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << activeLayers_1 - i - 1;\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n    this._log.debug('_updateEncodings:', encodings.map(function (_a, i) {\n      var active = _a.active,\n        scaleResolutionDownBy = _a.scaleResolutionDownBy;\n      return \"[\" + i + \": \" + active + \", \" + (scaleResolutionDownBy || 0) + \"]\";\n    }).join(', '));\n  };\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._addIceCandidate = function (candidate) {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      candidate = new _this._RTCIceCandidate(candidate);\n      return _this._peerConnection.addIceCandidate(candidate);\n    }).catch(function (error) {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      _this._log.warn(\"Failed to add RTCIceCandidate \" + (candidate ? \"\\\"\" + candidate.candidate + \"\\\"\" : 'null') + \": \" + error.message);\n    });\n  };\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._addIceCandidates = function (candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(function () {});\n  };\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n  PeerConnectionV2.prototype._addOrUpdateTransceiver = function (track) {\n    var _this = this;\n    var transceiver = takeRecycledTransceiver(this, track.kind);\n    if (transceiver && transceiver.sender) {\n      var oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n      if (oldTrackId) {\n        this._log.warn(\"Reusing transceiver: \" + transceiver.mid + \"] \" + oldTrackId + \" => \" + track.id);\n      }\n      // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(function () {\n        transceiver.direction = 'sendrecv';\n      }, function () {\n        // Do nothing.\n      }).finally(function () {\n        _this._replaceTrackPromises.delete(transceiver);\n      }));\n      return transceiver;\n    }\n    return this._peerConnection.addTransceiver(track);\n  };\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._checkIceBox = function (description) {\n    var ufrag = getUfrag(description);\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n    var candidates = this._remoteCandidates.setUfrag(ufrag);\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n  PeerConnectionV2.prototype._answer = function (offer) {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'answerer';\n      }\n      return _this._setRemoteDescription(offer);\n    }).catch(function () {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(function () {\n      return _this._peerConnection.createAnswer();\n    }).then(function (answer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new _this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      }\n      // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      var updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n      if (_this._shouldApplySimulcast) {\n        var sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = _this._setSimulcast(sdpWithoutSimulcast, _this._trackIdsToAttributes);\n        // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n        updatedSdp = _this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      }\n      // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n      return _this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(function () {\n      return _this._checkIceBox(offer);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription);\n    }).catch(function (error) {\n      var errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n      _this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error: error\n      });\n      throw errorToThrow;\n    });\n  };\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n  PeerConnectionV2.prototype._close = function () {\n    this._iceConnectionMonitor.stop();\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n      this.preempt('closed');\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleConnectionStateChange = function () {\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleDataChannelEvent = function (event) {\n    var _this = this;\n    var dataChannel = event.channel;\n    var dataTrackReceiver = new DataTrackReceiver(dataChannel);\n    this._dataTrackReceivers.add(dataTrackReceiver);\n    dataChannel.addEventListener('close', function () {\n      _this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n    this.emit('trackAdded', dataTrackReceiver);\n  };\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._handleGlare = function (offer) {\n    var _this = this;\n    this._log.debug('Glare detected; rolling back');\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n    return Promise.resolve().then(function () {\n      _this._trackIdsToAttributes = new Map(_this._appliedTrackIdsToAttributes);\n      return _this._setLocalDescription({\n        type: 'rollback'\n      });\n    }).then(function () {\n      _this._needsAnswer = false;\n      return _this._answer(offer);\n    }).then(function (didReoffer) {\n      return didReoffer ? Promise.resolve() : _this._offer();\n    });\n  };\n  PeerConnectionV2.prototype._publishMediaWarning = function (_a) {\n    var message = _a.message,\n      code = _a.code,\n      error = _a.error,\n      sdp = _a.sdp;\n    this._eventObserver.emit('event', {\n      level: 'warning',\n      name: 'error',\n      group: 'media',\n      payload: {\n        message: message,\n        code: code,\n        context: JSON.stringify({\n          error: error.message,\n          sdp: sdp\n        })\n      }\n    });\n  };\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceCandidateEvent = function (event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n      this._didGenerateLocalCandidates = true;\n      this._iceGatheringTimeout.clear();\n      this._localCandidates.push(event.candidate);\n    }\n    var peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  };\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceConnectionStateChange = function () {\n    var _this = this;\n    var iceConnectionState = this._peerConnection.iceConnectionState;\n    var isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    var log = this._log;\n    log.debug(\"ICE connection state is \\\"\" + iceConnectionState + \"\\\"\");\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n      this._iceRestartBackoff.reset();\n    }\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    }\n    // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n      this._iceConnectionMonitor.start(function () {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        _this._iceConnectionMonitor.stop();\n        if (!_this._shouldRestartIce && !_this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          _this._isIceConnectionInactive = true;\n          _this._initiateIceRestartBackoff();\n          _this.emit('iceConnectionStateChanged');\n          _this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) {\n      // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n      this._isIceConnectionInactive = false;\n    }\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  };\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceGatheringTimeout = function () {\n    this._log.warn('ICE failed to gather any local candidates');\n    this._iceGatheringFailed = true;\n    this._initiateIceRestartBackoff();\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  };\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleIceGatheringStateChange = function () {\n    var iceGatheringState = this._peerConnection.iceGatheringState;\n    var log = this._log;\n    log.debug(\"ICE gathering state is \\\"\" + iceGatheringState + \"\\\"\");\n    // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n    var _a = this._iceGatheringTimeout,\n      delay = _a.delay,\n      isSet = _a.isSet;\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(\"Starting ICE gathering timeout: \" + delay);\n      this._iceGatheringFailed = false;\n      this._iceGatheringTimeout.start();\n    }\n  };\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleSignalingStateChange = function () {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  };\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._handleTrackEvent = function (event) {\n    var _this = this;\n    var sdp = this._peerConnection.remoteDescription ? this._peerConnection.remoteDescription.sdp : null;\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n    this._trackMatcher.update(sdp);\n    var mediaStreamTrack = event.track;\n    var signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    var mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack);\n    // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n    this._mediaTrackReceivers.forEach(function (trackReceiver) {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        _this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n    mediaStreamTrack.addEventListener('ended', function () {\n      return _this._mediaTrackReceivers.delete(mediaTrackReceiver);\n    });\n    this.emit('trackAdded', mediaTrackReceiver);\n  };\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._initiateIceRestart = function () {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n    var log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n    var _a = this._iceReconnectTimeout,\n      delay = _a.delay,\n      isSet = _a.isSet;\n    if (!isSet) {\n      log.debug(\"Starting ICE reconnect timeout: \" + delay);\n      this._iceReconnectTimeout.start();\n    }\n    this.offer().catch(function (ex) {\n      log.error(\"offer failed in _initiateIceRestart with: \" + ex.message);\n    });\n  };\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype._initiateIceRestartBackoff = function () {\n    var _this = this;\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n    this._log.warn('An ICE restart has been scheduled');\n    this._isIceRestartBackoffInProgress = true;\n    this._iceRestartBackoff.backoff(function () {\n      return _this._initiateIceRestart();\n    });\n  };\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n  PeerConnectionV2.prototype._maybeReoffer = function (localDescription) {\n    var shouldReoffer = this._shouldOffer;\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      var senders_1 = this._peerConnection.getSenders().filter(function (sender) {\n        return sender.track;\n      });\n      shouldReoffer = ['audio', 'video'].reduce(function (shouldOffer, kind) {\n        var mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        var sendersOfKind = senders_1.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || mediaSections.length < sendersOfKind.length;\n      }, shouldReoffer);\n      // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n      var hasDataTrack = this._dataChannels.size > 0;\n      var hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      var needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n    var promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(function () {\n      return shouldReoffer;\n    });\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._offer = function () {\n    var _this = this;\n    var offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n    return Promise.all(this._replaceTrackPromises.values()).then(function () {\n      return _this._peerConnection.createOffer(offerOptions);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientLocalDescFailedError();\n      _this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error: error\n      });\n      throw errorToThrow;\n    }).then(function (offer) {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new _this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      }\n      // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      var sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = _this._peerConnection.remoteDescription ? filterLocalCodecs(sdp, _this._peerConnection.remoteDescription.sdp) : sdp;\n      var updatedSdp = _this._setCodecPreferences(sdp, _this._preferredAudioCodecs, _this._preferredVideoCodecs);\n      _this._shouldOffer = false;\n      if (!_this._negotiationRole) {\n        _this._negotiationRole = 'offerer';\n      }\n      if (_this._shouldApplySimulcast) {\n        _this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = _this._setSimulcast(updatedSdp, _this._trackIdsToAttributes);\n      }\n      return _this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  };\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n  PeerConnectionV2.prototype._getMediaTrackSenderId = function (trackId) {\n    var mediaTrackSender = Array.from(this._rtpSenders.keys()).find(function (_a) {\n      var id = _a.track.id;\n      return id === trackId;\n    });\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  };\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n  PeerConnectionV2.prototype._addOrRewriteLocalTrackIds = function (description) {\n    var _this = this;\n    var transceivers = this._peerConnection.getTransceivers();\n    var activeTransceivers = transceivers.filter(function (_a) {\n      var sender = _a.sender,\n        stopped = _a.stopped;\n      return !stopped && sender && sender.track;\n    });\n    // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n    var assignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return mid;\n    });\n    var midsToTrackIds = new Map(assignedTransceivers.map(function (_a) {\n      var mid = _a.mid,\n        sender = _a.sender;\n      return [mid, _this._getMediaTrackSenderId(sender.track.id)];\n    }));\n    var sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds);\n    // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n    var unassignedTransceivers = activeTransceivers.filter(function (_a) {\n      var mid = _a.mid;\n      return !mid;\n    });\n    var newTrackIdsByKind = new Map(['audio', 'video'].map(function (kind) {\n      return [kind, unassignedTransceivers.filter(function (_a) {\n        var sender = _a.sender;\n        return sender.track.kind === kind;\n      }).map(function (_a) {\n        var sender = _a.sender;\n        return _this._getMediaTrackSenderId(sender.track.id);\n      })];\n    }));\n    var sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  };\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._rollbackAndApplyOffer = function (offer) {\n    var _this = this;\n    return this._setLocalDescription({\n      type: 'rollback'\n    }).then(function () {\n      return _this._setLocalDescription(offer);\n    });\n  };\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._setLocalDescription = function (description) {\n    var _this = this;\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n    return this._peerConnection.setLocalDescription(description).catch(function (error) {\n      _this._log.warn(\"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n      var errorToThrow = new MediaClientLocalDescFailedError();\n      var publishWarning = {\n        message: \"Calling setLocalDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error\n      };\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n        publishWarning.sdp = description.sdp;\n      }\n      _this._publishMediaWarning(publishWarning);\n      throw errorToThrow;\n    }).then(function () {\n      if (description.type !== 'rollback') {\n        _this._localDescription = _this._addOrRewriteLocalTrackIds(description);\n        // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n        if (_this._shouldApplyDtx) {\n          _this._localDescription = new _this._RTCSessionDescription({\n            sdp: enableDtxForOpus(_this._localDescription.sdp, []),\n            type: _this._localDescription.type\n          });\n        }\n        _this._localCandidates = [];\n        if (description.type === 'offer') {\n          _this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          _this._lastStableDescriptionRevision = _this._descriptionRevision;\n          negotiationCompleted(_this);\n        }\n        _this._localUfrag = getUfrag(description);\n        _this.emit('description', _this.getState());\n      }\n    });\n  };\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._setRemoteDescription = function (description) {\n    var _this = this;\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(description.sdp, this._preferredAudioCodecs, this._preferredVideoCodecs);\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n    description = new this._RTCSessionDescription(description);\n    // eslint-disable-next-line consistent-return\n    return Promise.resolve().then(function () {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && _this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        var adaptiveSimulcastEntry = _this._preferredVideoCodecs.find(function (cs) {\n          return 'adaptiveSimulcast' in cs;\n        });\n        var revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n        var sdpWithoutSimulcastForNonVP8MediaSections = _this._revertSimulcast(_this._localDescription.sdp, _this._localDescriptionWithoutSimulcast.sdp, description.sdp, revertForAll);\n        _this._localDescriptionWithoutSimulcast = null;\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== _this._localDescription.sdp) {\n          return _this._rollbackAndApplyOffer({\n            type: _this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(function () {\n      return _this._peerConnection.setRemoteDescription(description);\n    }).then(function () {\n      if (description.type === 'answer') {\n        if (_this._isRestartingIce) {\n          _this._log.debug('An ICE restart was in-progress and is now completed');\n          _this._isRestartingIce = false;\n        }\n        negotiationCompleted(_this);\n      }\n    }, function (error) {\n      _this._log.warn(\"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed with the error \\\"\" + error.message + \"\\\".\", error);\n      if (description.sdp) {\n        _this._log.warn(\"The SDP was \" + description.sdp);\n      }\n      throw error;\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._updateDescription = function (description) {\n    var _this = this;\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        break;\n      case 'close':\n        return this._close();\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        return this._offer();\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(function () {});\n      default:\n      // Do nothing.\n    }\n    // Handle answer or pranswer.\n    var revision = description.revision;\n    return Promise.resolve().then(function () {\n      return _this._setRemoteDescription(description);\n    }).catch(function (error) {\n      var errorToThrow = new MediaClientRemoteDescFailedError();\n      _this._publishMediaWarning({\n        message: \"Calling setRemoteDescription with an RTCSessionDescription of type \\\"\" + description.type + \"\\\" failed\",\n        code: errorToThrow.code,\n        error: error,\n        sdp: description.sdp\n      });\n      throw errorToThrow;\n    }).then(function () {\n      _this._lastStableDescriptionRevision = revision;\n      _this._needsAnswer = false;\n      return _this._checkIceBox(description);\n    }).then(function () {\n      return _this._queuedDescription && _this._updateDescription(_this._queuedDescription);\n    }).then(function () {\n      _this._queuedDescription = null;\n      return _this._maybeReoffer(_this._peerConnection.localDescription).then(function () {});\n    });\n  };\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype._updateIce = function (iceState) {\n    var candidates = this._remoteCandidates.update(iceState);\n    return this._addIceCandidates(candidates);\n  };\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.addDataTrackSender = function (dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n    try {\n      var dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n      var dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n      dataTrackSender.addDataChannel(dataChannel);\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(\"Error creating an RTCDataChannel for DataTrack \\\"\" + dataTrackSender.id + \"\\\": \" + error.message);\n    }\n  };\n  PeerConnectionV2.prototype._handleQueuedPublisherHints = function () {\n    var _this = this;\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(function (_a, mediaTrackSender) {\n        var deferred = _a.deferred,\n          encodings = _a.encodings;\n        _this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n        _this._setPublisherHint(mediaTrackSender, encodings).then(function (result) {\n          return deferred.resolve(result);\n        }).catch(function (error) {\n          return deferred.reject(error);\n        });\n      });\n    }\n  };\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n  PeerConnectionV2.prototype._setPublisherHint = function (mediaTrackSender, encodings) {\n    var _this = this;\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    var sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n      var deferred = defer();\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, {\n        deferred: deferred,\n        encodings: encodings\n      });\n      return deferred.promise;\n    }\n    var parameters = sender.getParameters();\n    if (encodings !== null) {\n      encodings.forEach(function (_a) {\n        var enabled = _a.enabled,\n          layerIndex = _a.layer_index;\n        if (parameters.encodings.length > layerIndex) {\n          _this._log.debug(\"layer:\" + layerIndex + \", active:\" + parameters.encodings[layerIndex].active + \" => \" + enabled);\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          _this._log.warn(\"invalid layer:\" + layerIndex + \", active:\" + enabled);\n        }\n      });\n    }\n    // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null /* trackReplaced */);\n    return sender.setParameters(parameters).then(function () {\n      return 'OK';\n    }).catch(function (error) {\n      _this._log.error('Failed to apply publisher hints:', error);\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  };\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.addMediaTrackSender = function (mediaTrackSender) {\n    var _this = this;\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n    var transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n    var sender = transceiver.sender;\n    mediaTrackSender.addSender(sender, function (encodings) {\n      return _this._setPublisherHint(mediaTrackSender, encodings);\n    });\n    this._rtpNewSenders.add(sender);\n    this._rtpSenders.set(mediaTrackSender, sender);\n  };\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.close = function () {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = {\n        type: 'close'\n      };\n      this.emit('description', this.getState());\n    }\n  };\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  PeerConnectionV2.prototype.getTrackReceivers = function () {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n  PeerConnectionV2.prototype.getState = function () {\n    if (!this._localDescription) {\n      return null;\n    }\n    // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n    var localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    var localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  };\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype.offer = function () {\n    var _this = this;\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n    return this.bracket('offering', function (key) {\n      _this.transition('updating', key);\n      var promise = _this._needsAnswer || _this._isRestartingIce ? Promise.resolve() : _this._offer();\n      return promise.then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  };\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.removeDataTrackSender = function (dataTrackSender) {\n    var dataChannel = this._dataChannels.get(dataTrackSender);\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n      this._dataChannels.delete(dataTrackSender);\n      dataChannel.close();\n    }\n  };\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.removeMediaTrackSender = function (mediaTrackSender) {\n    var sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      return;\n    }\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n    mediaTrackSender.removeSender(sender);\n    // clean up any pending publisher hints associated with this mediaTrackSender.\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    this._rtpNewSenders.delete(sender);\n    this._rtpSenders.delete(mediaTrackSender);\n  };\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n  PeerConnectionV2.prototype.setConfiguration = function (configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  };\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  PeerConnectionV2.prototype.setIceReconnectTimeout = function (period) {\n    this._iceReconnectTimeout.setDelay(period);\n    this._log.debug('Updated ICE reconnection timeout period:', this._iceReconnectTimeout.delay);\n    return this;\n  };\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n  PeerConnectionV2.prototype.update = function (peerConnectionState) {\n    var _this = this;\n    return this.bracket('updating', function (key) {\n      if (_this.state === 'closed') {\n        return Promise.resolve();\n      }\n      _this.transition('updating', key);\n      var updates = [];\n      if (peerConnectionState.ice) {\n        updates.push(_this._updateIce(peerConnectionState.ice));\n      }\n      if (peerConnectionState.description) {\n        updates.push(_this._updateDescription(peerConnectionState.description));\n      }\n      return Promise.all(updates).then(function () {\n        _this.tryTransition('open', key);\n      }, function (error) {\n        _this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  };\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n  PeerConnectionV2.prototype.getStats = function () {\n    var _this = this;\n    return getStatistics(this._peerConnection).then(function (response) {\n      return rewriteTrackIds(_this, response);\n    });\n  };\n  return PeerConnectionV2;\n}(StateMachine);\nfunction rewriteLocalTrackId(pcv2, stats) {\n  var trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\nfunction rewriteTrackId(pcv2, stats) {\n  var receiver = __spreadArray([], __read(pcv2._mediaTrackReceivers)).find(function (receiver) {\n    return receiver.track.id === stats.trackId;\n  });\n  var trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, {\n    trackId: trackId\n  });\n}\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(function (stats) {\n      return rewriteTrackId(pcv2, stats);\n    }),\n    localAudioTrackStats: response.localAudioTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    }),\n    localVideoTrackStats: response.localVideoTrackStats.map(function (stats) {\n      return rewriteLocalTrackId(pcv2, stats);\n    })\n  });\n}\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\nfunction getUfrag(description) {\n  if (description.sdp) {\n    var match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n    if (match) {\n      return match[1];\n    }\n  }\n  return null;\n}\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\nfunction isSenderOfKind(kind, sender) {\n  var track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped && !pcv2._replaceTrackPromises.has(transceiver) && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\nfunction takeRecycledTransceiver(pcv2, kind) {\n  var preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    }),\n    video: pcv2._preferredVideoCodecs.map(function (_a) {\n      var codec = _a.codec;\n      return codec.toLowerCase();\n    })\n  }[kind];\n  var recycledTransceivers = pcv2._recycledTransceivers[kind];\n  var localCodec = preferredCodecs.find(function (codec) {\n    return pcv2._localCodecs.has(codec);\n  });\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n  var transceiver = recycledTransceivers.find(function (transceiver) {\n    var remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n  return transceiver;\n}\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\nfunction updateLocalCodecs(pcv2) {\n  var description = pcv2._peerConnection.localDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(function (section) {\n    var codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach(function (pts, codec) {\n      return pcv2._localCodecs.add(codec);\n    });\n  });\n}\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateRemoteCodecMaps(pcv2) {\n  var description = pcv2._peerConnection.remoteDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(function (section) {\n    var matched = section.match(/^a=mid:(.+)$/m);\n    if (!matched || !matched[1]) {\n      return;\n    }\n    var mid = matched[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n  pcv2._peerConnection.getTransceivers().forEach(function (transceiver) {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      var track = transceiver.receiver.track;\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(function () {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateEncodingParameters(pcv2) {\n  var _a = pcv2._encodingParameters,\n    maxAudioBitrate = _a.maxAudioBitrate,\n    maxVideoBitrate = _a.maxVideoBitrate;\n  var maxBitrates = new Map([['audio', maxAudioBitrate], ['video', maxVideoBitrate]]);\n  var promises = [];\n  pcv2._peerConnection.getSenders().filter(function (sender) {\n    return sender.track;\n  }).forEach(function (sender) {\n    var maxBitrate = maxBitrates.get(sender.track.kind);\n    var params = sender.getParameters();\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(\"Not setting maxBitrate for \" + sender.track.kind + \" Track \" + sender.track.id + \" because it appears to be screen share track: \" + sender.track.label);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n    if (!isFirefox && params.encodings.length > 0) {\n      if (sender.track.kind === 'audio') {\n        // NOTE(mmalavalli): \"priority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected. With this, audio encoding\n        // is prioritized the most.\n        params.encodings[0].priority = 'high';\n      } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n        // NOTE(mmalavalli): Screen share encodings are prioritized more than those\n        // of the camera.\n        params.encodings[0].priority = 'medium';\n      }\n      if (pcv2._enableDscp) {\n        // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected.\n        params.encodings[0].networkPriority = 'high';\n      }\n    }\n    // when a sender is reused, delete any active encodings set by server.\n    var trackReplaced = pcv2._rtpNewSenders.has(sender);\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n    pcv2._rtpNewSenders.delete(sender);\n    var promise = sender.setParameters(params).catch(function (error) {\n      pcv2._log.warn(\"Error while setting encodings parameters for \" + sender.track.kind + \" Track \" + sender.track.id + \": \" + (error.message || error.name));\n    });\n    promises.push(promise);\n  });\n  return Promise.all(promises);\n}\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(function (encoding) {\n      return delete encoding.maxBitrate;\n    });\n  }\n}\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{\n      maxBitrate: maxBitrate\n    }];\n  } else {\n    params.encodings.forEach(function (encoding) {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\nmodule.exports = PeerConnectionV2;","map":{"version":3,"mappings":"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","names":["DefaultBackoff","require","DefaultRTCIceCandidate","DefaultRTCPeerConnection","DefaultRTCSessionDescription","getStatistics","util","DEFAULT_ICE_GATHERING_TIMEOUT_MS","DEFAULT_LOG_LEVEL","DEFAULT_SESSION_TIMEOUT_SEC","iceRestartBackoffConfig","addOrRewriteNewTrackIds","addOrRewriteTrackIds","createCodecMapForMediaSection","disableRtx","enableDtxForOpus","filterLocalCodecs","getMediaSections","removeSSRCAttributes","revertSimulcast","setCodecPreferences","setSimulcast","DefaultTimeout","MediaClientLocalDescFailedError","MediaClientRemoteDescFailedError","buildLogLevels","getPlatform","isChromeScreenShareTrack","oncePerTick","defer","IceBox","DefaultIceConnectionMonitor","DataTrackReceiver","MediaTrackReceiver","StateMachine","Log","TrackMatcher","workaroundIssue8329","guess","guessBrowser","platform","isAndroid","test","isChrome","isFirefox","isSafari","nInstances","states","open","updating","closed","__extends","id","encodingParameters","preferredCodecs","options","_super","Object","assign","enableDscp","dummyAudioMediaStreamTrack","iceServers","logLevel","offerOptions","sessionTimeout","Backoff","IceConnectionMonitor","RTCIceCandidate","RTCPeerConnection","RTCSessionDescription","Timeout","configuration","getConfiguration","logLevels","chromeSpecificConstraints","optional","push","googDscp","log","createLog","_this","loggerName","peerConnection","addTrack","defineProperties","_appliedTrackIdsToAttributes","value","Map","writable","_dataChannels","_dataTrackReceivers","Set","_descriptionRevision","_didGenerateLocalCandidates","_enableDscp","_encodingParameters","_isChromeScreenShareTrack","_iceGatheringFailed","_iceGatheringTimeout","_handleIceGatheringTimeout","_iceRestartBackoff","_instanceId","_isIceConnectionInactive","_isIceLite","_isIceRestartBackoffInProgress","_isRestartingIce","_lastIceConnectionState","_lastStableDescriptionRevision","_localCandidates","_localCodecs","_localCandidatesRevision","_localDescriptionWithoutSimulcast","_localDescription","_localUfrag","_log","_eventObserver","eventObserver","_remoteCodecMaps","_rtpSenders","_rtpNewSenders","_iceConnectionMonitor","_mediaTrackReceivers","_needsAnswer","_negotiationRole","_offerOptions","_onEncodingParametersChanged","updateEncodingParameters","_peerConnection","_preferredAudioCodecs","audio","_preferredVideoCodecs","video","_shouldApplyDtx","every","_a","codec","some","dtx","_queuedDescription","_iceReconnectTimeout","debug","close","_recycledTransceivers","_replaceTrackPromises","_remoteCandidates","_setCodecPreferences","toLowerCase","_setSimulcast","_revertSimulcast","_RTCIceCandidate","_RTCPeerConnection","_RTCSessionDescription","_shouldOffer","_shouldRestartIce","_trackIdsToAttributes","_trackMatcher","_mediaTrackSenderToPublisherHints","enumerable","on","addEventListener","_handleConnectionStateChange","bind","_handleDataChannelEvent","_handleIceCandidateEvent","_handleIceConnectionStateChange","_handleIceGatheringStateChange","_handleSignalingStateChange","_handleTrackEvent","self","stateChanged","state","removeListener","forEach","dataChannel","dataTrackSender","removeDataTrackSender","PeerConnectionV2","effectiveAdaptiveSimulcast","cs","adaptiveSimulcast","simulcast","iceConnectionState","connectionState","signalingState","localDescription","sdp","length","adaptiveSimulcastEntry","find","track","encodings","trackReplaced","kind","readyState","getSettings","height","width","browser","_isAdaptiveSimulcastEnabled","_updateEncodings","screenShareActiveLayerConfig_1","scaleResolutionDownBy","encoding","i","activeLayerConfig","active","pixelsToMaxActiveLayers","pixels","maxActiveLayers","trackPixels_1","activeLayersInfo","layer","activeLayers_1","Math","min","enabled","map","join","candidate","Promise","resolve","then","addIceCandidate","catch","warn","error","message","candidates","all","_addIceCandidate","transceiver","takeRecycledTransceiver","sender","oldTrackId","mid","set","replaceTrack","direction","finally","delete","addTransceiver","description","ufrag","getUfrag","setUfrag","_addIceCandidates","offer","_setRemoteDescription","createAnswer","answer","type","updatedSdp","_shouldApplySimulcast","sdpWithoutSimulcast","replace","_setLocalDescription","_checkIceBox","_updateDescription","_maybeReoffer","errorToThrow","_publishMediaWarning","code","stop","preempt","emit","event","channel","dataTrackReceiver","add","_answer","didReoffer","_offer","level","name","group","payload","context","JSON","stringify","clear","peerConnectionState","ice","slice","complete","revision","isIceConnectedOrComplete","includes","reset","_initiateIceRestartBackoff","start","iceGatheringState","delay","isSet","remoteDescription","update","mediaStreamTrack","signaledTrackId","match","mediaTrackReceiver","trackReceiver","ex","backoff","_initiateIceRestart","shouldReoffer","senders_1","getSenders","filter","reduce","shouldOffer","mediaSections","sendersOfKind","isSenderOfKind","hasDataTrack","size","hasApplicationMediaSection","needsApplicationMediaSection","promise","iceRestart","values","createOffer","trackId","mediaTrackSender","Array","from","keys","transceivers","getTransceivers","activeTransceivers","stopped","assignedTransceivers","midsToTrackIds","_getMediaTrackSenderId","sdp1","unassignedTransceivers","newTrackIdsByKind","sdp2","setLocalDescription","publishWarning","_addOrRewriteLocalTrackIds","negotiationCompleted","getState","filterOutMediaStreamIds","revertForAll","sdpWithoutSimulcastForNonVP8MediaSections","_rollbackAndApplyOffer","setRemoteDescription","_close","_handleGlare","iceState","has","dataChannelDict","ordered","maxPacketLifeTime","maxRetransmits","createDataChannel","addDataChannel","deferred","_setPublisherHint","result","reject","queuedHint","get","parameters","getParameters","layerIndex","_maybeUpdateEncodings","setParameters","_addOrUpdateTransceiver","addSender","concat","localDescriptionRevision","bracket","transition","key","tryTransition","removeDataChannel","removeTrack","removeSender","setConfiguration","period","setDelay","updates","_updateIce","response","rewriteLocalTrackId","pcv2","stats","rewriteTrackId","receiver","__spreadArray","rewriteTrackIds","remoteAudioTrackStats","remoteVideoTrackStats","localAudioTrackStats","localVideoTrackStats","bundlePolicy","rtcpMuxPolicy","shouldRecycleTransceiver","recycledTransceivers","localCodec","shift","remoteCodecMap","splice","indexOf","updateLocalCodecs","codecMap","section","pts","updateRemoteCodecMaps","matched","updateRecycledTransceivers","_handleQueuedPublisherHints","maxAudioBitrate","maxVideoBitrate","maxBitrates","promises","maxBitrate","params","removeMaxBitrate","label","setMaxBitrate","priority","networkPriority","isArray","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/signaling/v2/peerconnection.js"],"sourcesContent":["'use strict';\n\nconst DefaultBackoff = require('../../util/backoff');\nconst {\n  RTCIceCandidate: DefaultRTCIceCandidate,\n  RTCPeerConnection: DefaultRTCPeerConnection,\n  RTCSessionDescription: DefaultRTCSessionDescription,\n  getStats: getStatistics\n} = require('../../webrtc');\n\nconst util = require('../../webrtc/util');\n\nconst {\n  DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n  DEFAULT_LOG_LEVEL,\n  DEFAULT_SESSION_TIMEOUT_SEC,\n  iceRestartBackoffConfig\n} = require('../../util/constants');\n\nconst {\n  addOrRewriteNewTrackIds,\n  addOrRewriteTrackIds,\n  createCodecMapForMediaSection,\n  disableRtx,\n  enableDtxForOpus,\n  filterLocalCodecs,\n  getMediaSections,\n  removeSSRCAttributes,\n  revertSimulcast,\n  setCodecPreferences,\n  setSimulcast\n} = require('../../util/sdp');\n\nconst DefaultTimeout = require('../../util/timeout');\n\nconst {\n  MediaClientLocalDescFailedError,\n  MediaClientRemoteDescFailedError\n} = require('../../util/twilio-video-errors');\n\nconst {\n  buildLogLevels,\n  getPlatform,\n  isChromeScreenShareTrack,\n  oncePerTick,\n  defer\n} = require('../../util');\n\nconst IceBox = require('./icebox');\nconst DefaultIceConnectionMonitor = require('./iceconnectionmonitor.js');\nconst DataTrackReceiver = require('../../data/receiver');\nconst MediaTrackReceiver = require('../../media/track/receiver');\nconst StateMachine = require('../../statemachine');\nconst Log = require('../../util/log');\nconst TrackMatcher = require('../../util/sdp/trackmatcher');\nconst workaroundIssue8329 = require('../../util/sdp/issue8329');\n\nconst guess = util.guessBrowser();\nconst platform = getPlatform();\nconst isAndroid = /android/.test(platform);\nconst isChrome = guess === 'chrome';\nconst isFirefox = guess === 'firefox';\nconst isSafari = guess === 'safari';\n\nlet nInstances = 0;\n\n/*\nPeerConnectionV2 States\n-----------------------\n\n    +------+    +--------+\n    |      |    |        |\n    | open |--->| closed |\n    |      |    |        |\n    +------+    +--------+\n      |  ^          ^\n      |  |          |\n      |  |          |\n      v  |          |\n  +----------+      |\n  |          |      |\n  | updating |------+\n  |          |\n  +----------+\n\n*/\n\nconst states = {\n  open: [\n    'closed',\n    'updating'\n  ],\n  updating: [\n    'closed',\n    'open'\n  ],\n  closed: []\n};\n\n/**\n * @extends StateMachine\n * @property {id}\n * @emits PeerConnectionV2#connectionStateChanged\n * @emits PeerConnectionV2#iceConnectionStateChanged\n * @emits PeerConnectionV2#candidates\n * @emits PeerConnectionV2#description\n */\nclass PeerConnectionV2 extends StateMachine {\n  /**\n   * Construct a {@link PeerConnectionV2}.\n   * @param {string} id\n   * @param {EncodingParametersImpl} encodingParameters\n   * @param {PreferredCodecs} preferredCodecs\n   * @param {object} [options]\n   */\n  constructor(id, encodingParameters, preferredCodecs, options) {\n    super('open', states);\n    options = Object.assign({\n      enableDscp: false,\n      dummyAudioMediaStreamTrack: null,\n      isChromeScreenShareTrack,\n      iceServers: [],\n      logLevel: DEFAULT_LOG_LEVEL,\n      offerOptions: {},\n      revertSimulcast,\n      sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,\n      setCodecPreferences,\n      setSimulcast,\n      Backoff: DefaultBackoff,\n      IceConnectionMonitor: DefaultIceConnectionMonitor,\n      RTCIceCandidate: DefaultRTCIceCandidate,\n      RTCPeerConnection: DefaultRTCPeerConnection,\n      RTCSessionDescription: DefaultRTCSessionDescription,\n      Timeout: DefaultTimeout\n    }, options);\n\n    const configuration = getConfiguration(options);\n    const logLevels = buildLogLevels(options.logLevel);\n    const RTCPeerConnection = options.RTCPeerConnection;\n\n    if (options.enableDscp === true) {\n      options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};\n      options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];\n      options.chromeSpecificConstraints.optional.push({ googDscp: true });\n    }\n\n    const log = options.log ? options.log.createLog('webrtc', this) : new Log('webrtc', this, logLevels, options.loggerName);\n    const peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);\n\n    if (options.dummyAudioMediaStreamTrack) {\n      peerConnection.addTrack(options.dummyAudioMediaStreamTrack);\n    }\n\n    Object.defineProperties(this, {\n      _appliedTrackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _dataChannels: {\n        value: new Map()\n      },\n      _dataTrackReceivers: {\n        value: new Set()\n      },\n      _descriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _didGenerateLocalCandidates: {\n        writable: true,\n        value: false\n      },\n      _enableDscp: {\n        value: options.enableDscp\n      },\n      _encodingParameters: {\n        value: encodingParameters\n      },\n      _isChromeScreenShareTrack: {\n        value: options.isChromeScreenShareTrack,\n      },\n      _iceGatheringFailed: {\n        value: false,\n        writable: true\n      },\n      _iceGatheringTimeout: {\n        value: new options.Timeout(\n          () => this._handleIceGatheringTimeout(),\n          DEFAULT_ICE_GATHERING_TIMEOUT_MS,\n          false)\n      },\n      _iceRestartBackoff: {\n        // eslint-disable-next-line new-cap\n        value: new options.Backoff(iceRestartBackoffConfig)\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _isIceConnectionInactive: {\n        writable: true,\n        value: false\n      },\n      _isIceLite: {\n        writable: true,\n        value: false\n      },\n      _isIceRestartBackoffInProgress: {\n        writable: true,\n        value: false\n      },\n      _isRestartingIce: {\n        writable: true,\n        value: false\n      },\n      _lastIceConnectionState: {\n        writable: true,\n        value: null\n      },\n      _lastStableDescriptionRevision: {\n        writable: true,\n        value: 0\n      },\n      _localCandidates: {\n        writable: true,\n        value: []\n      },\n      _localCodecs: {\n        value: new Set()\n      },\n      _localCandidatesRevision: {\n        writable: true,\n        value: 1\n      },\n      _localDescriptionWithoutSimulcast: {\n        writable: true,\n        value: null\n      },\n      _localDescription: {\n        writable: true,\n        value: null\n      },\n      _localUfrag: {\n        writable: true,\n        value: null\n      },\n      _log: {\n        value: log\n      },\n      _eventObserver: {\n        value: options.eventObserver\n      },\n      _remoteCodecMaps: {\n        value: new Map()\n      },\n      _rtpSenders: {\n        value: new Map()\n      },\n      _rtpNewSenders: {\n        value: new Set()\n      },\n      _iceConnectionMonitor: {\n        value: new options.IceConnectionMonitor(peerConnection)\n      },\n      _mediaTrackReceivers: {\n        value: new Set()\n      },\n      _needsAnswer: {\n        writable: true,\n        value: false\n      },\n      _negotiationRole: {\n        writable: true,\n        value: null\n      },\n      _offerOptions: {\n        writable: true,\n        value: options.offerOptions\n      },\n      _onEncodingParametersChanged: {\n        value: oncePerTick(() => {\n          if (!this._needsAnswer) {\n            updateEncodingParameters(this);\n          }\n        })\n      },\n      _peerConnection: {\n        value: peerConnection\n      },\n      _preferredAudioCodecs: {\n        value: preferredCodecs.audio\n      },\n      _preferredVideoCodecs: {\n        value: preferredCodecs.video\n      },\n      _shouldApplyDtx: {\n        value: preferredCodecs.audio.every(({ codec }) => codec !== 'opus')\n          || preferredCodecs.audio.some(({ codec, dtx }) => codec === 'opus' && dtx)\n      },\n      _queuedDescription: {\n        writable: true,\n        value: null\n      },\n      _iceReconnectTimeout: {\n        value: new options.Timeout(() => {\n          log.debug('ICE reconnect timed out');\n          this.close();\n        }, options.sessionTimeout, false)\n      },\n      _recycledTransceivers: {\n        value: {\n          audio: [],\n          video: []\n        }\n      },\n      _replaceTrackPromises: {\n        value: new Map()\n      },\n      _remoteCandidates: {\n        writable: true,\n        value: new IceBox()\n      },\n      _setCodecPreferences: {\n        // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264\n        // preferred codec is selected does not work on Android Firefox due to this behavior:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by\n        // not applying any non-H264 preferred video codec.\n        value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264'\n          ? sdp => sdp\n          : options.setCodecPreferences\n      },\n      _setSimulcast: {\n        value: options.setSimulcast\n      },\n      _revertSimulcast: {\n        value: options.revertSimulcast\n      },\n      _RTCIceCandidate: {\n        value: options.RTCIceCandidate\n      },\n      _RTCPeerConnection: {\n        value: options.RTCPeerConnection\n      },\n      _RTCSessionDescription: {\n        value: options.RTCSessionDescription\n      },\n      _shouldOffer: {\n        writable: true,\n        value: false\n      },\n      _shouldRestartIce: {\n        writable: true,\n        value: false\n      },\n      _trackIdsToAttributes: {\n        value: new Map(),\n        writable: true\n      },\n      _trackMatcher: {\n        writable: true,\n        value: null\n      },\n      _mediaTrackSenderToPublisherHints: {\n        value: new Map()\n      },\n      id: {\n        enumerable: true,\n        value: id\n      }\n    });\n\n    encodingParameters.on('changed', this._onEncodingParametersChanged);\n\n    peerConnection.addEventListener('connectionstatechange', this._handleConnectionStateChange.bind(this));\n    peerConnection.addEventListener('datachannel', this._handleDataChannelEvent.bind(this));\n    peerConnection.addEventListener('icecandidate', this._handleIceCandidateEvent.bind(this));\n    peerConnection.addEventListener('iceconnectionstatechange', this._handleIceConnectionStateChange.bind(this));\n    peerConnection.addEventListener('icegatheringstatechange', this._handleIceGatheringStateChange.bind(this));\n    peerConnection.addEventListener('signalingstatechange', this._handleSignalingStateChange.bind(this));\n    peerConnection.addEventListener('track', this._handleTrackEvent.bind(this));\n\n    const self = this;\n    this.on('stateChanged', function stateChanged(state) {\n      if (state !== 'closed') {\n        return;\n      }\n      self.removeListener('stateChanged', stateChanged);\n      self._dataChannels.forEach((dataChannel, dataTrackSender) => {\n        self.removeDataTrackSender(dataTrackSender);\n      });\n    });\n  }\n\n  toString() {\n    return `[PeerConnectionV2 #${this._instanceId}: ${this.id}]`;\n  }\n\n  setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast) {\n    this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast);\n    // clear adaptive simulcast from codec preferences if it was set.\n    this._preferredVideoCodecs.forEach(cs => {\n      if ('adaptiveSimulcast' in cs) {\n        cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;\n      }\n    });\n  }\n\n  get _shouldApplySimulcast() {\n    if (!isChrome && !isSafari) {\n      return false;\n    }\n\n    // adaptiveSimulcast is set to false after connected message is received if other party does not support it.\n    const simulcast = this._preferredVideoCodecs.some(cs => {\n      return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;\n    });\n\n    return simulcast;\n  }\n\n  /**\n   * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState\n   * if supported by the browser, its RTCIceConnectionState otherwise.\n   * @property {RTCPeerConnectionState}\n   */\n  get connectionState() {\n    return this.iceConnectionState === 'failed'\n      ? 'failed' : (this._peerConnection.connectionState || this.iceConnectionState);\n  }\n\n  /**\n   * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's\n   * RTCIceConnectionState.\n   * @property {RTCIceConnectionState}\n   */\n  get iceConnectionState() {\n    return ((this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected') || this._iceGatheringFailed)\n      ? 'failed' : this._peerConnection.iceConnectionState;\n  }\n\n  /**\n   * Whether the {@link PeerConnectionV2} has negotiated or is in the process\n   * of negotiating the application m= section.\n   * @returns {boolean}\n   */\n  get isApplicationSectionNegotiated() {\n    if (this._peerConnection.signalingState !== 'closed') {\n      // accessing .localDescription in 'closed' state causes it throw exceptions.\n      return this._peerConnection.localDescription\n        ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0\n        : false;\n    }\n    return true;\n  }\n\n  /**\n   * Whether adaptive simulcast is enabled.\n   * @returns {boolean}\n   */\n  get _isAdaptiveSimulcastEnabled() {\n    const adaptiveSimulcastEntry = this._preferredVideoCodecs.find(cs => 'adaptiveSimulcast' in cs);\n    return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;\n  }\n\n  /**\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   * @returns {boolean} true if encodings were updated.\n   */\n  _maybeUpdateEncodings(track, encodings, trackReplaced = false) {\n    if (track.kind !== 'video' || track.readyState === 'ended') {\n      return false;\n    }\n    // NOTE(mmalavalli): There is no guarantee that CanvasCaptureMediaStreamTracks will always have \"width\" and \"height\"\n    // in their settings. So, we don't update the encodings if they are not present.\n    // Chromium bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1367082\n    const { height, width } = track.getSettings();\n    if (typeof height !== 'number' || typeof width !== 'number') {\n      return false;\n    }\n    // Note(mpatwardhan): always configure encodings for safari.\n    // for chrome only when adaptive simulcast enabled.\n    const browser = util.guessBrowser();\n    if (browser === 'safari' || (browser === 'chrome' && this._isAdaptiveSimulcastEnabled)) {\n      this._updateEncodings(track, encodings, trackReplaced);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Configures with default encodings depending on track type and resolution.\n   * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy\n   * values. When trackReplaced is set to true, it will clear 'active' for any encodings that\n   * needs to be enabled.\n   * @param {MediaStreamTrack} track\n   * @param {Array<RTCRtpEncodingParameters>} encodings\n   * @param {boolean} trackReplaced\n   */\n  _updateEncodings(track, encodings, trackReplaced) {\n    if (this._isChromeScreenShareTrack(track)) {\n      const screenShareActiveLayerConfig = [\n        { scaleResolutionDownBy: 1 },\n        { scaleResolutionDownBy: 1 }\n      ];\n      encodings.forEach((encoding, i) => {\n        const activeLayerConfig = screenShareActiveLayerConfig[i];\n        if (activeLayerConfig) {\n          encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;\n          if (trackReplaced) {\n            delete encoding.active;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    } else {\n      const { width, height }  = track.getSettings();\n      // NOTE(mpatwardhan): for non-screen share tracks\n      // enable layers depending on track resolutions\n      const pixelsToMaxActiveLayers = [\n        { pixels: 960 * 540, maxActiveLayers: 3 },\n        { pixels: 480 * 270, maxActiveLayers: 2 },\n        { pixels: 0, maxActiveLayers: 1 }\n      ];\n\n      const trackPixels =  width * height;\n      const activeLayersInfo = pixelsToMaxActiveLayers.find(layer => trackPixels >= layer.pixels);\n      const activeLayers = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);\n      encodings.forEach((encoding, i) => {\n        const enabled  = i < activeLayers;\n        if (enabled) {\n          encoding.scaleResolutionDownBy = 1 << (activeLayers - i - 1);\n          if (trackReplaced) {\n            encoding.active = true;\n          }\n        } else {\n          encoding.active = false;\n          delete encoding.scaleResolutionDownBy;\n        }\n      });\n    }\n    this._log.debug('_updateEncodings:', encodings.map(({ active, scaleResolutionDownBy }, i) => `[${i}: ${active}, ${scaleResolutionDownBy || 0}]`).join(', '));\n  }\n\n  /**\n   * Add an ICE candidate to the {@link PeerConnectionV2}.\n   * @private\n   * @param {object} candidate\n   * @returns {Promise<void>}\n   */\n  _addIceCandidate(candidate) {\n    return Promise.resolve().then(() => {\n      candidate = new this._RTCIceCandidate(candidate);\n      return this._peerConnection.addIceCandidate(candidate);\n    }).catch(error => {\n      // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an\n      // empty candidate string to signal end-of-candidates, followed by a null\n      // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since\n      // this does not affect the media connection between Firefox 68+ and Chrome/Safari\n      // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.\n      //\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n      //\n      this._log.warn(`Failed to add RTCIceCandidate ${candidate ? `\"${candidate.candidate}\"` : 'null'}: `\n        + error.message);\n    });\n  }\n\n  /**\n   * Add ICE candidates to the {@link PeerConnectionV2}.\n   * @private\n   * @param {Array<object>} candidates\n   * @returns {Promise<void>}\n   */\n  _addIceCandidates(candidates) {\n    return Promise.all(candidates.map(this._addIceCandidate, this)).then(() => {});\n  }\n\n  /**\n   * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the\n   * given MediaStreamTrack.\n   * @private\n   * @param {MediaStreamTrack} track\n   * @returns {RTCRtpTransceiver}\n   */\n  _addOrUpdateTransceiver(track) {\n    const transceiver = takeRecycledTransceiver(this, track.kind);\n    if (transceiver && transceiver.sender) {\n      const oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;\n      if (oldTrackId) {\n        this._log.warn(`Reusing transceiver: ${transceiver.mid}] ${oldTrackId} => ${track.id}`);\n      }\n      // NOTE(mpatwardhan):remember this transceiver while we replace track.\n      // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent\n      // this one from getting recycled while replaceTrack is pending.\n      this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(() => {\n        transceiver.direction = 'sendrecv';\n      }, () => {\n        // Do nothing.\n      }).finally(() => {\n        this._replaceTrackPromises.delete(transceiver);\n      }));\n      return transceiver;\n    }\n    return this._peerConnection.addTransceiver(track);\n  }\n\n  /**\n   * Check the {@link IceBox}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _checkIceBox(description) {\n    const ufrag = getUfrag(description);\n    if (!ufrag) {\n      return Promise.resolve();\n    }\n    const candidates = this._remoteCandidates.setUfrag(ufrag);\n    return this._addIceCandidates(candidates);\n  }\n\n  /**\n   * Create an answer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<boolean>}\n   */\n  _answer(offer) {\n    return Promise.resolve().then(() => {\n      if (!this._negotiationRole) {\n        this._negotiationRole = 'answerer';\n      }\n      return this._setRemoteDescription(offer);\n    }).catch(() => {\n      throw new MediaClientRemoteDescFailedError();\n    }).then(() => {\n      return this._peerConnection.createAnswer();\n    }).then(answer => {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        answer = new this._RTCSessionDescription({\n          sdp: disableRtx(answer.sdp),\n          type: answer.type\n        });\n      } else {\n        answer = workaroundIssue8329(answer);\n      }\n\n      // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      let updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);\n\n      if (this._shouldApplySimulcast) {\n        let sdpWithoutSimulcast = updatedSdp;\n        updatedSdp = this._setSimulcast(sdpWithoutSimulcast, this._trackIdsToAttributes);\n        // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n        // unset simulcast for sections in local offer where corresponding\n        // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n        updatedSdp = this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);\n      }\n\n      // NOTE(mmalavalli): Work around Chromium bug 1074421.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421\n      updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');\n\n      return this._setLocalDescription({\n        type: answer.type,\n        sdp: updatedSdp\n      });\n    }).then(() => {\n      return this._checkIceBox(offer);\n    }).then(() => {\n      return this._queuedDescription\n        && this._updateDescription(this._queuedDescription);\n    }).then(() => {\n      this._queuedDescription = null;\n      return this._maybeReoffer(this._peerConnection.localDescription);\n    }).catch(error => {\n      const errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();\n      this._publishMediaWarning({\n        message: 'Failed to _answer',\n        code: errorToThrow.code,\n        error\n      });\n      throw errorToThrow;\n    });\n  }\n\n  /**\n   * Close the underlying RTCPeerConnection. Returns false if the\n   * RTCPeerConnection was already closed.\n   * @private\n   * @returns {boolean}\n   */\n  _close() {\n    this._iceConnectionMonitor.stop();\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.close();\n      this.preempt('closed');\n      this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a \"connectionstatechange\" event.\n   * @private\n   * @returns {void}\n   */\n  _handleConnectionStateChange() {\n    this.emit('connectionStateChanged');\n  }\n\n  /**\n   * Handle a \"datachannel\" event.\n   * @private\n   * @param {RTCDataChannelEvent} event\n   * @returns {void}\n   */\n  _handleDataChannelEvent(event) {\n    const dataChannel = event.channel;\n    const dataTrackReceiver = new DataTrackReceiver(dataChannel);\n    this._dataTrackReceivers.add(dataTrackReceiver);\n\n    dataChannel.addEventListener('close', () => {\n      this._dataTrackReceivers.delete(dataTrackReceiver);\n    });\n\n    this.emit('trackAdded', dataTrackReceiver);\n  }\n\n  /**\n   * Handle a glare scenario on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  _handleGlare(offer) {\n    this._log.debug('Glare detected; rolling back');\n    if (this._isRestartingIce) {\n      this._log.debug('An ICE restart was in progress; we\\'ll need to restart ICE again after rolling back');\n      this._isRestartingIce = false;\n      this._shouldRestartIce = true;\n    }\n    return Promise.resolve().then(() => {\n      this._trackIdsToAttributes = new Map(this._appliedTrackIdsToAttributes);\n      return this._setLocalDescription({ type: 'rollback' });\n    }).then(() => {\n      this._needsAnswer = false;\n      return this._answer(offer);\n    }).then(didReoffer => {\n      return didReoffer ? Promise.resolve() : this._offer();\n    });\n  }\n\n  _publishMediaWarning({ message, code, error, sdp }) {\n    this._eventObserver.emit('event', { level: 'warning', name: 'error', group: 'media', payload: {\n      message,\n      code,\n      context: JSON.stringify({ error: error.message, sdp })\n    } });\n  }\n\n  /**\n   * Handle an ICE candidate event.\n   * @private\n   * @param {Event} event\n   * @returns {void}\n   */\n  _handleIceCandidateEvent(event) {\n    if (event.candidate) {\n      this._log.debug('Clearing ICE gathering timeout');\n      this._didGenerateLocalCandidates = true;\n      this._iceGatheringTimeout.clear();\n      this._localCandidates.push(event.candidate);\n    }\n    const peerConnectionState = {\n      ice: {\n        candidates: this._isIceLite ? [] : this._localCandidates.slice(),\n        ufrag: this._localUfrag\n      },\n      id: this.id\n    };\n    if (!event.candidate) {\n      peerConnectionState.ice.complete = true;\n    }\n    if (!(this._isIceLite && event.candidate)) {\n      peerConnectionState.ice.revision = this._localCandidatesRevision++;\n      this.emit('candidates', peerConnectionState);\n    }\n  }\n\n  /**\n   * Handle an ICE connection state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleIceConnectionStateChange() {\n    const { iceConnectionState } = this._peerConnection;\n    const isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);\n    const log = this._log;\n\n    log.debug(`ICE connection state is \"${iceConnectionState}\"`);\n    if (isIceConnectedOrComplete) {\n      this._iceReconnectTimeout.clear();\n      this._iceRestartBackoff.reset();\n    }\n\n    if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {\n      // Case 1: Transition to \"failed\".\n      log.warn('ICE failed');\n      this._initiateIceRestartBackoff();\n    } else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {\n      // Case 2: Transition from \"disconnected\" or \"failed\".\n      log.debug('ICE reconnected');\n    }\n\n    // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.\n    if (iceConnectionState === 'connected') {\n      this._isIceConnectionInactive = false;\n      this._iceConnectionMonitor.start(() => {\n        // note: iceConnection monitor waits for iceConnectionState=disconnected for\n        // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange\n        this._iceConnectionMonitor.stop();\n        if (!this._shouldRestartIce && !this._isRestartingIce) {\n          log.warn('ICE Connection Monitor detected inactivity');\n          this._isIceConnectionInactive = true;\n          this._initiateIceRestartBackoff();\n          this.emit('iceConnectionStateChanged');\n          this.emit('connectionStateChanged');\n        }\n      });\n    } else if (!['disconnected', 'completed'].includes(iceConnectionState)) { // don't stop monitoring for disconnected or completed.\n      this._iceConnectionMonitor.stop();\n      this._isIceConnectionInactive = false;\n    }\n\n    this._lastIceConnectionState = iceConnectionState;\n    this.emit('iceConnectionStateChanged');\n  }\n\n  /**\n   * Handle ICE gathering timeout.\n   * @private\n   * @returns {void}\n   */\n  _handleIceGatheringTimeout() {\n    this._log.warn('ICE failed to gather any local candidates');\n    this._iceGatheringFailed = true;\n    this._initiateIceRestartBackoff();\n    this.emit('iceConnectionStateChanged');\n    this.emit('connectionStateChanged');\n  }\n\n  /**\n   * Handle an ICE gathering state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleIceGatheringStateChange() {\n    const { iceGatheringState } = this._peerConnection;\n    const log = this._log;\n    log.debug(`ICE gathering state is \"${iceGatheringState}\"`);\n\n    // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection\n    // has started gathering candidates for the first time since the initial offer/answer\n    // or an offer/answer with ICE restart.\n    const { delay, isSet } = this._iceGatheringTimeout;\n    if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {\n      log.debug(`Starting ICE gathering timeout: ${delay}`);\n      this._iceGatheringFailed = false;\n      this._iceGatheringTimeout.start();\n    }\n  }\n\n  /**\n   * Handle a signaling state change event.\n   * @private\n   * @returns {void}\n   */\n  _handleSignalingStateChange() {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);\n    }\n  }\n\n  /**\n   * Handle a track event.\n   * @private\n   * @param {RTCTrackEvent} event\n   * @returns {void}\n   */\n  _handleTrackEvent(event) {\n    const sdp = this._peerConnection.remoteDescription\n      ? this._peerConnection.remoteDescription.sdp\n      : null;\n\n    this._trackMatcher = this._trackMatcher || new TrackMatcher();\n    this._trackMatcher.update(sdp);\n\n    const mediaStreamTrack = event.track;\n    const signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;\n    const mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack);\n\n    // NOTE(mmalavalli): \"ended\" is not fired on the remote MediaStreamTrack when\n    // the remote peer removes a track. So, when this MediaStreamTrack is re-used\n    // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),\n    // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack\n    // before adding the new MediaTrackReceiver.\n    this._mediaTrackReceivers.forEach(trackReceiver => {\n      if (trackReceiver.track.id === mediaTrackReceiver.track.id) {\n        this._mediaTrackReceivers.delete(trackReceiver);\n      }\n    });\n\n    this._mediaTrackReceivers.add(mediaTrackReceiver);\n    mediaStreamTrack.addEventListener('ended', () => this._mediaTrackReceivers.delete(mediaTrackReceiver));\n    this.emit('trackAdded', mediaTrackReceiver);\n  }\n\n  /**\n   * Initiate ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  _initiateIceRestart() {\n    if (this._peerConnection.signalingState === 'closed') {\n      return;\n    }\n    const log = this._log;\n    log.warn('Attempting to restart ICE');\n    this._didGenerateLocalCandidates = false;\n    this._isIceRestartBackoffInProgress = false;\n    this._shouldRestartIce = true;\n\n    const { delay, isSet } = this._iceReconnectTimeout;\n    if (!isSet) {\n      log.debug(`Starting ICE reconnect timeout: ${delay}`);\n      this._iceReconnectTimeout.start();\n    }\n    this.offer().catch(ex => {\n      log.error(`offer failed in _initiateIceRestart with: ${ex.message}`);\n    });\n  }\n\n  /**\n   * Schedule an ICE Restart.\n   * @private\n   * @returns {void}\n   */\n  _initiateIceRestartBackoff() {\n    if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {\n      return;\n    }\n    this._log.warn('An ICE restart has been scheduled');\n    this._isIceRestartBackoffInProgress = true;\n    this._iceRestartBackoff.backoff(() => this._initiateIceRestart());\n  }\n\n  /**\n   * Conditionally re-offer.\n   * @private\n   * @param {?RTCSessionDescriptionInit} localDescription\n   * @returns {Promise<boolean>}\n   */\n  _maybeReoffer(localDescription) {\n    let shouldReoffer = this._shouldOffer;\n\n    if (localDescription && localDescription.sdp) {\n      // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or\n      // video send* m= lines than the corresponding RTCRtpSenders with non-null\n      // MediaStreamTracks, it means that the newly added RTCRtpSenders require\n      // renegotiation.\n      const senders = this._peerConnection.getSenders().filter(sender => sender.track);\n      shouldReoffer = ['audio', 'video'].reduce((shouldOffer, kind) => {\n        const mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');\n        const sendersOfKind = senders.filter(isSenderOfKind.bind(null, kind));\n        return shouldOffer || (mediaSections.length < sendersOfKind.length);\n      }, shouldReoffer);\n\n      // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share\n      // but no m= application section.\n      const hasDataTrack = this._dataChannels.size > 0;\n      const hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;\n      const needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;\n      shouldReoffer = shouldReoffer || needsApplicationMediaSection;\n    }\n\n    const promise = shouldReoffer ? this._offer() : Promise.resolve();\n    return promise.then(() => shouldReoffer);\n  }\n\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @private\n   * @returns {Promise<void>}\n   */\n  _offer() {\n    const offerOptions = Object.assign({}, this._offerOptions);\n    this._needsAnswer = true;\n    if (this._shouldRestartIce) {\n      this._shouldRestartIce = false;\n      this._isRestartingIce = true;\n      offerOptions.iceRestart = true;\n    }\n\n    return Promise.all(this._replaceTrackPromises.values()).then(() => {\n      return this._peerConnection.createOffer(offerOptions);\n    }).catch(error => {\n      const errorToThrow = new MediaClientLocalDescFailedError();\n      this._publishMediaWarning({\n        message: 'Failed to create offer',\n        code: errorToThrow.code,\n        error\n      });\n      throw errorToThrow;\n    }).then(offer => {\n      if (isFirefox) {\n        // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling\n        // RTX in Firefox 79+. For more details about the bug, please go here:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157\n        offer = new this._RTCSessionDescription({\n          sdp: disableRtx(offer.sdp),\n          type: offer.type\n        });\n      } else {\n        offer = workaroundIssue8329(offer);\n      }\n\n      // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes\n      // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110\n      // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ\n      // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.\n      // this also helps reduce bytes on wires\n      let sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);\n      sdp = this._peerConnection.remoteDescription\n        ? filterLocalCodecs(sdp, this._peerConnection.remoteDescription.sdp)\n        : sdp;\n\n      let updatedSdp = this._setCodecPreferences(\n        sdp,\n        this._preferredAudioCodecs,\n        this._preferredVideoCodecs);\n\n      this._shouldOffer = false;\n      if (!this._negotiationRole) {\n        this._negotiationRole = 'offerer';\n      }\n\n      if (this._shouldApplySimulcast) {\n        this._localDescriptionWithoutSimulcast = {\n          type: 'offer',\n          sdp: updatedSdp\n        };\n        updatedSdp = this._setSimulcast(updatedSdp, this._trackIdsToAttributes);\n      }\n      return this._setLocalDescription({\n        type: 'offer',\n        sdp: updatedSdp\n      });\n    });\n  }\n\n  /**\n   * Get the MediaTrackSender ID of the given MediaStreamTrack ID.\n   * Since a MediaTrackSender's underlying MediaStreamTrack can be\n   * replaced, the corresponding IDs can mismatch.\n   * @private\n   * @param {Track.ID} id\n   * @returns {Track.ID}\n   */\n  _getMediaTrackSenderId(trackId) {\n    const mediaTrackSender = Array.from(this._rtpSenders.keys()).find(({ track: { id } }) => id === trackId);\n    return mediaTrackSender ? mediaTrackSender.id : trackId;\n  }\n\n  /**\n   * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.\n   * @private\n   * @param {RTCSessionDescription} description\n   * @return {RTCSessionDescription}\n   */\n  _addOrRewriteLocalTrackIds(description) {\n    const transceivers = this._peerConnection.getTransceivers();\n    const activeTransceivers = transceivers.filter(({ sender, stopped }) => !stopped && sender && sender.track);\n\n    // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in\n    // SDPs, and even if they are, there is no guarantee that they will be the same as the\n    // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs\n    // to the assigned m= sections here.\n    const assignedTransceivers = activeTransceivers.filter(({ mid }) => mid);\n    const midsToTrackIds = new Map(assignedTransceivers.map(({ mid, sender }) => [mid, this._getMediaTrackSenderId(sender.track.id)]));\n    const sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds);\n\n    // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.\n    // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.\n    const unassignedTransceivers = activeTransceivers.filter(({ mid }) => !mid);\n    const newTrackIdsByKind = new Map(['audio', 'video'].map(kind => [\n      kind,\n      unassignedTransceivers.filter(({ sender }) => sender.track.kind === kind).map(({ sender }) => this._getMediaTrackSenderId(sender.track.id))\n    ]));\n    const sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);\n\n    return new this._RTCSessionDescription({\n      sdp: sdp2,\n      type: description.type\n    });\n  }\n\n  /**\n   * Rollback and apply the given offer.\n   * @private\n   * @param {RTCSessionDescriptionInit} offer\n   * @returns {Promise<void>}\n   */\n  _rollbackAndApplyOffer(offer) {\n    return this._setLocalDescription({ type: 'rollback' }).then(() => this._setLocalDescription(offer));\n  }\n\n  /**\n   * Set a local description on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescription|RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _setLocalDescription(description) {\n    if (description.type !== 'rollback' && this._shouldApplyDtx) {\n      description = new this._RTCSessionDescription({\n        sdp: enableDtxForOpus(description.sdp),\n        type: description.type\n      });\n    }\n    return this._peerConnection.setLocalDescription(description).catch(error => {\n      this._log.warn(`Calling setLocalDescription with an RTCSessionDescription of type \"${description.type}\" failed with the error \"${error.message}\".`, error);\n\n      const errorToThrow = new MediaClientLocalDescFailedError();\n      const publishWarning = {\n        message: `Calling setLocalDescription with an RTCSessionDescription of type \"${description.type}\" failed`,\n        code: errorToThrow.code,\n        error\n      };\n\n      if (description.sdp) {\n        this._log.warn(`The SDP was ${description.sdp}`);\n        publishWarning.sdp = description.sdp;\n      }\n      this._publishMediaWarning(publishWarning);\n      throw errorToThrow;\n    }).then(() => {\n      if (description.type !== 'rollback') {\n        this._localDescription = this._addOrRewriteLocalTrackIds(description);\n\n        // NOTE(mmalavalli): In order for this feature to be backward compatible with older\n        // SDK versions which to not support opus DTX, we append \"usedtx=1\" to the local SDP\n        // only while applying it. We will not send it over the wire to prevent inadvertent\n        // enabling of opus DTX in older SDKs. Newer SDKs will append \"usedtx=1\" by themselves\n        // if the developer has requested opus DTX to be enabled. (JSDK-3063)\n        if (this._shouldApplyDtx) {\n          this._localDescription = new this._RTCSessionDescription({\n            sdp: enableDtxForOpus(this._localDescription.sdp, []),\n            type: this._localDescription.type\n          });\n        }\n\n        this._localCandidates = [];\n        if (description.type === 'offer') {\n          this._descriptionRevision++;\n        } else if (description.type === 'answer') {\n          this._lastStableDescriptionRevision = this._descriptionRevision;\n          negotiationCompleted(this);\n        }\n        this._localUfrag = getUfrag(description);\n        this.emit('description', this.getState());\n      }\n    });\n  }\n\n  /**\n   * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _setRemoteDescription(description) {\n    if (description.sdp) {\n      description.sdp = this._setCodecPreferences(\n        description.sdp,\n        this._preferredAudioCodecs,\n        this._preferredVideoCodecs);\n\n      if (this._shouldApplyDtx) {\n        description.sdp = enableDtxForOpus(description.sdp);\n      } else {\n        // NOTE(mmalavalli): Remove \"usedtx=1\" from opus's fmtp line if present\n        // since DTX is disabled.\n        description.sdp = enableDtxForOpus(description.sdp, []);\n      }\n\n      if (isFirefox) {\n        // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By\n        // mapping MediaStream IDs in the SDP to \"-\", we ensure the \"track\" event\n        // doesn't include any new MediaStreams in Firefox. Its `streams` member\n        // will always be the empty Array.\n        description.sdp = filterOutMediaStreamIds(description.sdp);\n      }\n      if (!this._peerConnection.remoteDescription) {\n        this._isIceLite = /a=ice-lite/.test(description.sdp);\n      }\n    }\n    description = new this._RTCSessionDescription(description);\n    // eslint-disable-next-line consistent-return\n    return Promise.resolve().then(() => {\n      // NOTE(syerrapragada): VMS does not support H264 simulcast. So,\n      // unset simulcast for sections in local offer where corresponding\n      // sections in answer doesn't have vp8 as preferred codec and reapply offer.\n      if (description.type === 'answer' && this._localDescriptionWithoutSimulcast) {\n        // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server\n        // revert simulcast even for vp8.\n        const adaptiveSimulcastEntry = this._preferredVideoCodecs.find(cs => 'adaptiveSimulcast' in cs);\n        const revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;\n        const sdpWithoutSimulcastForNonVP8MediaSections = this._revertSimulcast(\n          this._localDescription.sdp,\n          this._localDescriptionWithoutSimulcast.sdp,\n          description.sdp, revertForAll);\n        this._localDescriptionWithoutSimulcast = null;\n        if (sdpWithoutSimulcastForNonVP8MediaSections !== this._localDescription.sdp) {\n          return this._rollbackAndApplyOffer({\n            type: this._localDescription.type,\n            sdp: sdpWithoutSimulcastForNonVP8MediaSections\n          });\n        }\n      }\n    }).then(() => this._peerConnection.setRemoteDescription(description)).then(() => {\n      if (description.type === 'answer') {\n        if (this._isRestartingIce) {\n          this._log.debug('An ICE restart was in-progress and is now completed');\n          this._isRestartingIce = false;\n        }\n        negotiationCompleted(this);\n      }\n    }, error => {\n      this._log.warn(`Calling setRemoteDescription with an RTCSessionDescription of type \"${description.type}\" failed with the error \"${error.message}\".`, error);\n      if (description.sdp) {\n        this._log.warn(`The SDP was ${description.sdp}`);\n      }\n      throw error;\n    });\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}'s description.\n   * @private\n   * @param {RTCSessionDescriptionInit} description\n   * @returns {Promise<void>}\n   */\n  _updateDescription(description) {\n    switch (description.type) {\n      case 'answer':\n      case 'pranswer':\n        if (description.revision !== this._descriptionRevision\n          || this._peerConnection.signalingState !== 'have-local-offer') {\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        break;\n      case 'close':\n        return this._close();\n      case 'create-offer':\n        if (description.revision <= this._lastStableDescriptionRevision) {\n          return Promise.resolve();\n        } else if (this._needsAnswer) {\n          this._queuedDescription = description;\n          return Promise.resolve();\n        }\n        this._descriptionRevision = description.revision;\n        return this._offer();\n      case 'offer':\n        if (description.revision <= this._lastStableDescriptionRevision\n          || this._peerConnection.signalingState === 'closed') {\n          return Promise.resolve();\n        }\n        if (this._peerConnection.signalingState === 'have-local-offer') {\n          // NOTE(mpatwardhan): For a peer connection\n          // 1) createOffer always generate SDP with `setup:actpass`\n          // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive\n          // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active\n          // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)\n          // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936\n          // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.\n          // we do not want that. lets wait for \"initial negotiation\" before attempting glare handling.\n          if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {\n            this._queuedDescription = description;\n            return Promise.resolve();\n          }\n          this._descriptionRevision = description.revision;\n          return this._handleGlare(description);\n        }\n        this._descriptionRevision = description.revision;\n        return this._answer(description).then(() => {});\n      default:\n        // Do nothing.\n    }\n\n    // Handle answer or pranswer.\n    const revision = description.revision;\n    return Promise.resolve().then(() => {\n      return this._setRemoteDescription(description);\n    }).catch(error => {\n      const errorToThrow = new MediaClientRemoteDescFailedError();\n      this._publishMediaWarning({\n        message: `Calling setRemoteDescription with an RTCSessionDescription of type \"${description.type}\" failed`,\n        code: errorToThrow.code,\n        error,\n        sdp: description.sdp\n      });\n      throw errorToThrow;\n    }).then(() => {\n      this._lastStableDescriptionRevision = revision;\n      this._needsAnswer = false;\n      return this._checkIceBox(description);\n    }).then(() => {\n      return this._queuedDescription\n        && this._updateDescription(this._queuedDescription);\n    }).then(() => {\n      this._queuedDescription = null;\n      return this._maybeReoffer(this._peerConnection.localDescription).then(() => {});\n    });\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}'s ICE candidates.\n   * @private\n   * @param {object} iceState\n   * @returns {Promise<void>}\n   */\n  _updateIce(iceState) {\n    const candidates = this._remoteCandidates.update(iceState);\n    return this._addIceCandidates(candidates);\n  }\n\n  /**\n   * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  addDataTrackSender(dataTrackSender) {\n    if (this._dataChannels.has(dataTrackSender)) {\n      return;\n    }\n    try {\n      const dataChannelDict = {\n        ordered: dataTrackSender.ordered\n      };\n      if (dataTrackSender.maxPacketLifeTime !== null) {\n        dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;\n      }\n      if (dataTrackSender.maxRetransmits !== null) {\n        dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;\n      }\n      const dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);\n      dataTrackSender.addDataChannel(dataChannel);\n      this._dataChannels.set(dataTrackSender, dataChannel);\n    } catch (error) {\n      this._log.warn(`Error creating an RTCDataChannel for DataTrack \"${dataTrackSender.id}\": ${error.message}`);\n    }\n  }\n\n  _handleQueuedPublisherHints() {\n    if (this._peerConnection.signalingState === 'stable') {\n      this._mediaTrackSenderToPublisherHints.forEach(({ deferred, encodings }, mediaTrackSender) => {\n        this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n        this._setPublisherHint(mediaTrackSender, encodings)\n          .then(result => deferred.resolve(result))\n          .catch(error => deferred.reject(error));\n      });\n    }\n  }\n\n  /**\n   * updates encodings for simulcast layers of given sender.\n   * @param {RTCRtpSender} sender\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>} string indicating result of the operation. can be one of\n   *  \"OK\", \"INVALID_HINT\", \"COULD_NOT_APPLY_HINT\", \"UNKNOWN_TRACK\"\n   */\n  _setPublisherHint(mediaTrackSender, encodings) {\n    if (isFirefox) {\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      // skip any stale hint associated with the mediaTrackSender.\n      const queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('REQUEST_SKIPPED');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n\n    const sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');\n      return Promise.resolve('UNKNOWN_TRACK');\n    }\n\n    if (this._peerConnection.signalingState === 'closed') {\n      this._log.warn('Could not apply publisher hint because signalingState was \"closed\"');\n      return Promise.resolve('COULD_NOT_APPLY_HINT');\n    }\n\n    if (this._peerConnection.signalingState !== 'stable') {\n      // enqueue this hint to be applied when pc becomes stable.\n      this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);\n      const deferred = defer();\n      this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, { deferred, encodings });\n      return deferred.promise;\n    }\n\n    const parameters = sender.getParameters();\n    if (encodings !== null) {\n      encodings.forEach(({ enabled, layer_index: layerIndex }) => {\n        if (parameters.encodings.length > layerIndex) {\n          this._log.debug(`layer:${layerIndex}, active:${parameters.encodings[layerIndex].active} => ${enabled}`);\n          parameters.encodings[layerIndex].active = enabled;\n        } else {\n          this._log.warn(`invalid layer:${layerIndex}, active:${enabled}`);\n        }\n      });\n    }\n\n    // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings\n    // to disable any encoding that shouldn't have been enabled by publisher_hints.\n    // When encodings===null (that is we are asked to reset encodings for replaceTrack)\n    // along with disabling encodings, clear active flag for encodings that should not be disabled\n    this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null /* trackReplaced */);\n\n    return sender.setParameters(parameters).then(() => 'OK').catch(error => {\n      this._log.error('Failed to apply publisher hints:', error);\n      return 'COULD_NOT_APPLY_HINT';\n    });\n  }\n\n  /**\n   * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  addMediaTrackSender(mediaTrackSender) {\n    if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {\n      return;\n    }\n    const transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);\n    const { sender } = transceiver;\n    mediaTrackSender.addSender(sender, encodings => this._setPublisherHint(mediaTrackSender, encodings));\n    this._rtpNewSenders.add(sender);\n    this._rtpSenders.set(mediaTrackSender, sender);\n  }\n\n  /**\n   * Close the {@link PeerConnectionV2}.\n   * @returns {void}\n   */\n  close() {\n    if (this._close()) {\n      this._descriptionRevision++;\n      this._localDescription = { type: 'close' };\n      this.emit('description', this.getState());\n    }\n  }\n\n  /**\n   * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the\n   * {@link PeerConnectionV2}.\n   * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers\n   */\n  getTrackReceivers() {\n    return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));\n  }\n\n  /**\n   * Get the {@link PeerConnectionV2}'s state (specifically, its description).\n   * @returns {?object}\n   */\n  getState() {\n    if (!this._localDescription) {\n      return null;\n    }\n\n    // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an\n    // answer, and this method is called for sending a \"sync\" message while the next remote offer is being processed,\n    // we need to send the most recent stable description revision instead of the current description revision,\n    // which is supposed to be for the next local answer.\n    const localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;\n    const localDescription = {\n      type: this._localDescription.type,\n      revision: localDescriptionRevision\n    };\n    if (this._localDescription.sdp) {\n      localDescription.sdp = this._localDescription.sdp;\n    }\n    return {\n      description: localDescription,\n      id: this.id\n    };\n  }\n\n  /**\n   * Create an offer and set it on the {@link PeerConnectionV2}.\n   * @returns {Promise<void>}\n   */\n  offer() {\n    if (this._needsAnswer || this._isRestartingIce) {\n      this._shouldOffer = true;\n      return Promise.resolve();\n    }\n\n    return this.bracket('offering', key => {\n      this.transition('updating', key);\n      const promise = this._needsAnswer || this._isRestartingIce ? Promise.resolve() : this._offer();\n      return promise.then(() => {\n        this.tryTransition('open', key);\n      }, error => {\n        this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  }\n\n  /**\n   * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.\n   * @param {DataTrackSender} dataTrackSender\n   * @returns {void}\n   */\n  removeDataTrackSender(dataTrackSender) {\n    const dataChannel = this._dataChannels.get(dataTrackSender);\n    if (dataChannel) {\n      dataTrackSender.removeDataChannel(dataChannel);\n      this._dataChannels.delete(dataTrackSender);\n      dataChannel.close();\n    }\n  }\n\n  /**\n   * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.\n   * @param {MediaTrackSender} mediaTrackSender\n   * @returns {void}\n   */\n  removeMediaTrackSender(mediaTrackSender) {\n    const sender = this._rtpSenders.get(mediaTrackSender);\n    if (!sender) {\n      return;\n    }\n    if (this._peerConnection.signalingState !== 'closed') {\n      this._peerConnection.removeTrack(sender);\n    }\n    mediaTrackSender.removeSender(sender);\n    // clean up any pending publisher hints associated with this mediaTrackSender.\n    if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {\n      const queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);\n      queuedHint.deferred.resolve('UNKNOWN_TRACK');\n      this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);\n    }\n    this._rtpNewSenders.delete(sender);\n    this._rtpSenders.delete(mediaTrackSender);\n  }\n\n  /**\n   * Set the RTCConfiguration on the underlying RTCPeerConnection.\n   * @param {RTCConfiguration} configuration\n   * @returns {void}\n   */\n  setConfiguration(configuration) {\n    if (typeof this._peerConnection.setConfiguration === 'function') {\n      this._peerConnection.setConfiguration(getConfiguration(configuration));\n    }\n  }\n\n  /**\n   * Set the ICE reconnect timeout period.\n   * @param {number} period - Period in milliseconds.\n   * @returns {this}\n   */\n  setIceReconnectTimeout(period) {\n    this._iceReconnectTimeout.setDelay(period);\n    this._log.debug('Updated ICE reconnection timeout period:',\n      this._iceReconnectTimeout.delay);\n    return this;\n  }\n\n  /**\n   * Update the {@link PeerConnectionV2}.\n   * @param {object} peerConnectionState\n   * @returns {Promise<void>}\n   */\n  update(peerConnectionState) {\n    return this.bracket('updating', key => {\n      if (this.state === 'closed') {\n        return Promise.resolve();\n      }\n\n      this.transition('updating', key);\n\n      const updates = [];\n\n      if (peerConnectionState.ice) {\n        updates.push(this._updateIce(peerConnectionState.ice));\n      }\n\n      if (peerConnectionState.description) {\n        updates.push(this._updateDescription(peerConnectionState.description));\n      }\n\n      return Promise.all(updates).then(() => {\n        this.tryTransition('open', key);\n      }, error => {\n        this.tryTransition('open', key);\n        throw error;\n      });\n    });\n  }\n\n  /**\n   * Get the {@link PeerConnectionV2}'s media statistics.\n   * @returns {Promise<StandardizedStatsResponse>}\n   */\n  getStats() {\n    return getStatistics(this._peerConnection).then(response => rewriteTrackIds(this, response));\n  }\n}\n\nfunction rewriteLocalTrackId(pcv2, stats) {\n  const trackId = pcv2._getMediaTrackSenderId(stats.trackId);\n  return Object.assign(stats, { trackId });\n}\n\nfunction rewriteTrackId(pcv2, stats) {\n  const receiver = [...pcv2._mediaTrackReceivers]\n    .find(receiver => receiver.track.id === stats.trackId);\n  const trackId = receiver ? receiver.id : null;\n  return Object.assign(stats, { trackId });\n}\n\nfunction rewriteTrackIds(pcv2, response) {\n  return Object.assign(response, {\n    remoteAudioTrackStats: response.remoteAudioTrackStats.map(stats => rewriteTrackId(pcv2, stats)),\n    remoteVideoTrackStats: response.remoteVideoTrackStats.map(stats => rewriteTrackId(pcv2, stats)),\n    localAudioTrackStats: response.localAudioTrackStats.map(stats => rewriteLocalTrackId(pcv2, stats)),\n    localVideoTrackStats: response.localVideoTrackStats.map(stats => rewriteLocalTrackId(pcv2, stats)),\n  });\n}\n\n/**\n * @event PeerConnectionV2#candidates\n * @param {object} candidates\n */\n\n/**\n * @event PeerConnectionV2#connectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#description\n * @param {object} description\n */\n\n/**\n * @event PeerConnectionV2#iceConnectionStateChanged\n */\n\n/**\n * @event PeerConnectionV2#trackAdded\n * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver\n */\n\nfunction getUfrag(description) {\n  if (description.sdp) {\n    const match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);\n    if (match) {\n      return match[1];\n    }\n  }\n  return null;\n}\n\nfunction getConfiguration(configuration) {\n  return Object.assign({\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n  }, configuration);\n}\n\n/**\n * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended\n * MediaStreamTrack of a given kind.\n * @private\n * @param {string} kind\n * @param {RTCRtpSender} sender\n * @return {boolean}\n */\nfunction isSenderOfKind(kind, sender) {\n  const track = sender.track;\n  return track && track.kind === kind && track.readyState !== 'ended';\n}\n\n/**\n * Preferred codecs.\n * @typedef {object} PreferredCodecs\n * @property {Array<AudioCodec>} audio\n * @property {Array<VideoCodec>} video\n */\n\nfunction filterOutMediaStreamIds(sdp) {\n  return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');\n}\n\n/**\n * Whether an RTCRtpTransceiver can be recycled.\n * @param {RTCRtpTransceiver} transceiver\n * @returns {boolean}\n */\nfunction shouldRecycleTransceiver(transceiver, pcv2) {\n  return !transceiver.stopped\n    && !pcv2._replaceTrackPromises.has(transceiver)\n    && ['inactive', 'recvonly'].includes(transceiver.direction);\n}\n\n/**\n * Take a recycled RTCRtpTransceiver if available.\n * @param {PeerConnectionV2} pcv2\n * @param {Track.Kind} kind\n * @returns {?RTCRtpTransceiver}\n */\nfunction takeRecycledTransceiver(pcv2, kind) {\n  const preferredCodecs = {\n    audio: pcv2._preferredAudioCodecs.map(({ codec }) => codec.toLowerCase()),\n    video: pcv2._preferredVideoCodecs.map(({ codec }) => codec.toLowerCase())\n  }[kind];\n\n  const recycledTransceivers = pcv2._recycledTransceivers[kind];\n  const localCodec = preferredCodecs.find(codec => pcv2._localCodecs.has(codec));\n  if (!localCodec) {\n    return recycledTransceivers.shift();\n  }\n\n  const transceiver = recycledTransceivers.find(transceiver => {\n    const remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);\n    return remoteCodecMap && remoteCodecMap.has(localCodec);\n  });\n\n  if (transceiver) {\n    recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);\n  }\n  return transceiver;\n}\n\n/**\n * Update the set of locally supported {@link Codec}s.\n * @param pcv2\n * @returns {void}\n */\nfunction updateLocalCodecs(pcv2) {\n  const description = pcv2._peerConnection.localDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(section => {\n    const codecMap = createCodecMapForMediaSection(section);\n    codecMap.forEach((pts, codec) => pcv2._localCodecs.add(codec));\n  });\n}\n\n/**\n * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateRemoteCodecMaps(pcv2) {\n  const description = pcv2._peerConnection.remoteDescription;\n  if (!description || !description.sdp) {\n    return;\n  }\n  getMediaSections(description.sdp).forEach(section => {\n    const matched = section.match(/^a=mid:(.+)$/m);\n    if (!matched || !matched[1]) {\n      return;\n    }\n    const mid = matched[1];\n    const codecMap = createCodecMapForMediaSection(section);\n    pcv2._remoteCodecMaps.set(mid, codecMap);\n  });\n}\n\n/**\n * Update the list of recycled RTCRtpTransceivers.\n * @param {PeerConnectionV2} pcv2\n */\nfunction updateRecycledTransceivers(pcv2) {\n  pcv2._recycledTransceivers.audio = [];\n  pcv2._recycledTransceivers.video = [];\n  pcv2._peerConnection.getTransceivers().forEach(transceiver => {\n    if (shouldRecycleTransceiver(transceiver, pcv2)) {\n      const track = transceiver.receiver.track;\n      pcv2._recycledTransceivers[track.kind].push(transceiver);\n    }\n  });\n}\n\n/**\n * Perform certain updates after an SDP negotiation is completed.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction negotiationCompleted(pcv2) {\n  updateRecycledTransceivers(pcv2);\n  updateLocalCodecs(pcv2);\n  updateRemoteCodecMaps(pcv2);\n  updateEncodingParameters(pcv2).then(() => {\n    // if there any any publisher hints queued, apply them now.\n    pcv2._handleQueuedPublisherHints();\n  });\n}\n\n/**\n * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.\n * @param {PeerConnectionV2} pcv2\n * @returns {void}\n */\nfunction updateEncodingParameters(pcv2) {\n  const { maxAudioBitrate, maxVideoBitrate } = pcv2._encodingParameters;\n\n  const maxBitrates = new Map([\n    ['audio', maxAudioBitrate],\n    ['video', maxVideoBitrate]\n  ]);\n\n  const promises = [];\n  pcv2._peerConnection.getSenders().filter(sender => sender.track).forEach(sender => {\n    const maxBitrate = maxBitrates.get(sender.track.kind);\n    const params = sender.getParameters();\n\n    if (maxBitrate === null || maxBitrate === 0) {\n      removeMaxBitrate(params);\n    } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n      // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,\n      // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome\n      pcv2._log.warn(`Not setting maxBitrate for ${sender.track.kind} Track ${sender.track.id} because it appears to be screen share track: ${sender.track.label}`);\n    } else {\n      setMaxBitrate(params, maxBitrate);\n    }\n\n    if (!isFirefox && params.encodings.length > 0) {\n      if (sender.track.kind === 'audio') {\n        // NOTE(mmalavalli): \"priority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected. With this, audio encoding\n        // is prioritized the most.\n        params.encodings[0].priority = 'high';\n      } else if (pcv2._isChromeScreenShareTrack(sender.track)) {\n        // NOTE(mmalavalli): Screen share encodings are prioritized more than those\n        // of the camera.\n        params.encodings[0].priority = 'medium';\n      }\n      if (pcv2._enableDscp) {\n        // NOTE(mmalavalli): \"networkPriority\" is a per-sender property and not\n        // a per-encoding-layer property. So, we set the value only on the first\n        // encoding layer. Any attempt to set the value on subsequent encoding\n        // layers (in the case of simulcast) will result in the Promise returned\n        // by RTCRtpSender.setParameters() being rejected.\n        params.encodings[0].networkPriority = 'high';\n      }\n    }\n\n    // when a sender is reused, delete any active encodings set by server.\n    const trackReplaced = pcv2._rtpNewSenders.has(sender);\n    pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);\n    pcv2._rtpNewSenders.delete(sender);\n\n    const promise = sender.setParameters(params).catch(error => {\n      pcv2._log.warn(`Error while setting encodings parameters for ${sender.track.kind} Track ${sender.track.id}: ${error.message || error.name}`);\n    });\n    promises.push(promise);\n  });\n  return Promise.all(promises);\n}\n\n/**\n * Remove maxBitrate from the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @returns {void}\n */\nfunction removeMaxBitrate(params) {\n  if (Array.isArray(params.encodings)) {\n    params.encodings.forEach(encoding => delete encoding.maxBitrate);\n  }\n}\n\n/**\n * Set the given maxBitrate in the RTCRtpSendParameters' encodings.\n * @param {RTCRtpSendParameters} params\n * @param {number} maxBitrate\n * @returns {void}\n */\nfunction setMaxBitrate(params, maxBitrate) {\n  if (isFirefox) {\n    params.encodings = [{ maxBitrate }];\n  } else {\n    params.encodings.forEach(encoding => {\n      encoding.maxBitrate = maxBitrate;\n    });\n  }\n}\nmodule.exports = PeerConnectionV2;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}