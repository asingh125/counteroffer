{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar MediaTrackTransceiver = require('./transceiver');\n/**\n * A {@link MediaTrackSender} represents one or more local RTCRtpSenders.\n * @extends MediaTrackTransceiver\n * @emits MediaTrackSender#replaced\n */\nvar MediaTrackSender = /** @class */function (_super) {\n  __extends(MediaTrackSender, _super);\n  /**\n   * Construct a {@link MediaTrackSender}.\n   * @param {MediaStreamTrack} mediaStreamTrack\n   */\n  function MediaTrackSender(mediaStreamTrack) {\n    var _this = _super.call(this, mediaStreamTrack.id, mediaStreamTrack) || this;\n    Object.defineProperties(_this, {\n      _clones: {\n        value: new Set()\n      },\n      _eventsToReemitters: {\n        value: new Map([['mute', function () {\n          return _this.queue('muted');\n        }], ['unmute', function () {\n          return _this.queue('unmuted');\n        }]])\n      },\n      _senders: {\n        value: new Set()\n      },\n      _senderToPublisherHintCallbacks: {\n        value: new Map()\n      },\n      isPublishing: {\n        enumerable: true,\n        get: function () {\n          return !!this._clones.size;\n        }\n      },\n      muted: {\n        enumerable: true,\n        get: function () {\n          return this._track.muted;\n        }\n      }\n    });\n    _this._reemitMediaStreamTrackEvents();\n    return _this;\n  }\n  /**\n   * @private\n   */\n  MediaTrackSender.prototype._reemitMediaStreamTrackEvents = function (mediaStreamTrack) {\n    if (mediaStreamTrack === void 0) {\n      mediaStreamTrack = this._track;\n    }\n    var _a = this,\n      eventsToReemitters = _a._eventsToReemitters,\n      track = _a._track;\n    eventsToReemitters.forEach(function (reemitter, event) {\n      return mediaStreamTrack.addEventListener(event, reemitter);\n    });\n    if (track !== mediaStreamTrack) {\n      eventsToReemitters.forEach(function (reemitter, event) {\n        return track.removeEventListener(event, reemitter);\n      });\n      if (track.muted !== mediaStreamTrack.muted) {\n        var reemitter = eventsToReemitters.get(mediaStreamTrack.muted ? 'mute' : 'unmute');\n        reemitter();\n      }\n    }\n  };\n  /**\n   * Return a new {@link MediaTrackSender} containing a clone of the underlying\n   * MediaStreamTrack. No RTCRtpSenders are copied.\n   * @returns {MediaTrackSender}\n   */\n  MediaTrackSender.prototype.clone = function () {\n    var clone = new MediaTrackSender(this.track.clone());\n    this._clones.add(clone);\n    return clone;\n  };\n  /**\n   * Remove a cloned {@link MediaTrackSender}.\n   * @returns {void}\n   */\n  MediaTrackSender.prototype.removeClone = function (clone) {\n    this._clones.delete(clone);\n  };\n  /**\n   * Set the given MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack\n   * @returns {Promise<void>}\n   */\n  MediaTrackSender.prototype.setMediaStreamTrack = function (mediaStreamTrack) {\n    var _this = this;\n    var clones = Array.from(this._clones);\n    var senders = Array.from(this._senders);\n    return Promise.all(clones.map(function (clone) {\n      return clone.setMediaStreamTrack(mediaStreamTrack.clone());\n    }).concat(senders.map(function (sender) {\n      return _this._replaceTrack(sender, mediaStreamTrack);\n    }))).finally(function () {\n      _this._reemitMediaStreamTrackEvents(mediaStreamTrack);\n      _this._track = mediaStreamTrack;\n    });\n  };\n  /**\n   * Add an RTCRtpSender.\n   * @param {RTCRtpSender} sender\n   * @param {?()=>Promise<string>} publisherHintCallback\n   * @returns {this}\n   */\n  MediaTrackSender.prototype.addSender = function (sender, publisherHintCallback) {\n    this._senders.add(sender);\n    if (publisherHintCallback) {\n      this._senderToPublisherHintCallbacks.set(sender, publisherHintCallback);\n    }\n    return this;\n  };\n  /**\n   * Remove an RTCRtpSender.\n   * @param {RTCRtpSender} sender\n   * @returns {this}\n   */\n  MediaTrackSender.prototype.removeSender = function (sender) {\n    this._senders.delete(sender);\n    this._senderToPublisherHintCallbacks.delete(sender);\n    return this;\n  };\n  /**\n   * Applies given encodings, or resets encodings if none specified.\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>}\n   */\n  MediaTrackSender.prototype.setPublisherHint = function (encodings) {\n    // Note(mpatwardhan): since publisher hint applies only to group rooms we only look at 1st call callback.\n    var _a = __read(Array.from(this._senderToPublisherHintCallbacks.values()), 1),\n      publisherHintCallback = _a[0];\n    return publisherHintCallback ? publisherHintCallback(encodings) : Promise.resolve('COULD_NOT_APPLY_HINT');\n  };\n  MediaTrackSender.prototype._replaceTrack = function (sender, mediaStreamTrack) {\n    var _this = this;\n    return sender.replaceTrack(mediaStreamTrack).then(function (replaceTrackResult) {\n      // clear any publisherHints and apply default encodings.\n      _this.setPublisherHint(null).catch(function () {});\n      _this.emit('replaced');\n      return replaceTrackResult;\n    });\n  };\n  return MediaTrackSender;\n}(MediaTrackTransceiver);\n/**\n * The {@link MediaTrackSender}'s underlying MediaStreamTrack was muted.\n * @event MediaTrackSender#muted\n */\n/**\n * The {@link MediaTrackSender} replaced the underlying MediaStreamTrack.\n * @event MediaTrackSender#replaced\n */\n/**\n * The {@link MediaTrackSender}'s underlying MediaStreamTrack was unmuted.\n * @event MediaTrackSender#unmuted\n */\nmodule.exports = MediaTrackSender;","map":{"version":3,"mappings":"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","names":["MediaTrackTransceiver","require","__extends","mediaStreamTrack","_super","id","Object","defineProperties","_this","_clones","value","Set","_eventsToReemitters","Map","queue","_senders","_senderToPublisherHintCallbacks","isPublishing","enumerable","get","size","muted","_track","_reemitMediaStreamTrackEvents","MediaTrackSender","eventsToReemitters","track","forEach","reemitter","event","addEventListener","removeEventListener","clone","add","delete","clones","Array","from","senders","Promise","all","map","setMediaStreamTrack","concat","_replaceTrack","sender","finally","publisherHintCallback","set","encodings","values","resolve","replaceTrack","then","setPublisherHint","catch","emit","replaceTrackResult","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/media/track/sender.js"],"sourcesContent":["'use strict';\n\nconst MediaTrackTransceiver = require('./transceiver');\n\n/**\n * A {@link MediaTrackSender} represents one or more local RTCRtpSenders.\n * @extends MediaTrackTransceiver\n * @emits MediaTrackSender#replaced\n */\nclass MediaTrackSender extends MediaTrackTransceiver {\n  /**\n   * Construct a {@link MediaTrackSender}.\n   * @param {MediaStreamTrack} mediaStreamTrack\n   */\n  constructor(mediaStreamTrack) {\n    super(mediaStreamTrack.id, mediaStreamTrack);\n    Object.defineProperties(this, {\n      _clones: {\n        value: new Set()\n      },\n      _eventsToReemitters: {\n        value: new Map([\n          ['mute', () => this.queue('muted')],\n          ['unmute', () => this.queue('unmuted')]\n        ])\n      },\n      _senders: {\n        value: new Set()\n      },\n      _senderToPublisherHintCallbacks: {\n        value: new Map()\n      },\n      isPublishing: {\n        enumerable: true,\n        get() {\n          return !!this._clones.size;\n        }\n      },\n      muted: {\n        enumerable: true,\n        get() {\n          return this._track.muted;\n        }\n      }\n    });\n\n    this._reemitMediaStreamTrackEvents();\n  }\n\n  /**\n   * @private\n   */\n  _reemitMediaStreamTrackEvents(mediaStreamTrack = this._track) {\n    const { _eventsToReemitters: eventsToReemitters, _track: track } = this;\n    eventsToReemitters.forEach((reemitter, event) => mediaStreamTrack.addEventListener(event, reemitter));\n    if (track !== mediaStreamTrack) {\n      eventsToReemitters.forEach((reemitter, event) => track.removeEventListener(event, reemitter));\n      if (track.muted !== mediaStreamTrack.muted) {\n        const reemitter = eventsToReemitters.get(mediaStreamTrack.muted ? 'mute' : 'unmute');\n        reemitter();\n      }\n    }\n  }\n\n  /**\n   * Return a new {@link MediaTrackSender} containing a clone of the underlying\n   * MediaStreamTrack. No RTCRtpSenders are copied.\n   * @returns {MediaTrackSender}\n   */\n  clone() {\n    const clone = new MediaTrackSender(this.track.clone());\n    this._clones.add(clone);\n    return clone;\n  }\n\n  /**\n   * Remove a cloned {@link MediaTrackSender}.\n   * @returns {void}\n   */\n  removeClone(clone) {\n    this._clones.delete(clone);\n  }\n\n  /**\n   * Set the given MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack\n   * @returns {Promise<void>}\n   */\n  setMediaStreamTrack(mediaStreamTrack) {\n    const clones = Array.from(this._clones);\n    const senders = Array.from(this._senders);\n    return Promise.all(clones.map(clone => {\n      return clone.setMediaStreamTrack(mediaStreamTrack.clone());\n    }).concat(senders.map(sender => {\n      return this._replaceTrack(sender, mediaStreamTrack);\n    }))).finally(() => {\n      this._reemitMediaStreamTrackEvents(mediaStreamTrack);\n      this._track = mediaStreamTrack;\n    });\n  }\n\n  /**\n   * Add an RTCRtpSender.\n   * @param {RTCRtpSender} sender\n   * @param {?()=>Promise<string>} publisherHintCallback\n   * @returns {this}\n   */\n  addSender(sender, publisherHintCallback) {\n    this._senders.add(sender);\n    if (publisherHintCallback) {\n      this._senderToPublisherHintCallbacks.set(sender, publisherHintCallback);\n    }\n    return this;\n  }\n\n  /**\n   * Remove an RTCRtpSender.\n   * @param {RTCRtpSender} sender\n   * @returns {this}\n   */\n  removeSender(sender) {\n    this._senders.delete(sender);\n    this._senderToPublisherHintCallbacks.delete(sender);\n    return this;\n  }\n\n  /**\n   * Applies given encodings, or resets encodings if none specified.\n   * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings\n   * @returns {Promise<string>}\n   */\n  setPublisherHint(encodings) {\n    // Note(mpatwardhan): since publisher hint applies only to group rooms we only look at 1st call callback.\n    const [publisherHintCallback] = Array.from(this._senderToPublisherHintCallbacks.values());\n    return publisherHintCallback ? publisherHintCallback(encodings) : Promise.resolve('COULD_NOT_APPLY_HINT');\n  }\n\n  _replaceTrack(sender, mediaStreamTrack) {\n    return sender.replaceTrack(mediaStreamTrack).then(replaceTrackResult => {\n      // clear any publisherHints and apply default encodings.\n      this.setPublisherHint(null).catch(() => {});\n      this.emit('replaced');\n      return replaceTrackResult;\n    });\n  }\n}\n\n/**\n * The {@link MediaTrackSender}'s underlying MediaStreamTrack was muted.\n * @event MediaTrackSender#muted\n */\n\n/**\n * The {@link MediaTrackSender} replaced the underlying MediaStreamTrack.\n * @event MediaTrackSender#replaced\n */\n\n/**\n * The {@link MediaTrackSender}'s underlying MediaStreamTrack was unmuted.\n * @event MediaTrackSender#unmuted\n */\n\nmodule.exports = MediaTrackSender;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}