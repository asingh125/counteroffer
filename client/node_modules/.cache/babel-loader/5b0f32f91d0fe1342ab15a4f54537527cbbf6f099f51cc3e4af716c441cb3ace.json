{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar _a = require('../'),\n  difference = _a.difference,\n  flatMap = _a.flatMap;\n/**\n * Create a random {@link SSRC}.\n * @returns {SSRC}\n */\nfunction createSSRC() {\n  var ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n/**\n * @property {string} cName\n * @property {boolean} isSimulcastEnabled\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\n * @property {Set<PrimarySSRC>} primarySSRCs\n * @property {string} streamId\n * @property {Track.ID} trackId\n */\nvar TrackAttributes = /** @class */function () {\n  /**\n   * Construct a {@link MediaStreamTrack} attribute store.\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\n   * @param {MediaStreamID} streamId - The MediaStream ID\n   * @param {string} cName - The MediaStream cname\n   */\n  function TrackAttributes(trackId, streamId, cName) {\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n  /**\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\n   * @returns {void}\n   */\n  TrackAttributes.prototype.addSimulcastSSRCs = function () {\n    if (this.isSimulcastEnabled) {\n      return;\n    }\n    var simulcastSSRCs = [createSSRC(), createSSRC()];\n    simulcastSSRCs.forEach(function (ssrc) {\n      this.primarySSRCs.add(ssrc);\n    }, this);\n    if (this.rtxPairs.size) {\n      simulcastSSRCs.forEach(function (ssrc) {\n        this.rtxPairs.set(createSSRC(), ssrc);\n      }, this);\n    }\n  };\n  /**\n   * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\n   * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\n   * @param {SSRC} ssrc - The {@link SSRC} to be added\n   * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\n   *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\n   * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\n   *   {@link SimSSRC}; false otherwise\n   * @returns {void}\n   */\n  TrackAttributes.prototype.addSSRC = function (ssrc, primarySSRC, isSimSSRC) {\n    if (primarySSRC) {\n      this.rtxPairs.set(ssrc, primarySSRC);\n    } else {\n      this.primarySSRCs.add(ssrc);\n    }\n    this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n  };\n  /**\n   * Construct the SDP lines for the {@link TrackAttributes}.\n   * @param {boolean} [excludeRtx=false]\n   * @returns {Array<string>} Array of SDP lines\n   */\n  TrackAttributes.prototype.toSdpLines = function (excludeRtx) {\n    var _this = this;\n    var rtxPairs = excludeRtx ? [] : Array.from(this.rtxPairs.entries()).map(function (rtxPair) {\n      return rtxPair.reverse();\n    });\n    var simSSRCs = Array.from(this.primarySSRCs.values());\n    var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n    var attrLines = flatMap(ssrcs, function (ssrc) {\n      return [\"a=ssrc:\" + ssrc + \" cname:\" + _this.cName, \"a=ssrc:\" + ssrc + \" msid:\" + _this.streamId + \" \" + _this.trackId];\n    });\n    var rtxPairLines = rtxPairs.map(function (rtxPair) {\n      return \"a=ssrc-group:FID \" + rtxPair.join(' ');\n    });\n    var simGroupLines = [\"a=ssrc-group:SIM \" + simSSRCs.join(' ')];\n    return rtxPairLines.concat(attrLines).concat(simGroupLines);\n  };\n  return TrackAttributes;\n}();\n/**\n * Get the matches for a given RegEx pattern.\n * @param {string} section - SDP media section\n * @param {string} pattern - RegEx pattern\n * @returns {Array<Array<string>>} - Array of pattern matches\n */\nfunction getMatches(section, pattern) {\n  var matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(function (match) {\n    var matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n/**\n * Get the {@link SimSSRC}s that belong to a simulcast group.\n * @param {string} section - SDP media section\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\n */\nfunction getSimulcastSSRCs(section) {\n  var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n/**\n * Get the value of the given attribute for an SSRC.\n * @param {string} section - SDP media section\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\n * @param {string} attribute - {@link SSRC} attribute name\n * @param {string} - {@link SSRC} attribute value\n */\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  var pattern = \"a=ssrc:\" + ssrc + \" \" + attribute + \":(.+)\";\n  return section.match(new RegExp(pattern))[1];\n}\n/**\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\n * @param {string} section - SDP media section\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\n *   corresponding {@link PrimarySSRC}s\n */\nfunction getSSRCRtxPairs(section) {\n  var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(function (pair) {\n    return pair.reverse();\n  }));\n}\n/**\n * Create SSRC attribute tuples.\n * @param {string} section\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\n */\nfunction createSSRCAttributeTuples(section) {\n  var _a = __read(flatMap(getMatches(section, '^a=msid:(.+) (.+)$')), 2),\n    streamId = _a[0],\n    trackId = _a[1];\n  var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(function (ssrc) {\n    return [ssrc, streamId, trackId];\n  });\n}\n/**\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\n * @param {string} section - SDP media section\n * @returns {Map<Track.ID, TrackAttributes>}\n */\nfunction createTrackIdsToAttributes(section) {\n  var simSSRCs = getSimulcastSSRCs(section);\n  var rtxPairs = getSSRCRtxPairs(section);\n  var ssrcAttrTuples = createSSRCAttributeTuples(section);\n  return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {\n    var ssrc = tuple[0];\n    var streamId = tuple[1];\n    var trackId = tuple[2];\n    var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));\n    var primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n/**\n * Apply simulcast settings to the given SDP media section.\n * @param {string} section - SDP media section\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\n *   map which will be updated for new MediaStreamTrack IDs\n * @returns {string} - The transformed SDP media section\n */\nfunction setSimulcastInMediaSection(section, trackIdsToAttributes) {\n  var newTrackIdsToAttributes = createTrackIdsToAttributes(section);\n  var newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  var trackIds = Array.from(trackIdsToAttributes.keys());\n  var trackIdsToAdd = difference(newTrackIds, trackIds);\n  var trackIdsToIgnore = difference(trackIds, newTrackIds);\n  // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n  var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) {\n    return newTrackIdsToAttributes.get(trackId);\n  });\n  trackAttributesToAdd.forEach(function (trackAttributes) {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  });\n  // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  var relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) {\n    return trackIdsToAttributes.get(trackId);\n  });\n  var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) {\n    return trackAttributes.toSdpLines(excludeRtx);\n  });\n  // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n  var sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n  var xGoogleFlagConference = 'a=x-google-flag:conference';\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n  return sectionLines.join('\\r\\n');\n}\n/**\n * String representing a MediaStream ID.\n * @typedef {string} MediaStreamID\n */\n/**\n * String representing the SSRC of a MediaStreamTrack.\n * @typedef {string} SSRC\n */\n/**\n * Primary SSRC.\n * @typedef {SSRC} PrimarySSRC\n */\n/**\n * Retransmission SSRC.\n * @typedef {SSRC} RtxSSRC\n */\n/**\n * Simulcast SSRC.\n * @typedef {SSRC} SimSSRC\n */\nmodule.exports = setSimulcastInMediaSection;","map":{"version":3,"mappings":"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","names":["require","difference","flatMap","createSSRC","ssrcMax","String","Math","floor","random","trackId","streamId","cName","Object","defineProperties","enumerable","value","isSimulcastEnabled","writable","primarySSRCs","Set","rtxPairs","Map","TrackAttributes","simulcastSSRCs","forEach","ssrc","add","size","set","primarySSRC","isSimSSRC","excludeRtx","Array","from","entries","map","reverse","simSSRCs","values","ssrcs","length","attrLines","_this","rtxPairLines","rtxPair","join","simGroupLines","concat","getMatches","section","pattern","matches","match","RegExp","slice","getSimulcastSSRCs","simGroupPattern","getSSRCAttribute","attribute","getSSRCRtxPairs","rtxPairPattern","createSSRCAttributeTuples","createTrackIdsToAttributes","ssrcAttrTuples","reduce","trackIdsToSSRCs","tuple","trackAttributes","get","addSSRC","has","setSimulcastInMediaSection","trackIdsToAttributes","newTrackIdsToAttributes","newTrackIds","keys","trackIds","trackIdsToAdd","trackIdsToIgnore","trackAttributesToAdd","addSimulcastSSRCs","relevantTrackIds","relevantTrackAttributes","relevantSdpLines","toSdpLines","sectionLines","split","xGoogleFlagConference","push","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/util/sdp/simulcast.js"],"sourcesContent":["'use strict';\n\nconst { difference, flatMap } = require('../');\n\n/**\n * Create a random {@link SSRC}.\n * @returns {SSRC}\n */\nfunction createSSRC() {\n  const ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n\n/**\n * @property {string} cName\n * @property {boolean} isSimulcastEnabled\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\n * @property {Set<PrimarySSRC>} primarySSRCs\n * @property {string} streamId\n * @property {Track.ID} trackId\n */\nclass TrackAttributes {\n  /**\n   * Construct a {@link MediaStreamTrack} attribute store.\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\n   * @param {MediaStreamID} streamId - The MediaStream ID\n   * @param {string} cName - The MediaStream cname\n   */\n  constructor(trackId, streamId, cName) {\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n\n  /**\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\n   * @returns {void}\n   */\n  addSimulcastSSRCs() {\n    if (this.isSimulcastEnabled) {\n      return;\n    }\n    const simulcastSSRCs = [createSSRC(), createSSRC()];\n    simulcastSSRCs.forEach(function(ssrc) {\n      this.primarySSRCs.add(ssrc);\n    }, this);\n\n    if (this.rtxPairs.size) {\n      simulcastSSRCs.forEach(function(ssrc) {\n        this.rtxPairs.set(createSSRC(), ssrc);\n      }, this);\n    }\n  }\n\n  /**\n   * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\n   * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\n   * @param {SSRC} ssrc - The {@link SSRC} to be added\n   * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\n   *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\n   * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\n   *   {@link SimSSRC}; false otherwise\n   * @returns {void}\n   */\n  addSSRC(ssrc, primarySSRC, isSimSSRC) {\n    if (primarySSRC) {\n      this.rtxPairs.set(ssrc, primarySSRC);\n    } else {\n      this.primarySSRCs.add(ssrc);\n    }\n    this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n  }\n\n  /**\n   * Construct the SDP lines for the {@link TrackAttributes}.\n   * @param {boolean} [excludeRtx=false]\n   * @returns {Array<string>} Array of SDP lines\n   */\n  toSdpLines(excludeRtx) {\n    const rtxPairs = excludeRtx\n      ? []\n      : Array.from(this.rtxPairs.entries()).map(rtxPair => rtxPair.reverse());\n\n    const simSSRCs = Array.from(this.primarySSRCs.values());\n    const ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n\n    const attrLines = flatMap(ssrcs, ssrc => [\n      `a=ssrc:${ssrc} cname:${this.cName}`,\n      `a=ssrc:${ssrc} msid:${this.streamId} ${this.trackId}`\n    ]);\n    const rtxPairLines = rtxPairs.map(rtxPair => `a=ssrc-group:FID ${rtxPair.join(' ')}`);\n    const simGroupLines = [\n      `a=ssrc-group:SIM ${simSSRCs.join(' ')}`\n    ];\n\n    return rtxPairLines.concat(attrLines).concat(simGroupLines);\n  }\n}\n\n/**\n * Get the matches for a given RegEx pattern.\n * @param {string} section - SDP media section\n * @param {string} pattern - RegEx pattern\n * @returns {Array<Array<string>>} - Array of pattern matches\n */\nfunction getMatches(section, pattern) {\n  const matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(match => {\n    const matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n\n/**\n * Get the {@link SimSSRC}s that belong to a simulcast group.\n * @param {string} section - SDP media section\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\n */\nfunction getSimulcastSSRCs(section) {\n  const simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n\n/**\n * Get the value of the given attribute for an SSRC.\n * @param {string} section - SDP media section\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\n * @param {string} attribute - {@link SSRC} attribute name\n * @param {string} - {@link SSRC} attribute value\n */\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  const pattern = `a=ssrc:${ssrc} ${attribute}:(.+)`;\n  return section.match(new RegExp(pattern))[1];\n}\n\n/**\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\n * @param {string} section - SDP media section\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\n *   corresponding {@link PrimarySSRC}s\n */\nfunction getSSRCRtxPairs(section) {\n  const rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(pair => pair.reverse()));\n}\n\n/**\n * Create SSRC attribute tuples.\n * @param {string} section\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\n */\nfunction createSSRCAttributeTuples(section) {\n  const [streamId, trackId] = flatMap(getMatches(section, '^a=msid:(.+) (.+)$'));\n  const ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(ssrc => [ssrc, streamId, trackId]);\n}\n\n/**\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\n * @param {string} section - SDP media section\n * @returns {Map<Track.ID, TrackAttributes>}\n */\nfunction createTrackIdsToAttributes(section) {\n  const simSSRCs = getSimulcastSSRCs(section);\n  const rtxPairs = getSSRCRtxPairs(section);\n  const ssrcAttrTuples = createSSRCAttributeTuples(section);\n\n  return ssrcAttrTuples.reduce((trackIdsToSSRCs, tuple) => {\n    const ssrc = tuple[0];\n    const streamId = tuple[1];\n    const trackId = tuple[2];\n\n    const trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(\n      trackId,\n      streamId,\n      getSSRCAttribute(section, ssrc, 'cname'));\n\n    const primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n\n/**\n * Apply simulcast settings to the given SDP media section.\n * @param {string} section - SDP media section\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\n *   map which will be updated for new MediaStreamTrack IDs\n * @returns {string} - The transformed SDP media section\n */\nfunction setSimulcastInMediaSection(section, trackIdsToAttributes) {\n  const newTrackIdsToAttributes = createTrackIdsToAttributes(section);\n  const newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  let trackIds = Array.from(trackIdsToAttributes.keys());\n  const trackIdsToAdd = difference(newTrackIds, trackIds);\n  const trackIdsToIgnore = difference(trackIds, newTrackIds);\n\n  // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n  const trackAttributesToAdd = flatMap(trackIdsToAdd, trackId => newTrackIdsToAttributes.get(trackId));\n  trackAttributesToAdd.forEach(trackAttributes => {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  });\n\n  // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  const relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  const relevantTrackAttributes = flatMap(relevantTrackIds, trackId => trackIdsToAttributes.get(trackId));\n  const excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  const relevantSdpLines = flatMap(relevantTrackAttributes, trackAttributes => trackAttributes.toSdpLines(excludeRtx));\n\n  // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n  const sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n\n  const xGoogleFlagConference = 'a=x-google-flag:conference';\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n\n  return sectionLines.join('\\r\\n');\n}\n\n/**\n * String representing a MediaStream ID.\n * @typedef {string} MediaStreamID\n */\n\n/**\n * String representing the SSRC of a MediaStreamTrack.\n * @typedef {string} SSRC\n */\n\n/**\n * Primary SSRC.\n * @typedef {SSRC} PrimarySSRC\n */\n\n/**\n * Retransmission SSRC.\n * @typedef {SSRC} RtxSSRC\n */\n\n/**\n * Simulcast SSRC.\n * @typedef {SSRC} SimSSRC\n */\n\nmodule.exports = setSimulcastInMediaSection;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}