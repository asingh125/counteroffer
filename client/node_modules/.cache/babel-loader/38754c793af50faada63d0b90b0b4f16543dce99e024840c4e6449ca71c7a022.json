{"ast":null,"code":"'use strict';\n\n/**\n * The {@link DocumentVisibilityMonitor} monitors the visibility state of the DOM\n * and executes the attached listeners in phase order when the DOM is visible.\n */\nvar DocumentVisibilityMonitor = /** @class */function () {\n  /**\n   * Constructor.\n   * @param {number} [nPhases=1] - the number of phases\n   */\n  function DocumentVisibilityMonitor(nPhases) {\n    var _this = this;\n    if (nPhases === void 0) {\n      nPhases = 1;\n    }\n    Object.defineProperties(this, {\n      _listeners: {\n        value: []\n      },\n      _onVisibilityChange: {\n        value: function () {\n          _this._emitVisible(document.visibilityState === 'visible');\n        }\n      }\n    });\n    for (var i = 0; i < nPhases; i++) {\n      this._listeners.push([]);\n    }\n  }\n  /**\n   * clears the state.\n   */\n  DocumentVisibilityMonitor.prototype.clear = function () {\n    var nPhases = this._listeners.length;\n    for (var i = 0; i < nPhases; i++) {\n      this._listeners[i] = [];\n    }\n  };\n  DocumentVisibilityMonitor.prototype._listenerCount = function () {\n    return this._listeners.reduce(function (count, phaseListeners) {\n      return count + phaseListeners.length;\n    }, 0);\n  };\n  /**\n   * Call all the listeners. Makes sure that all listeners for a given phase\n   * are executed before calling the listeners of the next phase.\n   * @private\n   */\n  DocumentVisibilityMonitor.prototype._emitVisible = function (isVisible) {\n    var _this = this;\n    var promise = Promise.resolve();\n    var _loop_1 = function (phase) {\n      promise = promise.then(function () {\n        return _this._emitVisiblePhase(phase, isVisible);\n      });\n    };\n    for (var phase = 1; phase <= this._listeners.length; phase++) {\n      _loop_1(phase);\n    }\n    return promise;\n  };\n  /**\n   * Call all the listeners for a given phase.\n   * @private\n   */\n  DocumentVisibilityMonitor.prototype._emitVisiblePhase = function (phase, isVisible) {\n    var phaseListeners = this._listeners[phase - 1];\n    return Promise.all(phaseListeners.map(function (listener) {\n      var ret = listener(isVisible);\n      return ret instanceof Promise ? ret : Promise.resolve(ret);\n    }));\n  };\n  /**\n   * Start listening to the DOM visibility state change.\n   * @private\n   */\n  DocumentVisibilityMonitor.prototype._start = function () {\n    document.addEventListener('visibilitychange', this._onVisibilityChange);\n  };\n  /**\n   * Stop listening to the DOM visibility state change.\n   * @private\n   */\n  DocumentVisibilityMonitor.prototype._stop = function () {\n    document.removeEventListener('visibilitychange', this._onVisibilityChange);\n  };\n  /**\n   * Listen for the DOM visibility changes at the given phase.\n   * @param {number} phase\n   * @param {function} listener\n   * @returns {this}\n   */\n  DocumentVisibilityMonitor.prototype.onVisibilityChange = function (phase, listener) {\n    if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {\n      throw new Error('invalid phase: ', phase);\n    }\n    var phaseListeners = this._listeners[phase - 1];\n    phaseListeners.push(listener);\n    if (this._listenerCount() === 1) {\n      this._start();\n    }\n    return this;\n  };\n  /**\n   * Stop listening for the DOM visibility change at the given phase.\n   * @param {number} phase\n   * @param {function} listener\n   * @returns {this}\n   */\n  DocumentVisibilityMonitor.prototype.offVisibilityChange = function (phase, listener) {\n    if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {\n      throw new Error('invalid phase: ', phase);\n    }\n    var phaseListeners = this._listeners[phase - 1];\n    var index = phaseListeners.indexOf(listener);\n    if (index !== -1) {\n      phaseListeners.splice(index, 1);\n      if (this._listenerCount() === 0) {\n        this._stop();\n      }\n    }\n    return this;\n  };\n  return DocumentVisibilityMonitor;\n}();\nmodule.exports = new DocumentVisibilityMonitor(2);","map":{"version":3,"mappings":"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","names":["nPhases","Object","defineProperties","_listeners","value","_onVisibilityChange","_this","_emitVisible","document","visibilityState","i","push","DocumentVisibilityMonitor","length","reduce","count","phaseListeners","isVisible","promise","Promise","resolve","phase","then","_emitVisiblePhase","all","map","ret","listener","addEventListener","removeEventListener","Error","_listenerCount","_start","index","indexOf","splice","_stop","module","exports"],"sources":["/Users/aarushisingh/Projects/counteroffer/client/node_modules/twilio-video/lib/util/documentvisibilitymonitor.js"],"sourcesContent":["'use strict';\n\n/**\n * The {@link DocumentVisibilityMonitor} monitors the visibility state of the DOM\n * and executes the attached listeners in phase order when the DOM is visible.\n */\nclass DocumentVisibilityMonitor {\n  /**\n   * Constructor.\n   * @param {number} [nPhases=1] - the number of phases\n   */\n  constructor(nPhases = 1) {\n    Object.defineProperties(this, {\n      _listeners: {\n        value: []\n      },\n      _onVisibilityChange: {\n        value: () => {\n          this._emitVisible(document.visibilityState === 'visible');\n        }\n      }\n    });\n\n    for (let i = 0; i < nPhases; i++) {\n      this._listeners.push([]);\n    }\n  }\n\n\n  /**\n   * clears the state.\n   */\n  clear() {\n    const nPhases = this._listeners.length;\n    for (let i = 0; i < nPhases; i++) {\n      this._listeners[i] = [];\n    }\n  }\n\n  _listenerCount() {\n    return this._listeners.reduce((count, phaseListeners) => count + phaseListeners.length, 0);\n  }\n\n  /**\n   * Call all the listeners. Makes sure that all listeners for a given phase\n   * are executed before calling the listeners of the next phase.\n   * @private\n   */\n  _emitVisible(isVisible) {\n    let promise = Promise.resolve();\n    for (let phase = 1; phase <= this._listeners.length; phase++) {\n      promise = promise.then(() => this._emitVisiblePhase(phase, isVisible));\n    }\n    return promise;\n  }\n\n  /**\n   * Call all the listeners for a given phase.\n   * @private\n   */\n  _emitVisiblePhase(phase, isVisible) {\n    const phaseListeners = this._listeners[phase - 1];\n    return Promise.all(phaseListeners.map(listener => {\n      const ret = listener(isVisible);\n      return ret instanceof Promise ? ret : Promise.resolve(ret);\n    }));\n  }\n\n  /**\n   * Start listening to the DOM visibility state change.\n   * @private\n   */\n  _start() {\n    document.addEventListener('visibilitychange', this._onVisibilityChange);\n  }\n\n  /**\n   * Stop listening to the DOM visibility state change.\n   * @private\n   */\n  _stop() {\n    document.removeEventListener('visibilitychange', this._onVisibilityChange);\n  }\n\n  /**\n   * Listen for the DOM visibility changes at the given phase.\n   * @param {number} phase\n   * @param {function} listener\n   * @returns {this}\n   */\n  onVisibilityChange(phase, listener) {\n    if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {\n      throw new Error('invalid phase: ', phase);\n    }\n    const phaseListeners = this._listeners[phase - 1];\n    phaseListeners.push(listener);\n    if (this._listenerCount() === 1) {\n      this._start();\n    }\n    return this;\n  }\n\n  /**\n   * Stop listening for the DOM visibility change at the given phase.\n   * @param {number} phase\n   * @param {function} listener\n   * @returns {this}\n   */\n  offVisibilityChange(phase, listener) {\n    if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {\n      throw new Error('invalid phase: ', phase);\n    }\n\n    const phaseListeners = this._listeners[phase - 1];\n    const index = phaseListeners.indexOf(listener);\n    if (index !== -1) {\n      phaseListeners.splice(index, 1);\n      if (this._listenerCount() === 0) {\n        this._stop();\n      }\n    }\n    return this;\n  }\n}\n\nmodule.exports = new DocumentVisibilityMonitor(2);\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}